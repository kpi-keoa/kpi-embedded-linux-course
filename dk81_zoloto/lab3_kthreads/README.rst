=====================================
**Лабораторна робота №3 Потоки ядра**
=====================================

Завдання:
---------------
Написати модуль ядра, який виконує наступні дії:

* Приймає три параметри thread_num, thread_inccnt та thread_delay
* Запускає thread_num потоків на одночасне виконання
* Кожен поток інкрементує глобальну змінну glob_var thread_inccnt разів із затримкою thread_delay
* Зберігає отримане значення змінної у список
* При вивантаженні модуль повинен виводити остаточне значення glob_var та вміст списку

**Хід роботи**

При виконанні декількох потоків вони будуть незмінно взаємодіяти один з одним, щоб синхронізувати своє виконання.
Існує кілька методів синхронізації потоків:
  * Блоки взаємного виключення (Mutex);
  * Спінлоки;
  * Семафори.
  
Завдяки об'єктам синхронізації багатопоточна програма може без проблем опрацьовувати критичні ділянки коду та дозволяє
працювати потокам і при конкурентній роботі не руйнючи послідовність одне одного.

``Семафори`` - добре зрозуміла концепція в комп'ютерній науці. За своєю суттю, семафор це одне ціле значення в поєднанні з парою функцій, які зазвичай називаються Р і V. Процес, який бажає увійти в критичну секцію, викличе Р на відповідному семафорі; якщо в семафорі значення більше нуля, це значення зменшується на одиницю і цей процес проддовжується. Якщо, навпаки, в семафорі значення дорівнює 0 (або менше), процес повинен чекати, поки хто-небудь інший звільнить семафор. Розблокування семафора здійснюється викликом V, ця функція збільшує значення семафора і, якщо необхідно, будить очікують процеси.

Коли семафори використовуються для взаємного виключення, оберігаючи безліч процесів від одночасного виконання в критичній секції, їх значення буде проініціалізувати в 1. Такий семафор в будь-який даний момент часу може утримуватися тільки одним процесом або потоком. Семафор, який використовується в цьому режимі, іноді називають ``м'ютекс`` (прапор), що, звичайно ж, розшифровується як "взаємне виключення "(mutex, mutual exclusion). Майже всі семафори, знайдені в ядрі Linux, використовуються для взаємного виключення.

``Спін-блокування`` - семафори є корисним інструментом для взаємного виключення, але вони є не єдиним таким інструментом, що надаються ядром. Замість цього, більшість блокувань здійснюється механізмом, названим спін-блокуванням. На відміну від семафорів, спін-блокування можуть бути використані в коді, який не може спати, такому, як обробники переривань. При правильному застосуванні, спін-блокування пропонують в цілому більш високу продуктивність, ніж семафори. Вони, однак, мають інший набір обмежень на своє використання.

**Результат**
---------

module `no_sync`
~~~~~~~~~~~~~~

.. code-block::

	/mnt # insmod no_sync.ko thread_num=10 thread_inccnt=50 thread_delay=50
	[  174.400609] no_sync started with: thread_num = 10,
	[  174.400609]                   thread_inccnt = 50
	[  174.400609]                   thread_delay = 50
	.
	.
	.
	[  177.563403] no_sync: Thread glob_var: 494
	[  177.564442] no_sync: Thread glob_var: 495
	[  177.564507] no_sync: Thread glob_var: 493
	[  177.564844] no_sync: Thread glob_var: 499
	[  177.565173] no_sync: Thread glob_var: 497
	/mnt # rmmod no_sync.
	[  178.726873] no_sync: node[0] glob_var_saved = 498
	[  178.727086] no_sync: node[1] glob_var_saved = 496
	[  178.727500] no_sync: node[2] glob_var_saved = 492
	[  178.727616] no_sync: node[3] glob_var_saved = 494
	[  178.727880] no_sync: node[4] glob_var_saved = 491
	[  178.727998] no_sync: node[5] glob_var_saved = 493
	[  178.728156] no_sync: node[6] glob_var_saved = 499
	[  178.728269] no_sync: node[7] glob_var_saved = 490
	[  178.728381] no_sync: node[8] glob_var_saved = 495
	[  178.728482] no_sync: node[9] glob_var_saved = 497
	[  178.728947] no_sync: glob_var = 499

module `mutex_sync`
~~~~~~~~~~~~~~~~~~~~~

.. code-block::

	/mnt # insmod mutex_sync.ko thread_num=10 thread_inccnt=100 thread_delay=1
	[  473.440283] mutex_sync started with: thread_num = 10,
	[  473.440283]                   thread_inccnt = 100
	[  473.440283]                   thread_delay = 1
	.
	.
	.
	[  436.244252] mutex_sync: Thread glob_var: 995
	[  436.245005] mutex_sync: Thread glob_var: 996
	[  436.279058] mutex_sync: Thread glob_var: 997
	[  436.280855] mutex_sync: Thread glob_var: 998
	[  436.282833] mutex_sync: Thread glob_var: 999
	[  436.285878] mutex_sync: Thread glob_var: 1000
	/mnt # rmmod mutex_sync.
	[  439.846076] mutex_sync: node[0] glob_var_saved = 935
	[  439.846531] mutex_sync: node[1] glob_var_saved = 951
	[  439.846844] mutex_sync: node[2] glob_var_saved = 958
	[  439.847086] mutex_sync: node[3] glob_var_saved = 981
	[  439.847262] mutex_sync: node[4] glob_var_saved = 986
	[  439.847380] mutex_sync: node[5] glob_var_saved = 985
	[  439.847699] mutex_sync: node[6] glob_var_saved = 993
	[  439.847957] mutex_sync: node[7] glob_var_saved = 995
	[  439.848116] mutex_sync: node[8] glob_var_saved = 994
	[  439.848237] mutex_sync: node[9] glob_var_saved = 1000
	[  439.848396] mutex_sync: glob_var = 1000
З використанням mutex

module `my_sync`
~~~~~~~~~~~~~~~~~~~~~

.. code-block::

	/mnt # insmod my_sync.ko thread_num=10 thread_inccnt=100 thread_delay=1
	[  539.582722] my_sync started with: thread_num = 10,
	[  539.582722]                   thread_inccnt = 100
	[  539.582722]                   thread_delay = 1
	.
	.
	.
	[  539.863702] my_sync: Thread glob_var: 996
	[  539.863782] my_sync: Thread glob_var: 997
	[  539.866730] my_sync: Thread glob_var: 999
	[  539.866780] my_sync: Thread glob_var: 998
	[  539.868746] my_sync: Thread glob_var: 1000

	/mnt # rmmod my_sync.
	[  572.338692] my_sync: node[0] glob_var_saved = 924
	[  572.339945] my_sync: node[1] glob_var_saved = 966
	[  572.340080] my_sync: node[2] glob_var_saved = 967
	[  572.340265] my_sync: node[3] glob_var_saved = 978
	[  572.340425] my_sync: node[4] glob_var_saved = 979
	[  572.340706] my_sync: node[5] glob_var_saved = 985
	[  572.340877] my_sync: node[6] glob_var_saved = 990
	[  572.340981] my_sync: node[7] glob_var_saved = 991
	[  572.341096] my_sync: node[8] glob_var_saved = 998
	[  572.341209] my_sync: node[9] glob_var_saved = 1000
        [  572.341363] my_sync: glob_var = 1000

**Використані бібліотеки**

* ``<linux/module.h>`` - потрібна для всіх модулів   
* ``<linux/moduleparam.h>`` - для використання макросів параметрів     
* ``<linux/kernel.h>`` - заголовки ядра    
* ``<linux/init.h>`` - використовується для ініціалізації та деініціалізації 
* ``<linux/list.h>`` - необхідна для ініціалізації та використання списків
* ``<linux/kthread.h>`` - необхідня для роботи з потоками ядра
* ``<linux/sched/task.h>`` - необхідна для перемикання між задачами
* ``<linux/mutex.h>`` - необхідна для синхронізації потоків між собою
* ``<linux/bitops.h>`` - необхідна для атомарних побітових операцій


**Використані макроси та функції**


``MODULE_DESCRIPTION`` - макрос для опису модуля    

``MODULE_AUTHOR`` - автор модуля    

``MODULE_VERSION`` - версія модуля    

``MODULE_LICENSE`` - тип ліцензії  

``module_param`` - передача параметрів в модуль    

``MODULE_PARM_DESC`` - опис параметра

``LIST_HEAD`` - створення списку, який ініціалізується під час компіляції

``INIT_LIST_HEAD`` - ініціалізує список з одного елемента

``DEFINE_MUTEX`` - статично визначає mutex

``kthread_run`` - створює та запускає потік

``kthread_stop`` - зупиняє потік

``get_task_struct`` - задає потоку нову задачу на виконання

``put_task_struct`` - зніма з потоку задачу на виконання

``list_add_tail`` - додає у кінець списку новий елемент

``list_del`` - видаляє елемент зі списку

``list_for_each_entry_safe`` - проходить по усім елементам списку з можливістю одночасного їх видалення

``mutex_lock`` - забороняє іншим потокам виконувати наступний код

``mutex_unlock`` - дозволяє наступному потоку виконувати наступний код

``test_and_set_bit`` - встановлює біт в 1 та повертає його попереднє значення

``clear_bit`` - встановлює біт в 0

``schedule`` - перемикає на іншу задачу

``schedule_timeout_uninterruptible`` - реалізує затримку у значеннях jiffies без дозволу на переривання

Висновки:
-------------

Як видно з результатів виконання лабораторної роботи, При роботі модуля ядра без синхронізацій, глобальна змінна інкрементується з невеликими похибками. При роботі з готовими реалізаціями синхронізацій mutex видно, що глобальна змінна інкрементується вірно. Інструменти синхронізації використовуються в основному для захисту критичних точок спрацювання ядра.
