=====================
Лабораторна робота №5
=====================

Тема
------

**Потоки ядра та методи синхронізації**

Завдання:
---------

Написати та зібрати  власний модуль ядра, який:
	* Принимает аргументы th_val, wrk_val и jffdelay, реализует два потока и ворк (в дефолтном work queue), а также таймер (на базе timer wheel)
	* Запускает таймер и ворк
	* При срабатывании таймера проверяет текущее значение jiffies, если оно кратно th_val – остановить первый поток; иначе – таймер перезапускается через jffdelay jiffies
	* Внутри ворка проверяет текущее значение jiffies, если оно кратно wrk_val - остановить второй поток; иначе – ворк должен уснуть на jffdelay jiffies и перезапустить себя.

А також:
	* Проверить работу. Для th_val и wrk_val желательно выбирать простые числа
	* Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies которые не привели к завершению первого и второго потоков соответственно. Получается связь "таймер – 1й список – 1й поток" и  "ворк – 2й список – 2й поток"
	* При выходе из потока распечатать список
	* Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию доступа к списку
	* Предусмотреть, что пользователь может выгрузить модуль досрочно

Хід роботи:
----------

При виконанні даної лабораторної роботи було застосовано таймери (timer whell), потоки і списки. Все це було вже використано при виконанні попередніх лабораторних робіт.Серед нових елементів, які були використані в даній лабораторній роботі, є workqueue. Workqueue, як і tasklet з поперездньої лабораторної, служать для відкладеної обробки данних, але, на відміну від tasklet'ів, вони виконуються в контексті потоку, і вони не є атомарними і тому можуть спати.

Виконання функції в контексті переривання повинно відбуватися максимально швидко. Тому якщо потрібно драйверу в момент переривання виконати 
якийсь великий обсяг роботи, то має сенс помістити функцію в чергу завдань (workqueue), для її відкладеного виконання. Після приміщення функції в чергу (за допомогою функції schedule_work),
вона буде виконана, коли до неї дійде черга в контексті ядра(як то кажуть вистрелить коли потрібно). 
Також варто відмітити, що workqueue обробляється спеціальними потоками, які звуться worker-ами. Worker-и забезпечують асинхронне виконання work'ов з workqueue.
Хоча вони й викликають work'и в порядку черги, але в загальному випадку про послідовне виконання мови не йде: все-таки тут мають місце витіснення, сон, очікування і т.д.

В підсумку варто перевести переваги workqueue над tasklet:
  * Мають гнучкий API (підтримується більше опцій / прапорів);
  * Призначені для більш високої затримки;
  * Можуть спати.

Результати тестування:
----------


.. code-block:: bash

	/ # insmod mnt/delayed_work.ko th_val=3 wrk_val=7 jiff_delay=4
	[   27.443143] delayed: loading out-of-tree module taints kernel.
	[   27.482092] hrtimer: interrupt took 8364480 ns
	[   27.482576] tim_p.kval 3
	[   27.482576] wrk_p.kval 7
	[   27.491380] tim_p.kval 3
	[   27.494911] wrk_p.kval 7
	[   27.495586] timer jiffies = 4294694812
	[   27.495786] insmod (98) used greatest stack depth: 13840 bytest
	/ # [   27.508197] wrk_p.kval 7
	[   27.512654] wrk_p.kval 7
	[   27.517637] work jiffies = 4294694812
	[   27.521067] work jiffies = 4294694820
	[   27.521913] work jiffies = 4294694833


Висновки:
--------
При виконанні даної лабораторної роботи було створено модуль ядра для демонстрації роботи workqueue.
синхронізація завершення потоків а також синхронізація між потоками  була зроблення за допомогою флагів. 
Таймер був зроблений на базі таймер wheel при закритті таймеру було використану sync версію функції таким 
чином таймер закриється на якому ядрі він би не працював.
