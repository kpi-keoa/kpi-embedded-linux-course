=================================================
**Лабораторна робота №0 Робота з потоками**
=================================================


**Завдання:**
--------------
Написати код в якому:

* Створити глобальну змінну та ініціалізувати її нулем;
* Створити функцію потоку,яка N разів додає до цієї змінної К;
* Запустити два потоки з цією функцією;
* Дочекатись завершення потоків використовуючи ``pthread_join()`` ;
* Вивести в ``stdout`` очікуване та фактичне значення глобальної змінної;

**Хід роботи:**
---------------

Щоб ознайомитись з основами ``GCC`` було зібрано 2 файли з прикладу лекційного занняття.
Основні прапорці, які були використані при збірці цих проєктів:

* ``-march=x86-64:``  	Прапор проінструктує компілятор генерувати специфічний код для CPU,
			з усіма доступними можливостями, особливостями, наборами команд,
			функціями і так далі, за умови, що вихідний код їх підтримує.

* ``-mtune=generic`` 	Підстроює оптимізацію коду для усіх систем, які задані попереднім параметром,
			(у нашому випадку х86-64).

* ``-O2:``		Параметр оптимізації, компілятор спробує збільшити продуктивність коду 
			без порушення розміру, і без затрачивания великої кількості часу компіляції.

* ``-Wall`` 		Виводить усі попередження про конструкції, макроси і тому подібне.

* ``-Wextra``		Додатково вмикає прапорці попередження, які не були ввімкнуті попереднім параметром

* ``-Wpedantic``	Виводить усі попередження, які суворо залежать від ISO C. Усі програми,
			які використовують заборонені розширення будуть відхилені.

* ``-lm	``		Підключення бібліотеки математики.

**Основне завдання:**
----------------------
Для роботи з потоками були використані функції із бібліотеки ``phtread.h``, а саме:
*``pthread_t``;
*``pthread_create``;
*``pthread_join``.
Перша функція - ініціалізація потоку. Друга функція створювала новий потік, в який передавались
ініціалізація потоку, функція додавання числа К та змінна\змінні, які оброблялись в потому.
Третя функція чекала закінчення потоку, яка повертала нуль(якщо все було без помилок).

Створено функцію додавання числа К по N разів до глобальної змінної, яка в свою чергу була 
ініціалізована нулем.
 
.. code-block:: C

void *add_func(void *args)
{
	struct parameters *par = (struct parameters*) args;

	for(int i = 0; i < par->n; i++) 
		global_var += par->k;
}

Функція ``main`` складається з перевірки кількості змніних, що передані у програму, циклів ``for``
для створення потоків та очікування закінчень потоків. 

.. code-block:: C

int main(int argc, char *argv[])
{
	int N = strtoul(argv[1], NULL, 10);
	int K = strtoul(argv[2], NULL, 10);

	struct parameters par = { .n = N, .k = K};

	pthread_t* pthread;

	if(argc != 3) {
		fprintf(stderr, "Please, enter the right number of argument\n");
		exit(EXIT_FAILURE);
	}	

	for(int i = 0; i < 2; i++) 
		pthread_create(&pthread, NULL, add_func, &par);
		
	for(int i = 0; i < 2; i++) 
		pthread_join(pthread, NULL);
	

	printf("Expected result: %d \n", 2 * N * K);
	printf("The real result: %d \n", global_var);

	return 0;
}

**Висновок:**
---------

При компіляції проекту з прапорцем -О0 значення до невеликої кількості N збігались. При збільшенні 
цього параметру, а це означає що кількість разів додавання числа К виросло, почались розбіжності у результаті.

При компіляції проекту з прапорцем -О2 значення були однакові, навіть при великій кількості додавань
числа К. При додаванні ключового слова ``volatile`` знову ж таки результат не збігався з очікуваним 
значенням, тому що цей ключове слово забороняло оптимізацію з будь-якою дією нашої глобальної змінної.

Це все обумовлено тим, що при перегляді асемблер лістингу було виявлено, що додавання числа К
відбувається у три етапи. При компіляції з -О0 суміжний потік може перехопити значення,прочитати
старе та додати число К. Потім управління знову перейде до першого потоку, який також додасть
своє значення, зовсім не знаючи, що суміжний потік вже змінив змінну.





