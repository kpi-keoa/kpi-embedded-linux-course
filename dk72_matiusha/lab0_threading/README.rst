=============================================
Лабораторна робота №0
=============================================

Тема
------

**Робота з потоками**

Завдання:
-------
Написати код в якому:
* Завести глобальну змінну з нульовим початковим значенням     
* Створити функцію потоку, яка N разів інкрементує змінну    
* Запустити N потоків з цією функцією     
* Дочекатися завершення потоків, використовуючи `pthread_join()`     
* Вивести у *stdout* очікуване і фактичне значення глобальної змінної     
       
Хід роботи
-------

**Опис виконаної роботи** 
В ході роботи було написано програмний код мовою *С* та Makefie. Також код було скомпільовано у декількох варіантах:
1. З оптимізацією -О0   
2. З оптимізацією -О2   
3. З оптимізацією -О2 і модифікатором змінної `volatile`   

У випадках №1 і №3 очікуване та фактичне значення відрізняються, починаючи від кількості ітерацій ~1500, тоді як у випадку №2 значення виводилося миттєво і ніяких дій насправді не проводилося. Це пов'язано з тим, що у випадку 2 компілятор оптимізує усі цикли і обчислює результат заздалегідь. У випадку 1 ми забороняємо йому це робити за допомогою флагу відключення оптимізацій, а у випадку 3 -- за допомогою кваліфікатора volatile.     
Також були спроби примусити програму працювати коректно і без оптимізацій, і це вдалося зробити за допомогою інлайн-асемблеру та префіксу інструкцій LOCK, що блокує доступ до шини пам'яті на час виконання інструкції, роблячи її атомарною. Недолік цього рішення -- не кросплатформеність.



Висновки
-------
Багатопотоковий код вносить нові і дещо неочікувані джерела помилок, і якщо з ними не боротися правильно, то код працювати не буде. Для потокової безпеки було створено багато засобів, як апаратних, так і програмних (семафори, мютекси). Їх використання у коді, який звертається до спільної пам'яті з декількох потоків, обов'язкове.


