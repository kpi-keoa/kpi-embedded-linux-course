
============
Звіт з лабораторної роботи №2
============

***************
Завдання
***************

- Модифікувати модуль з прикладу:

	* Модуль повинен виводити ім’я, передане в параметрах при встановлені. 

	* Модуль повинен містити тасклет, який виводить jiffies.

- Експериментально перевірити чи залежить різниця **jiffies** за одиницю часу від архітектури.

- Експериментально розраувати час (в мілісекундах), який потрібен на 1 jiffy. Порівняти з теоретичним значенням.

***************
Хід роботи
***************

Опис програми
~~~~~~~~~~~~~~~~
Особливістю написання модулів ядра перед звичайними програмами на мові *С* є відсутність функції ``main`` та використання бібліотек з дерикторії ``linux/``.

.. code-block:: C

	#include <linux/module.h>	
	#include <linux/moduleparam.h>
	#include <linux/kernel.h>	
	#include <linux/init.h>	
	#include <linux/jiffies.h>	
	#include <linux/interrupt.h>

``linux/module.h`` -- необіхідна для всіх модулів.
``linux/moduleparam.h`` -- необхідна для передачі параметрів модуля при його заванатженні через термінал.
``linux/kernel.h`` -- необхідна для функції запису строкової інформації.  
``linux/init.h`` -- необхідна для використання макросів ініціалізації та виходу з модуля.
``linux/jiffies.h`` -- необхідна для отримання значення ``jiffies``.
``linux/interrupt.h`` -- необхідна для такслетів.

За допомогою макросів є можливість навести основну інформацію про модуль.
.. code-block:: C

	MODULE_DESCRIPTION("First module");
	MODULE_AUTHOR("CYB3RSP1D3R");
	MODULE_VERSION("0.1");
	MODULE_LICENSE("Dual MIT/GPL"); // this affects the kernel behavior
	
Дані макроси зазначають: опис модуля, автора модуля, версію модуля та ліцензію на модуль відповідно.

Ліцензія ``"Dual MIT/GPL"`` описана як "Правильний спосіб виразити, що модуль має подвійну ліцензію за варіантом GPL v2 або вибором ліцензії MIT."
Оригінал доступен за посиланням <https://www.kernel.org/doc/html/latest/process/license-rules.html>`__
Дана ліцензія вказує, що модуль є **open source**. Якщо в модуля ліцензія пропрієтарна, то при завантаженні такого модулю кошерний кернел стає не кошерним. 

Для ініціалізації та завершення роботи модуля є функції ``init_module`` та ``cleanup_module`` відповідно.
Проте, є можливість присвоїти даним функціям рандомні імена. Для цього потрібно використовувати макрос ``module_init`` та приставку до функції ``__init`` для функції ініціалізації. 
Та макрос ``moudule_exit`` й приставку ``__exit`` для функції виходу. Дані макроси задекларовані в бібліотеці ``linux/init/h``.

.. code-block:: C
	
	static int __init init_mod(void)
	...
	static void __exit cleanup_mod(void)
	...
	module_init(init_mod);
	module_exit(cleanup_mod);

Тасклети - це механізм обробки нижної половини (**bottom half**), побудований на основі механізму відкладених переривань.
Linux розділяює обробник переривання на дві половини. Так звана верхня половина (**top half**) - це звичайні функції, які викликаються при перериванні та реєструються в **request_irq**.
Нижня половина (**bottom half**) - це функції, які поставлені в чергу після верхньої половини для пізнішого виконання, коли усі хардварні переривання оброблені. 
Тасклети бажано робити максимально швидкодіючими та без очікування.
Структура тасклету виглядає наступним образом:

.. code-block:: C

	struct tasklet_struct
	{
		struct tasklet_struct *next;  
		unsigned long state;          
		atomic_t count;              
		void (*func)(unsigned long);
		unsigned long data;     
	};
	
	
struct tasklet_struct *next -- наступний тасклет в черзі.
unsigned long state -- TASKLET_STATE_SCHED якщо тасклет чекає своєї черги на виконання або TASKLET_STATE_RUN при виконанні.
atomic_t count -- флаг, який показує активирований тасклет чи ні.
void (*func)(unsigned long) -- функція тасклету.
unsigned long data -- параметр, який передається до функції тасклету.

Для ініціалізації тасклету використовується макрос ``DECLARE_TASKLET``. Першим вказуэться ім'я тасклету, потім його функція, і в кінці аргумент, який передасться при виклику.

.. code-block:: C

	DECLARE_TASKLET(jiffies_tasklet, print_jiffies, 0);

Функція створеного тасклету:

.. code-block:: C

	static void print_jiffies(unsigned long data)
	{
		printk(KERN_INFO "jiffies using tasklet = %lu\n", jiffies);
	}
	
Функція ``printk`` записує повідомлення до файлу логів та в консоль *Kernel*. Поведінка майже аналогічна ``printf`` в ``stdio``,
тільки строка починається зі вказанням пріоітету виведення повідомлення.

 * KERN_EMERG -- System is unuseable.
 
 * KERN_ALERT -- Action must be taken immediately.
 
 * KERN_CRIT -- Critical conditions. 
 
 * KERN_ERR -- Error conditions.
  
 * KERN_WARNING  -- Warning conditions.
 
 * ERN_NOTICE -- Normal but significant condition.
  
 * KERN_INFO -- Informational.
  
 * KERN_DEBUG -- Debug-level messages. 

Глобальна змінна ``jiffies`` містить у собі кількість переривань від системного таймеру від початку завантаження системи.
Дана змінна є 64-бітною та оголошена у бібліотеці ``linux/jiffies.h``

.. code-block:: C

	extern unsigned long volatile jiffies;
	
Кількість переривань в секунду є фіксованим для кожної архітектури. Це значення замасковане макросом ``HZ``. 
Початкове значення ``jiffies`` зсунуто на 5 хвилин відносно нуля. Зробленно це задля запобігання помилок, називаємих як ``wrap bugs``.

.. code-block:: C
      
        #define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))
        
Функція ініціалізації модуля:

.. code-block:: C

	static int __init init_mod(void)
	{
		tasklet_hi_schedule(&jiffies_tasklet);

		printk(KERN_INFO "Hello, %s!\njiffies = %lu\n", name, jiffies);
	
		return 0;
	}

Функція ``tasklet_hi_schedule`` дозволяє поставити такслет в чергу на виконання з високим пріорітетом. Також існують ідентичні функції.
`` tasklet_schedule`` ставить тасклет в чергу з нормальним пріорітетом. ``tasklet_hi_schedule_first`` дозволяє "пропихнути" тасклет без черги.
Аргументом даних функцій є посилання на тасклет.

Вивод ``jiffies`` присутній як у функції ініціалізації, так і у тасклеті. 
Зроблено це для порівняння значень, тобто фактично часу між викликами функції ``printk`` в обох випадках.

Глобальна змінна ``name`` є параметром модулю. Змінити це значення можна при виклику, прописавши явно значення аргументу ``name=``.

.. code-block:: C

	static char *name = "$username"; 
	module_param(name, charp, 0);
	MODULE_PARM_DESC(name, "Variable for passing the name via command line");
	
Макрос ``module_param`` дозволяє використовувати змінну як параметр. Даний макрос задекларований у бібліотеці ``linux/moduleparam.h`` Першим аргументом є ім'я змінної. 
Другим аргументом є її тип. Третім аргументом є так звані біти дозволу.

Макрос ``MODULE_PARAM_DESC`` дозволяє записати опис параметру. Спочатку вказується змінна, а потім її опис у стрінгу.

Якщо параметр не був вказаний, то в змінній залишиться дефолтне значення, в даному випадку ``$username``.


У функція завершення зазвичай система приводиться до того виду, який був до завантаження модулю.
В даному модулі було загружено тасклет ``jiffies_tasklet``, тож у функції завершення доведеться його вбити.

.. code-block:: C

	static void __exit cleanup_mod(void)
	{
		tasklet_kill(&jiffies_tasklet);
	
		printk(KERN_INFO "Wanna break your Linux again, %s?\n", name);
		printk(KERN_WARNING "Bye-bye!\n");
	}

Функція ``tasklet_kill`` дозволяє вбити тасклет. Проте, якщо він запланований на виконання, то вихід з функції ``tasklet_kill`` відбудеться лише тоді,
коли тасклет за вказаним посиланням буде виконаний.

Дослід
~~~~~~~~~~~~~~~~

Для виконання експерименту необхідно двічі зафіксувати значення змінної ``jiffies`` з інтервалом 10 секунд.
Від значення з другого вимірювання відняти перше і буде отримано приблизне значення натікавщих **jiffies** за 10 секунд. Потім знайти час, необхідний для одного **jiffy**.

Для теоретичного розрахунку необхідно значення ``HZ`` помножити на 10 секунд. Значення ``HZ`` можливо дізнатись за допомогою команди:

.. code-block::

	`grep 'CONFIG_HZ=' /boot/config-$(uname -r)`


 * х86: **HZ = 300**
 * BBB: **HZ = 100**

Тобто час на 1 **jiffiy** становить:

 * х86 **1000мс / 300 = 3.33мс**
 * ВВВ **1000мс / 100 = 10мс**

Очікувані значення різниць **jiffies** за 10 секунд

 * х86: **300 * 10 = 3000**
 * ВВВ: **100 * 10 = 1000** 


**РЕЗУЛЬТАТИ**

.. table:: 

    +-----------------+--------+-------+
    |                 |  х86   |  ВВВ  | 
    +=================+========+=======+
    | **Час, с**      |  10    |  10   |
    +-----------------+--------+-------+
    | **jiffies**     | 3009   | 964   |
    +-----------------+--------+-------+
    |**час/jiffy, мс**| 3.32   | 10.37 |
    +-----------------+--------+-------+

Отримані результати майже збігаютсья з теоретично отриманими. Похибка при вимірюваннях обумовлена людськими факторами (не абсолютна точність та затримка реакцієї). 
Для різних архітектур практичні значення різниці **jiffies** за однаковий інтервал виявилися різними. Отже це значення залежить від архітектури. 

Зауваження: значення змінної ``jiffies`` не відрізнялося в обох випадках виводу, оскільки затримка між двома виводами є відносно не суттєвою. 
На платі BBB спочатку виводилися ``jiffies`` з тасклету, а вже потім з функції ініціалізації. Отже перехід на тасклет відбувається відразу після занесення в чергу. 

***************
Висновок
***************

Під час виконання даної лабораторної роботи було досліджено особливості створення модулів для системи Linux та інструментів, які доступні в проццесі розробки. Також було досліджено глобальної змінної ``jiffies``, її особливості та за що вона відповідає.

Результати практичного експерименту показали, що значення **jiffies** за одиницю часу для різних архітекур відрізняється. Теоретичні розрахунки часу, необхідного на 1 jiffy співпали з практичними значеннями.

Отже дана лабораторна робота була вдало виконана з дотриманням усіх вимог.

Слава Лінуксу! Пінгвіну слава!
