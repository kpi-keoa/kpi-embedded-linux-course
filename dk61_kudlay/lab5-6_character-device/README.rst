=============================================
Лабораторная работа №5-6: Символьное устройство   
=============================================

Цели и задание
-----
Изученение механизма работы символьных устройств.   

- модифицировать исходный пример:
  - добавить инициализацию памяти устроства нулевыми символами
  - добавить механизмы чтения и записи устройства  
  - добавить возможность добавление устройства в ``/dev``  
  - добавить операции с ``ioctl``, которые добавляют в буфер "магическую" строку и позволяют задавать размер буфера 



Теоретическая база работы 
-----

Символьное устройство - это такое устройств, к которому можно обращаться как к потоку байтов (так же как к файлу).
драйвер символьного устройства отвечает за реализацию такого поведения. Такой драйвер обычно, как минимум, 
поддерживает системные вызовы ``open``, ``close``, ``read`` и ``write``. 

Символьные устройства, которые часто обозначают как ``cdevs``, в отличии от блочных устройств, 
обычно не позволяют адресовать отдельные блоки данных. 
Они предоставляют доступ к данным только в виде непрерывного потока символов (байтов). В качестве примеров символьных 
устройств можно привести клавиатуру или мышь. Для доступа к символьным 
устройствам используется специальный файл, называемый узлом символьного устройства (``character device node``). 
В отличие от блочного устройства приложение взаимодействует с символьным устройством напрямую через узел этого устройства.
Несмотря на используемый в системах Unix подход к проектированию, 
заключающийся в том, что “все в системе является файлом”, сетевые устройства ему не подчиняются. Обращение к ним выполняется
не через соответствующий узел файловой системы, а через специальный интерфейс, называемый API-сокетом (socket API). 
В системе Linux используются также и другие типы устройств, но они не являются универсальными и относятся только к одной 
специализированной задаче. Исключением здесь являются смешанные устройства (miscellaneous devices), которые часто обозначают 
как miscdevs. По сути, они являются упрощенной формой символьных устройств. Смешанные устройства позволяют авторам драйверов
с легкостью работать с простыми устройствами и сосредоточить всю функциональность на общей инфраструктуре. 
Однако не все драйверы устройств в системе Linux работают с физическими устройствами. Часть драйверов устройств являются 
виртуальными и обеспечивают доступ к функциональным возможностям ядра. 

Для хранения номеров устройств, обоих, старшего и младшего, в ядре используется тип ``dev_t``. 
Начиная с версии ядра 2.6.0, dev_t является 32-х разрядным, 12 бит отведены для старшего номера и 20 - для младшего.
Для получения старшей или младшей части ``dev_t`` можно использовать:

   .. code-block:: C
   
    MAJOR(dev_t dev); 
    MINOR(dev_t dev);
    
Или же при наличии старшего и младшего номера устройств для преобразования в ``dev_t``:
  
  .. code-block:: C
  
    MKDEV(int major, int minor);

Одним из первых шагов, который необходимо сделать драйверу символьного устройства, 
является получение одного или нескольких номеров устройств для работы с ними. Необходимой функцией для выполнения 
этой задачи является ``register_chrdev_region``, которая объявлена в ``<linux/fs.h>``: 

    .. code-block:: C
    
        int register_chrdev_region(dev_t first, unsigned int count, char *name);

Однако, иногда нету возможности знать, какие старшие номера устройств будут использоваться. 
Ядро может выделить старший номер самостоятельно, для этого используется другая функция: 

    .. code-block:: C
    
        int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);

Структура ``file_operations`` определяет операции для работы с драйвером.
Структура определена в ``<linux/fs.h>``, которая состоит из перечня указателей на функции. 
Операции в основном отвечают за осуществление системных вызовов и, таким образом, названы ``open``, 
``read`` и т.д. 
По сути пишется обработчик внутри драйвера, который ассоциируется с определенным системным вызовом. Указатели на 
эти функции обработчик и вмещает в себя структура ``file_operations``.

В данной работе будет затронута тема структур данных в ядре. Связный список уже рассматривался, поговорим про деревья:
Наряду с базисными деревьями (``radix trees``) ядро содержит реализацию структуры данных, известной под названием 
"красно-чёрное дерево" (``red-black tree``). Красно-чёрные деревья (в ядре более известные, как ``rb_trees``) являются 
разновидностью полусбалансированных деревьев. Каждый узел дерева содержит некое значение и не более двух дочерних узлов; 
значение узла больше, чем значения любого из содержащихся в его левом поддереве или меньше любого из значений его правого 
поддерева. Поиск значения возможен с самого первого глубокого узла обходом слева направо.

Каждый узел красно-чёрного дерева может быть красного или чёрного цвета, корень дерева всегда чёрный. 
Набор правил, исходя из которых окрашиваются узлы и когда должна происходить перебалансировка несколько сложен.
В ядре множество мест, где используются красно-чёрные деревья. Планировщики ввода-вывода ``anticipatory`` (упреждающий), 
``deadline`` (алгоритм крайнего срока) и ``CFQ`` (completely fair queuing - абсолютно честная очередь) используют красно-чёрные 
деревья для отслеживания запросов; драйвер пакетной записи CD/DVD использует красно-чёрные деревья для этих же целей. 
Код таймеров высокого разрешения использует красно-чёрное дерево для упорядочивания невыполненных запросов на таймеры. 
Файловая система ``ext3`` отслеживает в красно-чёрных деревьях содержимое (записи) директорий. 
Также с помощью красно-чёрных деревьев отслеживаются диапазоны виртуальных адресов (VMAs), дескрипторы файлов, 
на которых применяется опрос вызовом epoll(), криптографические ключи и сетевые пакеты в планировщике 
``hierarchical token bucket``.

Выполнение  
-----
В директории ``src`` данной лабораторной работы находится исходный файл драйвера символьного устройства ядра ``hivemod.c`` 
с результатом выполнения заданий в рамках данной работы. Также имеется тест операций чтения и записи.
Проведём небольшой анализ исходного кода:

#. Ниже наведена реализация функции обработчика системного вызова ``write``. Обеспечена защита от записи за пределом выделеного
   места. Копирование данных из пространства пользователя обеспечивается методом ядра ``copy_from_user``, который возвращает нулевое 
   значение в случае успешного выполнения. Таким образом переменная ``retval`` при успешном выполнении должна равняться длине данных ``count``.
   
   
   .. code-block:: C

        static ssize_t cdev_write(struct file *file, const char __user *buf,
			    size_t count, loff_t *loff)
        {
          struct hive_flist_item *item = hive_flist_get(file);
          if (NULL == item)
            return -EBADF;

          //Completed: Add buffer write logic.
          ssize_t retval = -ENOMEM;

          if((count + *loff) > item->length) {
            MOD_DEBUG(KERN_DEBUG, "Attempt to write beyond the dev size!");
            goto EXIT;
          }

          /* copy to user and update the offset in the device */
          retval = count - copy_from_user((item->buffer + *loff), buf, count);
          *loff += retval;

          MOD_DEBUG(KERN_DEBUG, " bytes written: %d, position: %d",\
               (int)retval, (int)*loff);

        EXIT:
          return retval;
        }


#. Аналогичным принципом реализована функция обработчик чтения по системному вызову. Обеспечена защита от чтения за пределом 
   буфера, в таком случае происходит чтение только в доступной части буфера. Для чтения данных в пространство пользователя использован 
   метод ядра ``copy_to_user``, обратный по принципу к ``copy_from_user``.
      
      .. code-block:: C
     
        static ssize_t cdev_read(struct file *file, char __user *buf, 
			 size_t count, loff_t *loff)
        {
          struct hive_flist_item *item = hive_flist_get(file);
          if (NULL == item)
            return -EBADF;
          // Completed: Add buffer read logic.

          ssize_t retval = 0;

          if(*loff > item->length)		
            goto EXIT;
          if((count + *loff) > item->length) {
            MOD_DEBUG(KERN_DEBUG, "Attempt to READ beyond the dev size!");
            
            count = item->length - *loff;
          }

          /* copy to user and update the offset in the device */
          retval = count - copy_to_user(buf, (item->buffer + *loff), count);
          *loff += retval;

          MOD_DEBUG(KERN_DEBUG, " bytes read: %d, position: %d",\
              (int)retval, (int)*loff);
        EXIT:
          return retval;	

          return 0;
        }


#. Для обеспечения базовой функциональности чтения-записи устройства, добавлена функция обработчик системного вызова 
   ``lseek``. Реализация самая базовая, которая обеспечивает установку смещения в файле. В дальнейшем функция будет дополнена.
   
    .. code-block:: C
   
      static loff_t cdev_lseek(struct file *file, loff_t f_offset, int action)
      {
        loff_t new_offset;
        struct hive_flist_item *item = hive_flist_get(file);
        if (NULL == item)
          return -EBADF;

        switch (action)
        {
          case SEEK_SET:
            new_offset = f_offset;
            break;

          default:
            new_offset = -EINVAL;
            goto EXIT;
        }

        file->f_pos = new_offset;

        MOD_DEBUG(KERN_DEBUG, "Seeking to position: %ld", (long)new_offset);
      EXIT:
        return new_offset;
      }

#. Для отображения устройства в директории /dev используется следующий код, который наведен ниже. 
   Для начала нужно создать класс устройства. Класс является высокоуровневым представлением устройство.
   В дальнейшем нужно создать устройство и зарегестрировать его в ``sysfs`` с помощью ``device_create``.
   
    .. code-block:: C
        if ((hive_class = class_create(THIS_MODULE, "hive_class")) == NULL) {
            unregister_chrdev_region(hive_dev, 1);
            return -1;
        }
        if (device_create(hive_class, NULL, hive_dev, NULL, "hive_dev") == NULL) {
          class_destroy(hive_class);
          unregister_chrdev_region(hive_dev, 1);
          return -1;
        }    

#. Ниже представлен обработчик системного вызова ``ioctl``. Так как таких вызовов может быть достаточно много, то нужно
   правильно определить какое именно действие запросил пользователь. Это делается с помощью параметра ``ioctl_num``, который
   имеет особый формат. Для упрощения они используются через макросы, которые задекларированы в начале кода. 
   ``CHG_BUF`` - отвечает за операцию изменения размера буфера, ``ADD_PHR`` - отвечает за добавление "магической строки" в конец 
   буфера.

    .. code-block:: C 
    
        #define CHG_BUF _IOW('V','a', unsigned long*)
        #define ADD_PHR _IOW('B','b', unsigned long*)
        
        ...
    
        long cdev_ioctl(struct file *file, unsigned int ioctl_num, 
                        unsigned long ioctl_param)
        {
          struct hive_item *item = hive_tree_get(&mytree, file);
          if (NULL == item)
            return -EBADF;
          switch(ioctl_num) {
                         case CHG_BUF:
                            if(ioctl_param > item->length) {
                              char *buf = kzalloc(sizeof(*buf) * ioctl_param, 
                                    GFP_KERNEL);
                              memcpy(buf, item->buffer, 
                                sizeof(*buf)*item->length);
                              kfree(item->buffer);
                              item->buffer = buf;
                              item->length = ioctl_param;

                            } else {
                              MOD_DEBUG(KERN_DEBUG, "Change buf not required");
                              return -1;
                            }                       
                            break;
                        case ADD_PHR:
                            if ((strlen(item->buffer) + buffsize/2) > item->length) {
                              char *buf = kzalloc(sizeof(*buf) 
                                  * (item->length + buffsize/2), 
                                  GFP_KERNEL);				
                              strcat(buf, item->buffer);
                              kfree(item->buffer);
                              strcat(buf, magic_phrase);
                              item->buffer = buf;
                              item->length = item->length + buffsize/2;

                            } else {

                              strcat(item->buffer, magic_phrase);
                            }

                                              break;
                        default:
                          return -1;
             }
             return 0;
        }

#. Вместо связного списка был реализован механизм хранения структур устройства в красно-чёрном дереве. Главной особеностью 
   является то, что элементы в нём важно необходимо правильно размещать в зависимости от того, по какому принципу выполняется 
   сортировка в дереве. В нашем случае это структура ``file``. Ниже представлена функция вставки в дерево. В зависимости от резульатата
   сравнения указателей на файл, выполняется движение по дереву и вставка. Остальные функции для работы с деревом работают по схожей 
   идее и используют API для работы с деревом в ядре.
   
   .. code-block:: C 
   
      int tree_insert(struct rb_root *root, struct hive_item *data)
      {
        struct rb_node **new = &(root->rb_node), *parent = NULL;

        /* Figure out where to put new node */
        while (*new) {
          struct hive_item *this = container_of(*new, struct hive_item, node);
          int result = memcmp(data->file, this->file, sizeof(struct file));

          parent = *new;
          if (result < 0) {
            new = &((*new)->rb_left);
          } else if (result > 0) {

            new = &((*new)->rb_right);

          } else {
            return 1;
          }
        }

        /* Add new node and rebalance tree. */
        rb_link_node(&data->node, parent, new);
        rb_insert_color(&data->node, root);

        return 0;
      }
    
Сборка модуля и тестирование 
-----          
Процесс сборки и запуска проекта следующий:

#. Для автоматизированной сборки используется Kbuild. С помощью команды ``make`` производиться сборка и компиляция 
   модуля и тестового кода. Для кросс-компиляции можно также указать архитектуру, компилятор и директорию исходников.  
   Например, компиляции для ARMv7 для SoC ``Zynq-7000``: ``make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabihf- KBUILDDIR=<path_to_linux_src>/linux-xlnx-xilinx-v2017.4/``.
#. Автоматически при использовании ``make`` проводиться как и загрузка модуля, так его тестирование, выводиться лог ядра.
#. Для удаления резульатов сборки можно использовать ``make clean`` и ``make tidy``.

Анализ полученных результатов 
-----   
Было проведено тестирование операция чтения и записи из(в) пространство пользователя. Ниже приведен результат работы тестовой 
программы в пространстве пользователя и лог ядра с результатами работы символьного устройства.

.. code-block:: C

    Opened fd of hive_dev = 3
    Opened fd of hive_dev = 4
    Return from write callback, offset=32, message=Wow, we made these bees TWERK !
    Return from read callback, offset=32, message=Wow, we made these bees TWERK !
    Return from write callback, offset=-1
    device 4 : buffer size change to 100
    Return from write callback, offset=69
    Return from read callback, offset=69, message=Wow, we made these bees TWERK !Wow, these bees really hottest things
    Return from read callback, offset=100, message=Wow, we made these bees TWERK !Wow, these bees really hottest thingsWow, we made these bees TWERK !

    [  346.680970] /dev/hive_dev: device: Seeking to position: 0
    [  346.680975] hivemod: hive: device: bytes read: 69, position: 69

    [  346.680994] /dev/hive_dev: device: Seeking to position: 0
    [  346.680999] hivemod: hive: device: bytes read: 100, position: 100

    [  346.681021] hivemod: File entry 00000000feaae122 unlinked
    [  346.681028] hivemod: File entry 00000000999c373a unlinked
    [  346.684722] hivemod: All honey reclaimed
    

Как можно увидеть, в начале видна отработка тестовой программы, которая пытается сначала записать строку из первого массива с помощью системного вызова ``write`` в первое устройство.
Затем с помощью ``lseek``, выставляется указатель положения в файле на начало и происходит считывание с помощью вызова ``read``. Код успешно вывел записаное 
ранее сообщение. Для второго устройства специально выполняется попытка записать строку с размером, которая больше размера буфера. Эта операция заканчивается
с ошибкой ``-1``. Дальше это устройство запрашивает изменить размер буфера с помощью вызова ``ioctl``. Значение буфера увеличивается до 100.
Происходит попытка вновь записать строку из второго массива в это устройство. На этот раз попытка удачна. В конце в это же устройство добавляется
магическа строка из модуля, которая просто добавляется в исходный буфер, если для неё есть место. Если этого места нет - выполняется выделение места для неё и вставка.
В логах ядра видны отладочные записи в лог про отработку обработчиков каждого системного вызова из пространства пользователя.
