==========================
Звіт з лабораторної роботи №1
==========================
"Двупоточний лічильник"
________________________________________________

Завдання
~~~~~~~~~~
1. Налаштування плати:

	* Завантажити Debian Stretch на плату BeagleBoard через SD-карту.
	* Виставити IP-адресу  192.168.7.1/24.
	* Підключитися до плати по SSH.

2. Написати програму, яка інкрементує змінну в 2 стільки разів в одному потоку, скільки вказано в аргументах виклику програми. 
   Для реалізації многопоточності необхідно використовувати бібліотеку ``pthread``.
   Програму зібрати з флагами ``-O0`` та ``-O2``.
   Перевірити оба варіанта на платі та на комп’ютері (архітектура *X86*).

Опис програми
~~~~~~~~~~~~~~~~
*POSIX threads* є класичним засобом для реалізації багатопоточності на UNIX подібних системах, тому застосування даної бібліотеки є доцільним у даному проекті. У бібліотеці ``pthreads`` визначено типи даних, функції для багатопоточності та їх синхронізації. 

Змінна для ікрементації є зовнішньою, що дозволяє обом потокам інерементувати одну і ту ж змінну

.. code-block:: C

	int global_inc = 0;


Функція ``main`` приймає на вхід аргументи виклику програми та їхня кількість. 
Першим аргументом виступає назва програми, у другому вказується число, до якого введеться інкрементація.

Спочатку виконується перевірка на кількість аргуменів та правильність вказання.
Якщо в чисельному аргументі є символи, відмінні від числельних, то ``strtol`` припине зчитування строки та в змінній ``endp`` буде зберігатися вказівник на ``\0``.
Якщо строка не зчиталася до кінця, то відбувається вихід з програми. 

.. code-block:: C

	if (argc != 2) {
		printf("Error: wrong number of arguements!\n");
		exit(EXIT_FAILURE);
	}
	
	char *endp;
	int limitcount = strtol(argv[1], &endp, 10);
	
	if (*endp != '\0') {
		printf("Error: wrong arguement format!\n");
		exit(EXIT_FAILURE);
	}

	
Для створення потоків необхідно створити змінні потоків:

.. code-block:: C

	pthread_t thread0, thread1;


Далі необхідно створити потоки

.. code-block:: C

	pthread_create(&thread0, NULL, &global_increment, &limitcount);
	pthread_create(&thread1, NULL, &global_increment, &limitcount);


У функції ``global_increment`` виконується цикл, що інкрементує значення глобальної змінної. Опис функції наведенно нижче.

.. code-block:: C

	void *global_increment(void *limit) 
	{
		int limitcount = *((int*) limit);
		
		for (int i = 0; i < limitcount; i++) {
			global_inc++;
		}
	
		pthread_exit(0);
	}


Аргумент ``limit`` має тип ``void *``. Цей тип є унверсальним посиланням, але потрбіно вказати тип посилання при зчитуванні даних за посиланням.

.. code-block:: C

        int limitcount = *((int*)limit);


Оскільки в змінну ``global_inc`` вже було записано ``0`` при декларації, необхідність записати повторно в тілі функції відпадає.
Далі йде інкрементація змінної до вказаного ліміту.

.. code-block:: C

	for (int i = 0; i < limitcount; i++) {
		global_inc++;
	}


Функція ``pthread_exit`` завершує роботу потока.

.. code-block:: C

        	pthread_exit(0);


Для очікування завершення роботи потоків у функціх ``main`` використовується функція ``pthread_join``.

.. code-block:: C

	pthread_join(thread0, NULL);
	pthread_join(thread1, NULL);


Оскільки ``retval`` присвоюється ``NULL``, то функція не повертає статус завершення потоку, вказаного в ``pthread_exit``.

Для відсідження часу виконання використовується бібліотека ``time``.

Для зберігання часу початку та кінця виконання використовуються змінні ``time_begin``, ``time_end``.
Фунуція ``clock`` повертає кількість тіків від початку виконання програми.

.. code-block:: C

	        clock_t time_begin = clock();
		...
		clock_t time_end = clock();


Час виконання в мікросекундах визначаєтсья за формулою ``(time_end-time_begin)/(CLOCKS_PER_SEC/1000000)``.
``CLOCKS_PER_SEC`` це константа, яка рівна кількості тіків за секунду.


Для виводу даного значення використовується функція ``printf``.

.. code-block:: C

	       printf("Counted value using 2 threads: %i\nTime spent: %li us\n",
		 global_inc, (time_end - time_begin)/(CLOCKS_PER_SEC/1000000));


Повний код знаходиться в директорії **src**.

Зборка
~~~~~~~~~~~

Для зборки використовувася *MakeFile*.
**Makefile** - це файл з інструкціями для програми make, яка допомагає зібрати програмний проект.

Використовуються різні флаги оптимізації *O0* та *O2*.
*O0* виключає всі можливі оптимізації для швидкого компілювання.
*O2* включає майже всі оптимізації, але час компіляції більше.

При компіляції написаної програми з флагом ``-O0`` зберігається цикл з інкрементацією змінної ``inc`` до значення змінної ``limit``.
При компіляції написаної програми з флагом ``-O2`` в змінну ``inc`` записується значення змінної ``limit``.



.. code-block::

	CFLAGS = -c -std=c11 -Wall -Werror -O0 -fverbose-asm -save-temps
	INCLUDE_OBJ = -pthread
	INCLUDE_SRC = -lpthread

де

  * ``-O0`` - флаг оптиміції. Цей флаг означає відключення оптимізації, і основна ціль являю собою високу шкидкість компіляції;
  * ``-O2`` - флаг оптимізації (використовується також в цьому файлі але пізніше), включає майже всі доступні оптимізації;
  * ``-fverbose-asm`` - додає додаткові коментарії до створеного файлу, щоб зробити його більш читабельним.
  * ``-save-temps`` - флаг для перегляду асемблерських листів;
  * ``-lpthread`` ``-pthread`` - підключає бібліотеку Pthread до програми.


Програма запускаєтсья на архітектурі *х86* та на платі з різними флагами оптимізаціями. 

**Результати:**

.. list-table:: **х86**

   * - Число
     - 100
     - 10000
     - 1000000
   * - Значення з ``O0``
     - 200 
     - 19654
     - 1104815
   * - Значення з ``O2``
     - 200
     - 20000
     - 2000000

Таблиця 1.

**Висновок з результатів**

Як видно з результатів вимірювання, при оптимізації ``O0`` два потоки асинхронно інкрементують змінну в два потоки  певну кількість разів кожен. При оптимізації ``O2`` компілятор підставляє теоретично розраховане значення в змінну ``global_inc``. 
Через асинхроне лічення глобальної змінної в два потоки отриманий результат відрізняється від теоретичного. 

**Висновок**

Під час виконання даної лабораторної роботи було проведено ознайомлення з плвтою BiggleBoard, яка працює під Debian Stretch. На плату було завантажено даний дистрибутив, а також налаштовано IP-адресу та під'днано до комп'ютера по SSH. 
Потім необхідно було написати программу під linux для лічення змінної в два потоки вказане при виклику кількість разів. Дану програму необхідно було зібрати з різними флагами опптимізації для порівняння. Результати наведені в Таблиці 1.
Отже завдання на дану лабораторну роботу було виконано.
