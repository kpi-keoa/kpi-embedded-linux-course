==============================
М'яновський Віталій Валерійович
==============================


#. Який формат опису повідомлень комітів використовується в курсі? Навіщо потрібно дотримуватися певного формату?
   Наведіть приклад команди, що додає до репозиторію коміт з важливими виправленнями кодової бази
	
	Для опису повідомлень комітів використовується формат Conventional Commits 1.0.0.. 
	Дотримання одного формату спрощує роботу в команді - легше орієнтуватися у внесених змінах до проекту.
	Приклад
	git commit -m "add(new file): added new file"

#. Як підтягнути зміни, що відбулись у віддаленому upstream-репозиторії (гілка master) до локального репозиторію? Наведіть команду.
	
	git pull upstream master

#. Прокоментуйте (за допомогою коментарів Make) Makefile що використовується для збірки модулів ядра в курсі.
   Що відбувається в кожній строчці?
	
	
	# Тут до змінної obj-m додається назва об'єктного файлу модуля, який буде підключено до ядра
	obj-m += firstmod.o

	# Прапор verbosity вказує на те, чи потрібно виводити інформацію про процес збірки ядра
	V ?= 2

	# Тут вказується директорія, де знаходяться вихідні файли ядра
	KBUILDDIR ?= ../linux-5.14.9/

	# Не виводити "Entering directory"
	MAKEFLAGS += $(if $(value V),,--no-print-directory)

	# ціль збірки, в якій перелічено залежності, які будуть виконані
	.PHONY: modules clean tidy

	# рекурсивно викликає головний makefile, що знаходиться у директорії KBUILDDIR, і додає до нього частину makefile модуля, що знаходиться у директорії PWD
	modules:
		$(MAKE) -C "$(KBUILDDIR)" M="$(PWD)" V=$(V) modules

	# видаляє всі службові файли способом системи збірки ядра
	tidy:
		$(MAKE) -C "$(KBUILDDIR)" M="$(PWD)" V=$(V) clean

	# очищення всіх перелічених службових файлів
	clean:
	-rm -rf .tmp_versions
	-rm -f modules.order .modules.order.cmd Module.symvers .Module.symvers.cmd
	-rm -f $(obj-m) $(obj-m:.o=.mod) $(obj-m:.o=.mod.o) $(obj-m:.o=.mod.c) .$(obj-m:.o=.mod.cmd)
	-rm -f $(addsuffix .cmd,$(addprefix .,$(obj-m)))
	-rm -f $(addsuffix .cmd,$(addprefix .,$(obj-m:.o=.ko)))
	-rm -f $(addsuffix .cmd,$(addprefix .,$(obj-m:.o=.mod.o)))

#. Завантаження, вивантаження, виведення списку завантажених модулів ядра та інформації про певний модуль ядра.
   Наведіть команди.
	

	# Для завантаження модуля викоростовується команда
	
	insmod /mnt/some_module.ko

	# Для вивантаження модуля використовується команда
	
	rmmod some_module

	# Список завантажених модулів виводиться по команді

	lsmod

	# Інформація про певний модуль виводиться по команді

	modinfo ./some_module.ko

#. Що таке jiffies? Якою є розрядність jiffies на x86 та x86_64, як це реалізовано?
	

	jiffies - личільник системних переривань, які перемикають задачі між собою, таким чином створюючи паралельне виконання програм при одному наявному потоці.
	Реалізований як unsigned long змінна, однак в залежності від системи має 32-ну розрядність на х86 та 64-ну на х86_64.
	jiffies завжди реалізований як 64-на змінна, однак, на х86 системах зчитуються лише молодші 32 біта.

#. В якому порядку виконуються алокації та деалокації в модулях ядра. Наведіть приклад коду з обробкою виключень, якщо
   невдалось виділити певний ресурс. (з використанням goto)
	
	Деалокації у модулі відбуваються у зворотньому напрямі до алокацій.

#. Як працює та для чого використовується макрос container_of. Наведіть приклад доступу до поля data контейнеру типу struct outer, 
   всередині структури якого визначено поле innerobj типу struct inner.
	
	Даний макрос використовується для отрsмання структури, яка має вказівник на певне поле структури.

#. Що таке Soft IRQ та які обмеження він накладає на відповідний код? Опишіть коротко.
   Які з вивчених механізмів відкладеної роботи виконуються в Soft IRQ?
