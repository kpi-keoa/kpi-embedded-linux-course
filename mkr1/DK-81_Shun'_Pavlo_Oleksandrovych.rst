==============================
Шунь Павло Олександрович
==============================


#. Для чого слугує файл .gitignore? Наведіть його синтаксис для виключення всіх файлів з розширенням .o в усіх директоріях та
   директорії build в корені репозиторію
   
      В файле .gitignore мы прописываем файлы или их шаблоны, которые мы не хотим добавлять в удаленный репозиторий
      
      Пример:
          .. code-block:: 
          
          *.o
      
#. Яким чином можна додати зміни до вже створеного (останнього) коміту? Наведіть приклад.
   Чи варто так робити в основних публічних гілках віддаленого репозиторію? Якщо так, коли? Якщо ні, чому?

#. Який інструмент використовується в курсі для автоматичного форматування вихідних файлів C відповідно до Coding Style?
   Де взяти основний шаблон з описом формату для коду ядра? Наведіть команду для форматування файлу module.c відповідно
   до Coding Style ядра.
   
      Как говорится, Линтер проверяет а Форматер располагает. Clang-format -- форматер, преобразовывает к какому хотим кодинг стайлу.
      В директории линуксового ядра можно взять шаблон кодинг стайла и его использовать. Нужно скачать его в папку, где лежит clang-format и использовать в команде,
      в моем случае он будет назван OurStyle
      
      Пример использования:
      
         -- clang-format -i --style=OurStyle ./module.c
   
#. Прокоментуйте (за допомогою коментарів Make) Makefile що використовується для збірки модулів ядра в курсі.
   Що відбувається в кожній строчці?

#. Які обмеження існують для модулів ядра в порівнянні з userspace-додатками?
      Если ты разрабатываешь свои модули, то ты должен работать под лицензией GPL или MIT и в итоге поделиться своими наработками с миром.
      Также у нас модули должны быть быстрыми, чтобы система не подвисала, работают они на тасклетах и не содержат main функции.
      Используем при разработке ядра не стандартные функции, а функции из кода ядра (используем не стандартные библиотеки).
      Не работается с числами с плавающей точкой, в отличии от юзерспейса и там надо извиваться аки ужик чтобы не просадить ядро.
      Ну и ресурсы ядра не освобождаются автоматически, всё прописываем вручную.

#. В якому порядку виконуються алокації та деалокації в модулях ядра. Наведіть приклад коду з обробкою виключень, якщо
   невдалось виділити певний ресурс. (з використанням goto)

#. Таймери на timer wheel. На базі чого реалізовані? Як працюють? Наведіть фрагмент коду для запуску таймера.
#. Таймери на hrtimer. Чим відрізняються від таймерів на timer wheel? Для чого використовуються?
   Наведіть фрагмент коду для запуску таймера.
   
     hrtimer более точный, чем стандартный (тот, что основан на timer wheel). В стандартном таймере счёт идёт исходя из джифисов (jiffies) и даёт точность порядка микросекунд,
     а hrtimer работает с точностью в наносекунды и основан на механизмах, которые я ещё не в силах осознать. Так что просто считаем что шртаймер более точный и используется в
     программах, в которых требуется эта точность.
     
     
      .. code-block:: 
      
      struct hrtimer timer;
      hrtimer_init(&&timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);

      hrtimer_start(&timer, delay, HRTIMER_MODE_REL);

      static enum hrtimer_restart timer_handler(struct hrtimer *handle)
      {
          // ... do what we need
          // ...
  
      return HRTIMER_NORESTART; 
      }

      // at close
      hrtimer_cancel(&timer);
