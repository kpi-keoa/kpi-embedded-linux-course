==============================
Дмитрук Олександр Олександрович
==============================


#. Наведіть команди git для додавання файлів та директорій ./dev ./dev/file.c ./.gitignore до локального репозиторію одним комітом
   (уважно).
   
   - git commit -a -m 'message'  
   
#. Як підтягнути зміни, що відбулись у віддаленому upstream-репозиторії (гілка master) до локального репозиторію? Наведіть команду.
   
   - git pull origin master  

#. Прокоментуйте (за допомогою коментарів Make) Makefile що використовується для збірки модулів ядра в курсі.
   Що відбувається в кожній строчці?
   
   - # (!) using paths with spaces may not work with Kbuild
	 
	 # додаємо до масиву обєкт.файл
	 
	 obj-m += firstmod.o 

	 V ?= 2 # овервосіті

	 # path до репоз. з makefile
	 
	 KBUILDDIR ?= ~/kernel/linux-5.14.8 

	 # флаги мейка
	 
	 MAKEFLAGS += $(if $(value V),,--no-print-directory) 

	 # ціль мейка в якій перечисленні залежності, які не породять файли
	 
	 .PHONY: modules clean tidy 

	 # зборка модуля
	 
	 modules: 
		$(MAKE) -C "$(KBUILDDIR)" M="$(PWD)" V=$(V) modules

	 # чистить все, також зібраний .ko файл
	 
	 tidy:
		$(MAKE) -C "$(KBUILDDIR)" M="$(PWD)" V=$(V) clean

	 # чистить все не потрібне 
	 
	 clean:
		-rm -rf .tmp_versions
		-rm -f modules.order .modules.order.cmd Module.symvers .Module.symvers.cmd
		-rm -f $(obj-m) $(obj-m:.o=.mod) $(obj-m:.o=.mod.o) $(obj-m:.o=.mod.c) .$(obj-m:.o=.mod.cmd)
		-rm -f $(addsuffix .cmd,$(addprefix .,$(obj-m)))
		-rm -f $(addsuffix .cmd,$(addprefix .,$(obj-m:.o=.ko)))
		-rm -f $(addsuffix .cmd,$(addprefix .,$(obj-m:.o=.mod.o)))

#. Завантаження, вивантаження, виведення списку завантажених модулів ядра та інформації про певний модуль ядра.
   Наведіть команди.
   
   - lsmod - подивитись завантажені модулі 
	 modinfo - інформація про модуль
	 insmod - загрузить модуль
	 rmmod - удалить модуль

#. Що таке jiffies? Якою є розрядність jiffies на x86 та x86_64, як це реалізовано?
   
   - Це механізм відліку часу. Таймер зазвичай налаштований на 250 гц 
     (4 мс). При проходженні 4 мс. відбувається переривання, і дається
     процесорний час для schedule-ра, який передає іншим таскам проц. час.
     Розрядність jiffies в 32-х бітній системі рівна 32-м
     В 64-х бітній системі - 64 біти.
     За 32-х бітну систему можу помилятись. Можливо jiffies 64-бітний,
     але вироситовується молодші 32.

#. Якщо роздрукувати поточне значення jiffies до запуску тасклета та всередині тасклета, то
   чому ці два виводимих значення можуть відрізнятися на 0, 1 чи 2? Поясніть для кожного випадку.
   
   - Якщо ядро не завантажене, тобто може виконати таску прямо зараз, тоді
   	 виведене значення jiffies не буде відрізнятись.
   	 Якщо ядро завантажене, то по наступному такті jiffies виконається таска, тобто вивед. знач. буде відрізн. на 1
   	 Якщо ядро завантажене + можливе доп. навантаження (переключення контекста) перед запуском тасклера, тоді jiffies можливо буде рівне 2

#. Наведіть приклад виділення та вивільнення пам'яті за допомогою kmalloc та vmalloc. Коли доцільно використовувати kzalloc?
 
   - void *kmalloc(size_t size, gfp_t flags); // - прототип ф-ї
     
     Викор. для виділення пам'яті в області відображення фіз. пам'яті
     яка фіз. неперервна.
     Ф-ції передається :
     розмір виділ. пам'яті (size)
     Флаги (методи виділ. пам'яті):
     GFP_ATOMIC - процец атомарний (виділення не буде перерване)
	GFP_KERNEL 	- нормальне виділення
	GFP_DMA 	- через DMA
     
  	 void *vmalloc(unsigned long size); // прототип vmalloc
  	 
  	 vmalloc дасть неперервну область пам'яті в пространстві віртуальної
  	 пам'яті, но вона не обов'язково являється неперерв. в фіз. пам'яті.
  	 Розмір використ. пам'яті не огранічений.
  	 
  	
  	 Для очищення пам'яті викор. ф-ю kfree.

  	 Kzalloc обнуляє пам'ять перед поверненням вказівника.
     

#. Тасклети. Як реалізовані? Для чого використовуються? Наведіть приклад створення tasklet'у.

   - Тасклет це базовий механізм відложенної роботи, який визве передану
   	 йому ф-цію з данними, які йому передали, при наступному заході в bottom half.

     #include <linux/interrupt.h>	// додаємо заголовок, для роботи з тасклетами.

	 struct tasklet_struct {		// структура тасклета
     /* ... */
     void (*func)(unsigned long);
     unsigned long data;
     };
     
 	 ініціал. таски, передається
	 вказівник на структуру тасклета, вказівник на функцію, яку необх. виконувати і
	 данні, які передаються ф-ї. 
	 
	 void tasklet_init(struct tasklet_struct *t,
	 void (*func)(unsigned long), unsigned long data); 

	 DECLARE_TASKLET(name, func, data);
	 DECLARE_TASKLET_DISABLED(name, func, data);
