==============================
Юрченко Віталій Олегович
==============================


#. Який формат опису повідомлень комітів використовується в курсі? Навіщо потрібно дотримуватися певного формату?
   Наведіть приклад команди, що додає до репозиторію коміт з важливими виправленнями кодової бази
   
   <type>[optional scope]: <description>

   Потрібно для того щоб було зрозуміло що було зроблено в коміті. Якщо буде різним стилем буде складно читати.
   Якщо коміт має важливі зміни які можуть багато проблем потрібно додати **!** наприклад

   .. code-block::

        $ git commit -m "feat!: code base corrections"

#. Що таке об'єднання гілок та для чого використовується? Конфлікти при об'єднанні.
   Наведіть приклад конфлікту (синтаксис) та команди для внесення змін до репозиторію після вирішення конфлікту.

   .. code-block::

        $ git merge --squash <branch_name>

   fdsaaf
   можуть з'явитися конфлікти. Після цього у файлах з конфліктами з'виться

   .. code-block::

        ...
        <<<<<<< HEAD
        ...
        =======
        ...
        >>>>>>> <branch_name>
        ... 

   вибираємо що хочемо залишити і продовжуємо

   .. code-block::

        git add ...
        git commit -m "..."

#. Який інструмент використовується в курсі для автоматичного форматування вихідних файлів C відповідно до Coding Style?
   Де взяти основний шаблон з описом формату для коду ядра? Наведіть команду для форматування файлу module.c відповідно
   до Coding Style ядра.

   Використовується **clang-format**

   .. code-block::

        $ clang-format --style=LLVM module.c > module.c

#. Що таке Busybox? Для чого він використовується в курсі?

   BusyBox це збірка основних утиліт командного рядка які можна побачити в директорії /bin.
   Для лабораторних робіт ми збираємо ядро linux тому нам потрібно BusyBox.

#. Переповнення jiffies. Як розрахувати значення jiffies, що відповідає часу на 250 мс пізніше поточного значення?
   Які є функції для таких обчислень?

   Якщо в нас 32 бітна система то всеодно jiffies буде 64b, але ми використовуємо лише моложші 32b
   Функції можна знайти у файлі *include/linux/jiffies.h*

#. В якому порядку виконуються алокації та деалокації в модулях ядра. Наведіть приклад коду з обробкою виключень, якщо
   невдалось виділити певний ресурс. (з використанням goto)

   Деалокації виконуються в зворотному порядку алокаціям

   .. code-block::
   
        long *array = kmalloc(sizeof(*array), GFP_KERNEL);
        if (NULL == array) {
                status = ERROR_MEM;
                goto dealloc_end;
        }
        
        char *mass = kmalloc(sizeof(*mass) * 64, GFP_KERNEL);
        if (NULL == mass) {
                status = ERROR_MEM;
                goto dealloc_array;
        }
        
        ...
        ...
        ...
        
        dealloc_mass:
                kfree(mass);
        dealloc_array:
                kfree(array);
        dealloc_end:
        
        return status;

#. Наведіть приклад виділення та вивільнення пам'яті за допомогою kmalloc та vmalloc. Коли доцільно використовувати kzalloc?

   kzalloc очіщує перед виділення пам'яті. Це безпечніше бо ми не знаємо що до цього зберігалося в пам'яті.

   .. code-block::

        long *array = kmalloc(sizeof(*array), GFP_KERNEL);
        kfree(array);

        long *array2 = vmalloc(40 * PAGE_SIZE));
        vfree(array2);

#. Таймери на hrtimer. Чим відрізняються від таймерів на timer wheel? Для чого використовуються?
   Наведіть фрагмент коду для запуску таймера.

   hrtimers - це таймери високої роздільної здатності.
   hrtimers забезпечує точні таймери для роботи, яку необхідно виконати найближчим часом.
   timer wheel менш точні.

   .. code-block::

        static void timer_fn(struct timer_list *list);
        DEFINE_TIMER(my_timer, timer_fn);

        static int __init module_init(void)
        {
                ...

                mod_timer(&my_timer, jiffies + delay);

                ...
        }

        static void timer_fn(struct timer_list *list)
        {
                ...
        }


