Звіт до лабораторної роботи №2 
~~~~~~~~~~
Завдання:
~~~~~~~~~

#. Перенести на плату й встановити заголовки ядра.
#. Зібрати модуль ядра на **х86** та **ВВХМ**, після кожного підключення модуля до ядра дивитися логи через dmesg.
#. Взяти секундомір. Засікти час між двома включеннями модуля на x86 і BBXM. Взяти відповідні значення jiffies з логів. 
   Відповісти на питання: чи залежить різниця в двох значеннях jiffies від платформи?
#. Експериментально розрахувати час (в мілісекундах), рівне 1 jiffies. Порівняти з теоретичним значенням. 
   Результати включити в протокол по роботі.
#. Виправити код з прикладу ``firstmod.c``, щоб замість username виводилось ім'я передане в якості аргумента.
#. Додати в ``init`` модуля тасклет, який також виведе значння jiffies.
   Пояснити різницю між результатами виводів в ``init`` і тасклеті.
   
Виконання завдань
~~~~~~~~~~~
1. Встановлення заголовків
--------------
Для того, щоб встановити заголовки, їх потрібно спочатку завантажити. Для цього потрібно перейти за посиланням ``http://repos.rcn-ee.com/debian/``
далі в вікні шляху запиту додаємо ``pool/main/l/linux-upstream/linux-headers-4.18.11-armv7-x11_1stretch_armhf.deb``, щоб запит мав вигляд
``http://repos.rcn-ee.com/debian/pool/main/l/linux-upstream/linux-headers-4.18.11-armv7-x11_1stretch_armhf.deb``. Після завантаження,
цей файл потрібно переслати на плату, я це зробив за допомогою ``sshfs``. На платі розпакував щойно переданий архів командою ``sudo dpkg -i ./linux-headers-4.18.11-armv7-x11_1stretch_armhf.deb``.

2. Збирання модуля ядра
-------------
Щоб зібрати модуль ядра запуститв Makefile з прикладу, він зтворив з файлу firstmod.c, що також був в прикладі, файл firstmod.ko.
Цей файл і є файлом модуля ядра. Тепер потрібно завантажити цей файл командою ``insmod firstmod.ko``. Щоб побачити логи ядра використовують
``dmesg -k``.

 .. image:: img/1.png



3. Визначення часу між двома включеннями на різних архітектурах
----------------

*Технічні проблеми досі не вирішені, тому доповнюю це завдання розрахунком лише на ``х86``.*

Щоб визначити час між двома включенями я визначив jiffies в перший момент часу, та через 10 хвилин. Отрима такі результати:

 .. table:: Табилця 1. Значення jiffies для різних архітектур.
 	
 +------------------+------------+------------+
 |  Архітектура     |     t1     |  t1 + 10хв |
 +==================+============+============+
 |      x86         | 4301461712 | 4301642601 |
 +------------------+------------+------------+
 |      ARM         |            |            |
 +------------------+------------+------------+
 
**t = (t1 + 10) - t1  = 180889**

Значння ``t`` є кількістью тіків системного тайммеру за, приблизно, 10 хвилин, це значення збільшується при кожному перериванні системного таймеру, так як за 
1 секунду відбувається ``N`` переривать таймеру, значення jiffies збільшиться на N, тому час в секундах дорівнює ``jiffies/N``.
На моїй x86 N = 300.
Тепер переведемо це значення в хвилини:

**T = 180889 / 300 = 602.9** секунд, що дорівнює **10.04** хвилини.

 

4. Експерементальний розрахунок
---------------

*Буде доповнено пізніше*


5. Передача аргументу в код модуля ядра
--------------

Модулі можуть приймати аргументи командного рядка, але не через ``argc / argv``.
Щоб дозволити передачу аргументів у модуль, потрібно оголосити змінні які приймуть значення аргументів командного рядка як глобальні,
а потім використати макрос ``module_param ()``, (визначений у ``linux / moduleparam.h``). 
Потім під час виконання insmod потрібно заповнити змінні аргументами командного рядка, 
наприклад ``./insmod mymodule.ko myvariable = 5.``

В моєму випадку, потрібно передати в програму рядок, тому змінну оголошено як ``static char *name = "name"``.
Макрос ``module_param()`` визначений як ``module_param (name, charp, 0000);``.
Щоб програма виводила цей аргумент, потрібно в функції ``__init firstmod_init`` додати специфікатор ``%s`` та ``name``. 

  .. image:: img/hellora7e.png

6. Визначення ``jiffies`` через тасклет
--------------

Тасклет - достатньо складна річ, яка виконує відкладену обробку переривань. Спочатку потрібно задекларувати тасклет.
Для цього викликаємо ``DECLARE_TASKLET(tasklet, tasklet_handler, 0)``, де ``tasklet``- ім'я тасклету, ``tasklet_handler`` - функція-обробник,
``0``- аргумент, що передається в функцію обробник. В цьому випадку значення передавати в функцію не потрібно, 
тому я вказав на місці фактичного аргументу ``__unsed`` ,що означає, що функіція не прийматиме аргумет.
Щоб вивести значення *jiffies* за дапомогою тасклету, я в функції ``tasklet_handler``
за допомогою ``printk`` вивожу значення ``jiffies``. Потім, в функції  ``__init firstmod_init`` викликаю ``tasklet_handler``.

  .. image:: img/tasklet.png

Вихідний код програми:
 
 .. code-block:: C
 
  void tasklet_handler(unsigned long __unused)
  {	
	
	printk(KERN_INFO "Tasklet jiffies = %lu\n", jiffies);
	
  } 

  static int __init firstmod_init(void)
  {
	tasklet_schedule(&tasklet);
	
	printk(KERN_INFO "Hello, %s\njiffies = %lu\n", name, jiffies);
		
	tasklet_handler(jiffies);
	
	return 0;
  }
  
  
Перед викликом тасклета, його роботу потрібно запланувати та поставити в чергу.
Цю дію виконує функція ``tasklet_schedule()``, також є функції ``tasklet_hi_schedule`` ``tasklet_hi_schedule_first``, 
що відрізняються приорітетом виконання.  
Після виконання тасклет повинен бути видалений з черги на виконання, це робить функція tasklet_kill().

 .. code-block:: C

  static void tasklet_exit(void)
  {
	tasklet_kill(&tasklet);
	
  }
 
Звичайно, не обов'язково було створювати функцію для зняття тасклету з черги (``tasklet_exit``), просто мені сподобалось як це було реалізовано 
в прикладі, на який я орієнтувався, його можна переглянути за посиланням: ````  
 
Висновок:
------------
На системі x86 jiffies показав себе як відносно точний механізм відліку часу, похибка склала 0.4%.
*To be continued*  

