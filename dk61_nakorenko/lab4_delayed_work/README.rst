Звіт з виконання лабороторної роботи №3
=============================================

**У даній лабораторній роботі було виконано наступні задачі:**


Написано найпростіший модуль ядра який:

* запускає на одночасне виконання M потоків 
* кожен поток інкрементує глобальну змінну N разів, після чого кладе поточне значення змінної до спику
* під час вилучення модуль виводить значення глобальної змінної, та значення елементів списку
* для задання значень N та M використано параметри модуля, яки передаються при підключенні модуля
* для пам'ять виділяється динамічно
* помилки при виділенні пам'яті перевіряються та оброблюються
* реалізовано функції ``lock()`` та ``unlock()`` за допомогою бібліотеки ``asm/atomic.h``
* за допомогою даних функцій було синхронізовано роботу двох потоків, та виконано захист спільного блоку пам'яті в якому зберігається глобальна змінна

Щоб запустити потік на виконання потрібно використати функцію ``kthread_create``, потім "розбудити" цей потік за допомогою `` wake_up_process()``, коли він буде потрібний.
Але також існує функція ``kthread_run()``, що відразу створить і запустить потік.

``struct task_struct *kthread_run(int (*threadfn, (void *)data, void *data, const char *namefmt, ...);``

*де*
		``*threadfn - вказівник на функцію, що виконається в потоці;``
		``(void *)data - данні, що передаються в функцію-обробник;``
		``const char *namefmt - ім'я потоку.``
	
Для того, щоб створити та  запустити на виконання декілька потоків, я використав цикл.

.. code-block:: c
	for(int i = 0; i <= n_of_threads; i++)
	{	
		threads[i] = kthread_run(&thread_func, (void*)iterator, "Thread %i", i);
	}

Потокова функція збільшує значення лічильника. Потрібно зазначити, що потоки можуть перехватити право на виконання виконання, тому, вірогідно, значення, що "порахує" 
функція може бути неправильним. Для того, щоб заблокувати можливість перехвату прав використовують атомарні операції - інструкції, які виконуються атомарно, тобто не перериваючись.
Засоби виконання атомарних операцій працюють з спеціальним типом данних ``atomic_t``, що забезпечує те, що данні з цим типом данних не можуть передатись в 
функції, що не виконують атомарних операцій. Також спеціальний тип гарантує, що компілятор не буде оптимізувати операції звернення до атомарних операцій.

.. code-block:: c
	static void* create_lock(void)
	{
		atomic_t *ptr_lock = kmalloc(sizeof *ptr_lock, GFP_ATOMIC);
		arch_atomic_set(ptr_lock, UNLOCKED);
		return ptr_lock;
	}

	static void lock(atomic_t *lock)
	{
		while (LOCKED == arch_atomic_cmpxchg(lock, UNLOCKED, LOCKED));
	}

	static void unlock(atomic_t *arg)
	{
		arch_atomic_set(arg, UNLOCKED);
	}



Далі, для комфортного зберігання результатів роботи всих потоків я використовував зв'язний список. В ядрі Linux вже реалізовано списки, в файлі <linux/list.h>.
Для того щоб скористатися можливостями даної бібліотеки, необхідно додати елемент структури ``struct list_head`` 
до своєї структури даних. А далі можна користуватися функціями для роботи зі списком.
Оголошую структуру:

.. code-block:: c
	struct my_list {
		struct list_head list;
		int number;
	};
	
	*де* ``number`` - змінна в якій буде зберігатися значення результату кожного з потоків.

Далі потрібно ініцілізувати список 

.. code-block:: c

	LIST_HEAD(first_node_LIST);

Для того щоб додати елемент до списка необхідно використати наступну функцію:

.. code-block:: c
 
	list_add(&this_node->list, &first_node_LIST);

*де* 
	``&this_node->list`` - елемент який необхідно додати до списка, 
	``&first_node_LIST`` - список.

Для того, щоб роздрукувати та видалити елементи списку були створені відповідні функції:

.. code-block:: c

	static void print_list(struct list_head *for_print)
	{	
		struct list_head *prt;
		struct my_list *data;
	
		list_for_each(prt, for_print)
		{
			data = list_entry(prt, struct my_list, list);	
			printk(KERN_INFO "value %d", data->number);
		}
	}

	static void delete_list(struct list_head *for_del)
	{
	struct list_head *ptr, *tmp;
		list_for_each_safe(ptr, tmp, for_del)
		{
			list_del(ptr); 
		}
	printk(KERN_INFO "Threads deleted\n");
	}

Функція ``list_for_each`` надає можливість пройти по усім елементам списку, де ``prt`` вказує на елементи списку ``for_del``, тобто розкривається в цикл ``for``.
Але розробники рекомендують використовувати саме макрос  ``list_for_each``, адже макрос виконує початкове завантаження данних в пам'ять, що зменшує вірогідність втрати частини данних.
Макрос ``list_entry`` повертає структуру данних, яка містить відповідний елмент структури ``list_head``.
В свою чергу макрос ``list_for_each_safe`` - використовує тимчасові змінні, для того, щоб видалення елементів списку було безпечним.


**Результат**
~~~~~~~~~~~~~~~~~~~~

Результат роботи програми без локів:

  .. image:: img/without_lock.png

Рисунок 1 - Результат без блокувань на x86
 
Кожен з потоків повинен був рахувати по 1000000. Видно, що значення, які пораховані в потоках, не відповідають очікуваним.

Результат роботи після застосування локів:

  .. image:: img/lock.png
  
Рисунок 2 - Результат з блокуваннями на x86
  
Можна бачити, що кожен з потоків рахує по 1000000.

Результати вище були отримані на x86 архітектурі. результати на ARM:

  .. image:: img/without_arm.png
  
Рисунок 3 - Результат без блокувань на ARM

Цікаво, що перший та четвертий потоки порахували правильно.

  .. image:: img/lock_arm.png

Рисунок 4 - Результат з блокуваннями на ARM


Висновок: блокування є важливою фічею для багатопоточного програмування, що дозволяє правильно виконувати багатопоточні програми на одноядерних та багатоядерних процесорах.





























  
  
  
  
