=============================================
Лабораторная работа №1: Мультипоточное приложение 
=============================================

Структура директории (Directory structure)
-----

+-------------------+----------------------------------+ 
| Folder and files  | description                      |
+===================+==================================+ 
|        scr        | The source code of the lab work  |
+-------------------+----------------------------------+ 
|       Makefile    | File to compile project          | 
+-------------------+----------------------------------+ 
|       README.rst  | Lab work report                  |
+-------------------+----------------------------------+


Задание
-----
Создание программы на языке С, которая реализует увеличение глобальной переменнной на 1 в двух потока. 
Потоки созданы с помощью библиотеки pthread.h. Результат выводиться после окончания двух потоков. 
Провести компиляцию с флагами компилятора -O0 и -O2 для архитектуры x86 и для ARMv7

Выполнение 
-----
В директории ``src`` данной лабораторной работы находиться исходный файл ``multi.c`` с результатом выполнения 
задачи создания мультипоточного приложения. Проведём небольшой анализ исходного кода:

#. Глобальная переменная ``count`` выступает в качестве счётчика. Именно эта переменная будет инкрментироваться
   в потоках. Размер её заведемо взят достаточно большим для тестирования на больших числах.
      
      .. code-block:: C
      
        long long count;
        
#. Функция ``thread_func`` выполняет функцию инкрементации глобального счётчика. Функция получает указатель на переменную 
   с числом количества итераций. 
      
      .. code-block:: C
      
        void *thread_func(void *argument) 
        {
        
          long long i, upper = atoll(argument);
          
          if (upper > 0) {
          
            for (i = 1; i <= upper; i++)
              count++;
          }
         
          pthread_exit(NULL);
        }

#. В функции ``main`` создаються два идентификатора потока ``tid`` и ``tid2``. С помощью функции ``pthread_create`` 
   создаються сами потоки, куда также передается аргумент командной строки ``argv[1]``. Именно через аргумент командной 
   строки задаётся количество итераций инкремента. ``pthread_join`` позволяет дождаться окончание указаного потока 
   за счёт блокировки вызывающего потока.        
   
    .. code-block:: C
      
          int main(int argc, char *argv[]) 
          {
            /** 
             * tid, tid2 - threads identifier  
             */
            pthread_t tid; 
            pthread_t tid2; 
            
            ....

            /**
             * We should call set task pthread_create() on a create threads (2, in our case). 
             */
            pthread_create(&tid, NULL, thread_func, argv[1]);
            pthread_create(&tid2, NULL, thread_func, argv[1]);

            pthread_join(tid,NULL);
            pthread_join(tid2,NULL);
            printf("count = %lld\n",count);
          }
          
Сборка проекта и тестирование 
-----          
Процесс сборки и запуска проекта следующий:

#. Для автоматизированной сборки используется ``Makefile``. С помощью команды ``make`` производиться сборка и компиляция 
   проекта с оптимизацией ``-O0``. Для компиляции на других степенях оптимизации можно использовать соответствующий аргумент.
   Например, для компиляции с оптимизацией ``-O2`` нужно использовать ``make O2``.
#. Для запуска программы нужно использовать в командной строке ``./multi <argument>``, где в качестве ``<argument>`` 
   пользователь вводит нужное ему число итераций инкремента глобальной переменной.
#. После окончания работы программы в терминале будет выведен результат об окончательном состоянии глобальной переменной. 
#. Для удаления резульатов сборки можно использовать ``make clean``.  

Анализ полученных результатов 
-----   
При тестировании на архитектурах x86 и ARMv7 на степени оптимизации ``-O0`` на числах количества итераций не больше ``10 000`` 
результат ничем не отличается и есть абсолютно правильным - результат равен удвоеному числу количества итераций. Однако, на 
числах большего порядка возвращается неверный результат. Он связан с тем, что один поток не успевают завершиться до вызова 
следующего и может прервать его во время инкремента, который является неатомарной операцией. В самом начале происходит загрузка
переменной в отдельный регистр, где потом инкрементируется и вновь выгружается обратно. Между этапами загрузки и выгрузки
может произойти переход на второй поток, который обнуляет прогресс первого потока. Для проверки этого утверждения можно 
проанализировать ассемлерный листинг программы на оптимизации ``-O0``:

.. code-block:: C
      
        movq	count(%rip), %rax	# count, count.5_1
	addq	$1, %rax	#, _2
	movq	%rax, count(%rip)	# _2, count

Как можно увидеть выше, инкремент происходит со значением в регистре ``%rax``, в который была загружена копия глобальной 
переменной. Решить данную проблему можно с помощью задержки (что помогает не всегда) или использовать механизм мьютексов, 
которые не позволяют перключиться на обработку задачи без снятия блокировки мьютекса другим потоком. 

При степени оптимизации ``-O2`` процесс инкрементирования в три инструкции (на каждой итерации) заменяется на одну инструкцию,  
что обеспечивает правильный результат на выводе. Ассемблерный листинг операции указан ниже:

.. code-block:: C

  addq	%rax, count(%rip)


