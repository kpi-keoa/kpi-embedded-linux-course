=============================================
Лабораторная работа №2: Простой модуль ядра  
=============================================

Структура директории (Directory structure)
-----

+-------------------+----------------------------------+ 
| Folder and files  | description                      |
+===================+==================================+ 
|        scr        | The source code of the lab work  |
+-------------------+----------------------------------+ 
|       Makefile    | File to compile project          | 
+-------------------+----------------------------------+ 
|       README.rst  | Lab work report                  |
+-------------------+----------------------------------+


Цели и задание
-----
Изученение модулей ядра Linux на основе `учебного модуля <https://bit.ly/2kLBtD9>`__. Модификация существующего
учебного модуля путём добавления параметров передаваемых при подключении, добавление ``tasklet`` для вывода значения
``jiffies``. Сравнение полученых результатов ``jiffies`` из ``init`` и ``tasklet``. Провести подключение на архитектурах 
``x86`` и ``ARMv7``. Анализ результатов и их теоретическое обоснование. 

Теоретическая база работы 
-----
Модули ядра представляют особый вид объектов действующих в ОС ``GNU/Linux`` на базе ядра ``Linux``. Он работают в 
пространстве ядра. Имеют привелегию по отношению к ``userspace-``приложениям. Не работают со стандартными библиотеками, а 
также не имеют ``main`` как стандартную точку входа. В большинстве случаев разработчики модулей избегают работу с ``FPU``. 
При подключении модуля вызывается функция инициализации ``__init <function_name>``, а при его удалении - ``__exit <function_name>``
Для декларации этих функций нужно использовать ``module_init(name_of_init_func)`` и ``module_exit(name_of_exit_func)``.
Для функционирования модуля нужно указать его линцензию с помощью специального макроса, а по желанию и автора, описание, версию и т.д.

В модулях ядра можно испозьзовать механизмы отложенных прерываний и тасклетов. Тасклеты — это механизм построения ``bottom half`` 
(нижних половин) обработчиков прерываний на основе механизма отложенных прерываний. Они не имеют ничего общего с задачами (task). 
По своей природе и принципу работы они очень похожи на отложенные прерывания, но имеют более простой интерфейс и упрощенные 
правила блокировок. Тасклеты представляются в виде структуры ``tasklet_struct``. Каждый экземпляр структуры представляет собой уникальный 
тасклет. Эта структура определена в файле ``linux/interrupt.h``. Задекларировать тасклет можно с помощью макроса ``DECLARE_TASKLET`` 
или вручную через инициализацию экземпляра структуры ``tasklet_struct``. Также необходимо описать функцию-обработчик тасклета. 
Запланировать выполнение таксклета можно с помощью ``tasklet_schedule(&<tasklet_name>)``. Когда тасклет запланирован на выполнение, 
ядро генерирует одно из двух отложенных прерываний. Отложенные прерывания, в свою очередь, обрабатываются 
с помощью специальных функций, в которых запускаются все запланированные на выполнение тасклеты.
В этих функциях предприняты меры, которые позволяют гарантировать, что только один тасклет данного типа будет выполняться 
в любой момент времени (но тасклеты разных типов могут выполняться одновременно). 
После планирования тасклета на выполнение он будет запущен всего **один раз** в некоторый момент времени в ближайшем будущем. 
Если до запуска тасклет будет запланирован на выполнение еще раз, то он также запустится всего **один раз**.

Для синхронизации процессов в системе и управление системным временем используется системный таймер, который тактируется от кварцевого
резонатора с постоянной и достаточно точной частотой, обеспечивая стабильность работы таймера. По окончанию периода работы таймера, 
процессору передается сигнал и возникает прерывание со своим обработчиком. Частота импульсов системного таймера (tick rate)
программируется при загрузке системы на основании значения статически определенной директивы препроцессора ``HZ``. 
Значение параметра ``HZ`` зависит от используемой аппаратной платформы. Есть два мнения по поводу выбора значения ``HZ``: порядок
сотни или порядок тысячи. Большое значение ``HZ`` позволяет запускать прерывания по таймеру более часто и улучшить точность определения времени, 
корректнее вытеснять задачи. Но существует проблема повышения расходов за счёт более частого внимания на обработчик таймера. Что 
может привести к уменьшению времени внимания процессора на другие процессы, а также преждевременно очищает кэш. В определенных условиях 
всё это уменьшает производительность. 

Отдельное внимание заслуживает глобальная переменная ``jiffies``, в которой содержится количество импульсов системного таймера, 
которые были получены со времени загрузки системы. Во время начальной загрузки ядро обнуляет значение этого параметра.в
При каждом прерывании системного таймера он будет увеличиваться на единицу. Поскольку каждую секунду возникает HZ прерываний
от системного таймера, за секунду значение переменной ``jiffies`` увеличивается на ``HZ``.  

Тип переменной ``jiffies`` объявлен как ``unsigneg long``, который на 64-х разрядных архитектурах является 64 бита, а на 32-х 
разрядных архитектурах - 32 бита. Но стоит отметить, что реализация немного не прозрачная. Существует счётчик длиной 64 бита для 
всех архитектур, и носит название - ``jiffies_64``. В ходе инициализации эта переменная просто приравнивается к ``jiffies``. Таким образом,
для 32-разрядных архитектур в переменной ``jiffies`` младшие 32 бита значения ``jiffies_64``. 64 бита необходимы для управления ходом времени, 
так как такая переменная фактически не переполниться в процессе эксплуатации устройства. На 64-разрядных архитектурах обе переменные идентичны.
А какое начальное значение ``jiffies``? Многие источники говорят, что оно нулевое. Но на самом деле это не так. Если обратиться к исходному 
коду ядра в библиотеку ``jiffies.h`` то можно увидеть обьявление макроса:

.. code-block:: C
      
        #define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))
        
это говорит о том, что начальное значение ``jiffies`` сдвинуто на 5 минут относительно нуля. Сделано для избежания ошибок именуемыми
в исходниках как ``wrap bugs``. На 64-разрядных системах начальное значение будет ``(2^32) - 300*HZ``, но так как переменная сама 
64 битная, то она не перполниться. На 32-разрядных системах она также будет иметь такое же значение, но переполнится после ``(2^32)-1``.
В итоге, можно сказать что вычисление времени стоит проводить не относительно нуля, а относительно выше описаного значения. Так и происходит 
в логах ядра. Если этим пренебречь, то результат будет на 300 секунд меньше реального. Например, для 32-разарядной системы имеем такой лог ядра:

.. code-block:: C

        [ 2009.029653] Value of Jiffies from tasklet = 170900
Значение ``HZ = 100``.          
Вычислим время работы системы относительно нулевого значения ``jiffies``: ``jiffies/HZ = 170900/100 = 1709 секунд``. Результат (с учётом точности
вычисления) на 300 секунд меньше от реального значения из результатов лога ядра. На самод деле изначально ``jiffies = (2^32) - 30 000``, 
которое затем переполняется, и начинает счёт с нуля. 

Выполнение  
-----
В директории ``src`` данной лабораторной работы находится исходный файл модуля ядра ``firstmod.c`` 
с результатом заданий в рамках данной работы. Проведём небольшой анализ исходного кода:

#. С помощью специальных макросов была продена инициализация информации модуля:
      
      .. code-block:: C
      
        MODULE_DESCRIPTION("Basic module demo: init, deinit, printk, jiffies, tasklet");
        MODULE_AUTHOR("MaksHolub");
        MODULE_VERSION("0.1");
        MODULE_LICENSE("Dual MIT/GPL");	

#. Описаны функции инициализаци и окончания работы модуля. В ``firstmod_init`` помимо вывода строки с именем пользователя и ``jiffies``
   также добавлена функция ``tasklet_schedule`` для запланирования выполнения тасклета. В свою очередь в ``firstmod_exit`` вызывается
   ``tasklet_kill`` для уничтожения тасклета.     
      
      .. code-block:: C
     
        static int __init firstmod_init(void)
        {
          printk(KERN_INFO "Hello, %s!\njiffies = %lu\n", username, jiffies);
          tasklet_schedule(&simple_tasklet);
          return 0;
        }

        static void __exit firstmod_exit(void)
        {
          tasklet_kill(&simple_tasklet);	
          printk(KERN_INFO "Long live the Kernel!\n");
        }

#. Само обьявление тасклета и его обработчик наведены ниже        
   
    .. code-block:: C
    
          static void tasklet_handler(unsigned long jiffy_value);
          DECLARE_TASKLET(simple_tasklet, tasklet_handler, 0);
          
          ...
          
          static void tasklet_handler(unsigned long jiffy_value)
          {
            printk(KERN_INFO "Run simple tasklet!\n");
            printk(KERN_INFO "Value of Jiffies from tasklet = %lu\n", jiffies);

          }
          
Сборка модуля и тестирование 
-----          
Процесс сборки и запуска проекта следующий:

#. Для автоматизированной сборки используется Kbuild. С помощью команды ``make`` производиться сборка и компиляция 
   модуля. Для кросс-компиляции можно также указать архитектуру, компилятор и директорию исходников.  
   Например, компиляции для ARMv7 для SoC ``Zynq-7000``: ``make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabihf- KBUILDDIR=<path_to_linux_src>/linux-xlnx-xilinx-v2017.4/``.
#. Для добавления модуля в ядро нужно использовать ``sudo insmod firstmod.ko``. Для передачи аргумента с именем пользователя
   стоит также добавить к команде ``username=<your_name>``.
#. Для просмотра логов ядра можно использовать ``dmesg -k | tail -20``.   
#. Для удаления модуля нужно использовать ``sudo rmmod firstmod.ko``.
#. Для удаления резульатов сборки можно использовать ``make clean`` и ``make tidy``.

Анализ полученных результатов 
-----   
Было проведено тестирование модуля на архитектурах x86 и ARMv7 SoC Zynq-7000. Лог ядра с результатами работы для ``x86``:

.. code-block:: C

    [17068.782173] Hello, maks!
                   jiffies = 4299997895
    [17068.782348] Run simple tasklet!
    [17068.782349] Value of Jiffies from tasklet = 4299997895
    [17082.227794] Long live the Kernel!
    
Лог ядра для ``ARMv7 SoC Zynq-7000``:
 
.. code-block:: C

    [  216.074999] Hello, zybo!
                   jiffies = 4294958900
    [  216.078092] Run simple tasklet!
    [  216.079924] Value of Jiffies from tasklet = 4294958901
    [ 1996.694877] Long live the Kernel!
    [ 2009.025077] Hello, zybo!
                   jiffies = 170899
    [ 2009.027827] Run simple tasklet!
    [ 2009.029653] Value of Jiffies from tasklet = 17090

Для второго случая специально было сделано для вывода с прододжительной паузой для демонстрации выше обозначеной теории, о инициализации
``Jiffies`` не нулём, а значение в эквиваленте на 5 минут позже. Таким образом, видно переменную до переполнения и после. 
Впочём почти похожая ситуация происходит и в первом случае, но переменная не переполняется ввиду её размера.

Также можно увидеть, что на ARM значение ``Jiffies`` разниться на ``1``. Это связано с продолжительностью времени, которое отвечает значения
равное ``1 jiffies``. x86 и ARM по стандарту имеют значения ``HZ`` равное ``300`` и ``100`` соответсвенно. Таким образом: ``1 jiffies = 1/HZ''.
Результат для ``x86``: ``1/300 = 0.003(3) секунд``; Результат для ``ARM``: ``1/100 = 0.01 секунд``;
Как можно заметить, значение ``jiffies`` обновляется быстрее в 3 раза на x86. Также выше точность вычисления времени. Но за счёт более
быстрой работы устройства на ``x86`` и большей скорости обработки обработчика таймера , то разница времени между выводом значения   
``Jiffies`` из функции инициализации и тасклера меньше точности увелечения ``Jiffies``. Что можно видеть по логу ядра. 
Напротив, для ARM ситуация противоположная: разница во времени между выводом значения ``Jiffies`` из функции инициализации и тасклера 
может быть достаточной для обновления ``Jiffies`` на единицу.
