=================================================
**Лабораторная работа №1 Мультипотоковое приложение**
=================================================

Тема: Создание мультипоточного приложение под Linux
---------------------------------

Цель: С помощью языка С и библиотеки pthread создать мультипоточное приложение. Протестировать работоспособность под х86 и ARM, замерять скорость работы и проанализировать ее.
------------------------------------

Структура директории (Directory structure)
-------------------------------------------
+-------------------+----------------------------------+ 
| Folder and files  |            Description           |
+===================+==================================+ 
|        scr        | The source code of the lab work  |
+-------------------+----------------------------------+ 
|       Makefile    |     File to compile project      | 
+-------------------+----------------------------------+ 
|       README.rst  |         Lab work report          |
+-------------------+----------------------------------+

**Задание:**
~~~~
* Написать программу итерирующую переменную в двух потоках(каждый поток итерирует 10000000 раз);
* Замерять скорость выполнения программы;
* Вывести данные в терминал(результат итерации и время);
* Протестировать работу при разной оптимизации -О0 и -О2;
* Сравнить результаты.

**Ход работы:**
-----------
В дериктории ``src`` помещен файл ``main.c`` с готовым программным кодом.

В коде используються библиотеки:
~~~~
* ``pthread.h`` - библиотека для мультипоточности
* ``stdio.h``   - библиотека использующая ввод и вывод данных в консоль
* ``time.h``    - Для замера тактов, времени выполнения

Глобальная переменная ``iter`` используются в потоках для итерации. Приравниваем ее сразу нулю. Тип данных ``int`` 
так как будем итерировать ее, число итераций не выходит за приделы этого типа.

Функция ``stream_iter`` вызывается в мультипоточности и выполняет задачу инкрементации глобальной переменной. 
Ниже приведен синтаксис этой функции.

.. code-block:: C

  void *stream_iter(void *param) 
  {
          for (int i; i < 10000000; i++) { // constant - given in the task, used for comparison
                  iter++;
          }
  
          pthread_exit(0);
  }

Функция ``main`` содержит в себе инициализацию двух переменных ``c_s`` и ``c_e``, для вычисления тактов затраченных процессором. 
Так же инициализируються два потока ``tid0`` и ``tid1`` типа ``pthread_t``. С помощью функции ``pthread_create`` создаються сами потоки.
Функция ``pthread_join`` ждет завершения потока, за счет блокировки потока.

.. code-block:: C

  int main(int argc, char *argv[])
  {
          clock_t c_s, c_e; // variables for calculating program execution speed
          c_s = clock();
  
          pthread_t tid0; // stream creation
          pthread_t tid1;
  
          pthread_create(&tid0, NULL, stream_iter, NULL); // call thread
          pthread_create(&tid1, NULL, stream_iter, NULL);
          pthread_join(tid0, NULL); // waiting for thread to finish
          pthread_join(tid1, NULL);
  
          c_e = clock() - c_s;
          printf("count = %d\ntime = %i\n", iter, c_e);
  }


Вывод
----

Программа без оптимизации выполняется не правильно на обеих архитектурах. Но на х86 эта ошибка вызвана паралельным вызовом команд и 
одновременной записью, тем самым оба потоки одновременно взяли одно и то же значение, ссумировали и записали одно и то же(операция 
выполняется в один такт). А на ARM получили огромное значение из за ошибок записи, операция итерации выполняется более одного такта.

С -О2 ситуация вообще другая. Расчет проводиться на стадии компиляции, по этому в обоих случаях быстро расчитывается.




