=================================================
**Лабораторна робота №0**
=================================================
**Тема: Робота з потоками** 
~~~~~~~~~~~~~
**Завдання:**
~~~~~~~~~~~~~
Написати код в якому:

* Створити глобальну змінну, ініціалізовану в 0;
* Створити функцію потоку, яка N разів додає до цієї змінної К;
* Запустити два потоки з цією функцією;
* Дочекатись завершення потоків використовуючи ``pthread_join()``;
* Вивести в ``stdout`` очікуване та фактичне значення глобальної змінної;

**Хід роботи:**
---------------
В першу чергу було підключено стандартні бібліотеки для конфортної роботи. Також для роботи з потоками підключаємо біблотеку - ``pthread.h``
Створюючі глобальну змінну, використовуємо модифікатор ``volatile``, який буде казати компілятору про те, що значення змінної може змінюватися ззовні і що 
компілятор не буде оптимізувати цю змінну. Це робиться для того, щоб далі перевірити коректність результату при різних оптимізаціях.
Далі було створено функцію ітерування глобальної змінної:

.. code-block:: C

  void *increment_func(void *args)
  {
	struct params *steps = args;
	
	for (int i = 0; i < steps->N; i++) {
		global += steps->K;
	}
  }

А також стровено функцію, яка заносить коректні дані, якщо раптом при їх введенні після цифр були введені непотрібні символи:

.. code-block:: C

  int check(char *arg, long *result)
  {
	int res;
	char sym;
	if (1 != sscanf(arg, "%d\"%c\"", &res, &sym))
		return 1;
	else *result = res;
		return 0;
  }

Ідея реалізація цієї функції була взята у викладача курсу, Ходнєва Т.А.

Для створення потоку використовуємо функцію ``pthread_create``, 
та очікуємо завершення потоку функцією ``pthread_join``.

Код реалізації знаходиться в директорії ``src``
за назвою ``thread.c``.

**MakeFile**

Для зручності було написано MakeFile, який за нас вводить всі прапорці, які потрібні нам для компіляції, а також має цілі для видалення непотрібних 
файлів, утворенних в резулятаті компіляції.

При зміні прапорця оптимізації OPTFLAG, під час запуску MakeFile, ми можемо протестувати програму при різних оптимізаціях.

Висновки
--------
В результатом лабораторної роботи було написано програму що показує роботу двох потоків з однією змінною, а саме, ітерування цієї змінної.
Перевіривши роботу програми з різними прапорцями оптимізації, тільки -O2 при кожному запуску видає правильні результати за рахунок того, що код було оптимізовано.
Програма скомпільована з прапорцем -O0, а також програма скомпільована з прапорцем -O2 та глобальною змінною з модифікатором ``volatile`` в результаті видають фактичні значення, 
які відрізняються від очикуваних. Відбувається це тому, шо в першому випадку прапорцем -О0 ми зовсім відключаємо оптимізацію, а в другому, модифікатор ``volatile`` дозволяє 
змінювати нашу змінну будь-яким потокам, що в свою чергу призводить до "гонок даних".

Було розглянуто, що для правильної роботи потоків, потрібно перевіряти, чи не використовують декілька потоків одночасно спільну пам'ять.
Тому для коректної роботи програми необхідно використовувати засоби для потокової безпеки (м'ютекси, бар'єри пам'яті тощо).



