~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Лабораторна робота №1 Введення в розробку модулів ядрa
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Теоретичні відомості
~~~~~~~~~~~~~~~~~~~~
Ядро
""""

Ядро - це найнижчий рівень програмного забезпечення, яке взаємодіє з апаратними засобами комп'ютера. Воно відповідає за взаємодію всіх програм, які працють в просторі користувача аж до фізичного обладнання.
Більшість ядер можуть бути одного з трьох типів: 
		* монолітне ядро
		* мікроядро
		* гібрид 
Ядро Linux являє собою ``монолітне ядро``.
*Монолітні ядра* охоплюють не тільки процесор, пам'ять, але і включають в себе такі речі, як драйвери пристроїв, управління файловою системою, систему введення-виведення. Монолітні ядра дають кращий доступ до обладнання та реалізують кращу багатозадачність, тому що якщо програмі потрібно отримати інформацію з пам'яті або іншого процесу, їй не доведеться чекати в так званій черзі. Але це і може викликати деякі проблеми, тому що багато речей виконуються в режимі суперкористувача. І це може принести шкоду системі при неправильній поведінці.

  .. table::
  Плюси і мінуси такого ядра:

+-------------------------------------------+-----------------------------------+
| Плюси                                     | Мінуси                            |
+===========================================+===================================+
| Більш прямий доступ до апаратних засобів  | Більший розмір                    |
+------------+------------------------------+-----------------------------------+
| Простіше обмін даними між процесами       | Займає багато оперативної пам'яті |
+------------+------------------------------+-----------------------------------+
| Процеси реагують швидше                   | Менш безпечно                     |
+-------------------------------------------+-----------------------------------+


Також, один із недоліків такої архітектури є: неможливість установки нових драйверів без перезбирання ядра. Проте розробники знайшли рішення і цієї проблеми, *додавши систему модулів* .

Ядро Linux дозволяє драйверам обладнання, файлових систем, і деяким іншим компонентам бути скомпільованими **окремо - як модулі, а не як частина самого ядра**.

**Завдання:**
~~~~~~~~~~~~~

* Виконати кроки по збірці ядра.    
* Зібрати мінімальне ядро. 
* Розібратись з особливостями базових структур ядра.
* Написати власний модуль ядра, який передбачає:    
    * Вивід імені користувача при підключенні модуля. до ядра. Якщо параметр не задано, виводить попередження    
    * Вивід часу між макросами ``init``, ``exit``.


**Хід роботи:**
~~~~~~~~~~~~~~~

При розробці модулю було модифіковано найпростіший модуль з двома макросами
з прикладу до лабораторної роботи. Принцип роботи модуля полягає у виводі імені 
користувача у макросі init, якщо воно задано, та виводі часу роботи між ``init`` та ``exit``. 
Якщо ж параметр імені не задано, то макрос ``init`` сигналізує про це.

**Використані бібліотеки**
--------------------------

* ``<linux/module.h>`` потрібна для всіх модулів    
* ``<linux/kernel.h>`` заголовки ядра    
* ``<linux/init.h>`` використовується для ініціалізації та деініціалізації    
* ``<linux/jiffies.h>`` тут лічильник та допоміжні функції    
* ``<linux/moduleparam.h>`` для використання параметрів    

**Використані макроси та функції**
----------------------------------

``MODULE_DESCRIPTION`` макрос для опису модуля    

``MODULE_AUTHOR`` автор модуля    

``MODULE_VERSION`` версія модуля    

``MODULE_LICENSE`` тип ліцензії. У мене GPL    

``module_param`` використовується для передачі параметрів в модуль    

``jiffies_delta_to_msecs`` використовується для розрахунку проміжку часу    

``printk`` використовується для виведення інформації в лог ядра    



Висновки
~~~~~~~~

В ході виконання лабораторної роботи було протестовано середовище для збірки 
мінімального лінукс ядра, проемульовано в емуляторі QEMU , створено та протестовано 
найпростіший власний модуль по виводу імені користувача та часу роботи між макросами
init та exit. Спершу було протестовано модуль, передавши туди параметр username. 
Ядро вивело відповідну фразу "Hello (user name)" та кількість переповнень лічильника. 
Після цього при виході з ядра у консоль виведено специфічну строку та час роботи між макросами. 
Таку ж саму операцію проведено без передачі параметру. Відрізнялось лиш тим, що у консолі
виведено попередження, що параметр не задано і що цей параметр дефолтний, у данному випадку "$username".
P.S За основу буз взятий протокол Антона Волошина.
