=====================
Лабораторна робота №5
=====================

Тема
------

**Workqueue**

Завдання:
---------

Написати та зібрати  власний модуль ядра, який:
	* Принимает аргументы th_val, wrk_val и jffdelay, реализует два потока и ворк (в дефолтном work queue), а также таймер (на базе timer wheel)
	* Запускает таймер и ворк
	* При срабатывании таймера проверяет текущее значение jiffies, если оно кратно th_val – остановить первый поток; иначе – таймер перезапускается через jffdelay jiffies
	* Внутри ворка проверяет текущее значение jiffies, если оно кратно wrk_val - остановить второй поток; иначе – ворк должен уснуть на jffdelay jiffies и перезапустить себя.

А також:
	* Проверить работу. Для th_val и wrk_val желательно выбирать простые числа
	* Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies которые не привели к завершению первого и второго потоков соответственно. Получается связь "таймер – 1й список – 1й поток" и  "ворк – 2й список – 2й поток"
	* При выходе из потока распечатать список
	* Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию доступа к списку
	* Предусмотреть, что пользователь может выгрузить модуль досрочно

Хід роботи:
----------

При виконанні даної лабораторної роботи було застосовано таймери (timer whell), потоки і списки. Все це було вже використано при виконанні попередніх лабораторних робіт.Серед нових елементів, які були використані в даній лабораторній роботі, є workqueue. Workqueue, як і tasklet з поперездньої лабораторної, служать для відкладеної обробки данних, але, на відміну від tasklet'ів, вони виконуються в контексті потоку, і вони не є атомарними і тому можуть спати.

Тасклети завжди виконуються на процесорі, з якого вони були викликані. Робочі черги працюють так само, за замовчуванням, але цей момент може змінювати програміст.

Ще одною відміністю між ними полягає в тому, що тасклети виконуються *швидко, протягом короткого періоду часу і в атомарному режимі, в той час як функції робочої черги можуть мати більш високу затримку, але не повинні бути атомарними. У кожного механізму є ситуації, коли потрібно використовувати саме їх.

В підсумку варто перевести переваги workqueue над tasklet:
  * Мають гнучкий API (підтримується більше опцій / прапорів);
  * Призначені для більш високої затримки;
  * Можуть спати.

Результати тестування:
----------


.. code-block:: bash

/ # insmod /mnt/lab5.ko th_val=3 wrk_val=5 jffdelay=10
/ # rmmod lab5
[  107.111499] Exit jiffies is 4294774265
[  107.114350] Timer fail in jiff = 4294772532
[  107.114352] Queue fail in jiff = 4294772532
[  107.116843] Queue fail in jiff = 4294772543
[  107.118851] Queue fail in jiff = 4294772554
[  107.119856] lab5: exit
[  107.121259]


Висновки:
--------
При виконанні даної лабораторної роботи було створено модуль ядра для демонстрації роботи workqueue.
Також було вивчено сам workqueue.
