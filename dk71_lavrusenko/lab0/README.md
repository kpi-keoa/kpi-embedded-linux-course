
Лабораторна робота №0
====
Тема: Робота з потоками
====
Завдання:
===
  - Створити глобальну змінну, яка ініціалізується в 0;
  - Створити фунцію потоку, яка буде інкрементувати на K до значення N;
  - Запустити два потока з цією фунцією;
  - Дочекатися завершення, використовуючи метод `pthread_join()`;
  - Вивести в `stdout` очікуване та фактичне значення;
  - Створити `Makefile` використувуючи різні прапори оптимізації (`-O2/-O0`);
  - Додати до глобальної змінної `volatile `, зафіксувати зміни;

Хід роботи:
====

Для почтаку роботи підключаемо стандартні бібліотеки, для роботи з потоками потрібно підключити `<pthread.h>`.

Для отримання значень `K` та `N` будемо використовувати `argv[]`.

По-перше, потрібно перевірити, чи правильну кількість аругемнів було прийнято.

По-друге, потрібно виконати перетворення типів із `str` в `long`.

Створюэмо два потоки, передаємо їх в метод `pthread_join()`

Виводимо очікувальний та фактчиний результат.

Нижче представлено результат виконная програми:

![MarineGEO circle logo](/doc/table.png "Results")

Висновки:
===

В ході перевірки роботи програми при різних типах оптимізації, було виялено, що оптимізація `-O2` правильно оптимізує наший код, результати орботи програми співпадають із очікуальними. При оптимізації `-O0`, що по суті є відсутність оптимізації, було виявлено некоректні результати, що свідчить про конкурентність потоків.

Модифікатор `volatile` говорить про те, що ми будемо використовувати цю змінну різними потоками і вимагає від компілятора не розміщувати її для зберігання там, де ми не зможемо отримати до неї доступ. По суті в нас виникає "гонка даних", що нам і не дає отримати правильний результат. Для правильної роботи потоків, потрібно перевіряти, чи не використовують дані інші потоки, так як поток не знає, хто ще може використовувати.

Вирішення є використання  мютексів, атомарних операцій, але нажаль інкремент не є атомарною операцією. Також різні потоки зберігають результати виконання в кеші, а на різних ядрах різні кеші, що роблять дані невалідними. Крім того є варіант використовувати барьери доступу до памяті,
для забезпечення узгодженості та запобігання зміни черговості виконання.
