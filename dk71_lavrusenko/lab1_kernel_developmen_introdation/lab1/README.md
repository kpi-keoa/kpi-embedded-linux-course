
Лабораторна робота №1
====
Тема: Введення в розробку модулей ядра
====
Завдання:
===
  - Виконати задання приведені в методичних вказіваках;
  - Ознайомитися з функцією `printk`, ознайомитися із змінною `jiffers`;
  - Ознайомитися із макросами `__init__`, `__exit__`;
  - Змінити модуль `firstmod.c` із методичних вказівок, щоб замість $username, виводилось імя,
    передане в якості параметра модуля при його підключенні за допомогою `insmod`, а якщо параметр не заданий - використовувати той же $username за замовченням
    крім  того в лог-ядра, повинно виводитись запис рівнем логінгу WARNING, про тещо імя не задано.
    

Хід роботи:
====

Після повтору всіх етапів вказаних у методичних вказівках, було зроблено висновок, що пам'яті в 256М не достатньо для адекватної роботи ядра, тому було принято рішення збільшити пам'ять до 512М.


`printk`  - одна з найбільш широко відомих функцій ядра Linux. 
Це стандартний інструмент для друку повідомлень і, як правило, найпростіший спосіб відстеження і улагодження. По суті це все тей же `pritf`, який має функціональні відмінності.


`jiffies` - глобальна змінна, яка містить кількість тактів, що сталися з моменту завантаження системи. 
При завантаженні ядро ініціалізує змінну до нуля, і вона збільшується на одиницю при кожному перериванні таймера. 
Таким чином, оскільки є переривання таймера HZ в секунду, є HZ `jiffies` в секунду. Таким чином, час безвідмовної роботи системи становить jiffies / HZ секунд.

`__init, __exit` -  Макрос `__init` призводить до того, що функція init відкидається, а її пам'ять звільняється після завершення функції init для вбудованих драйверів, але не для завантажуваних модулів. Якщо ви думаєте про те, коли викликається функція init, це цілком логічно.
Існує також `__initdata`, який працює подібно до `__init`, але для змінних init, а не для функцій.
Макрос `__exit` викликає пропуск функції, коли модуль вбудований в ядро, і, як і `__exit`, не впливає на завантажувані модулі. Знову ж таки, якщо врахувати, коли запускається функція очищення, це має повний сенс; вбудовані драйвери не потребують функції очищення, тоді як завантажувані модулі - це потрібно.
Ці макроси визначені в `linux/init.h` і служать для звільнення пам'яті ядра. Коли ви завантажуєте своє ядро і бачите щось на кшталт Звільнення невикористаної пам'яті ядра: звільнено 236k, це якраз те, що звільняє ядро.

Для запуску модуля потрібно спочатку скомпілювати його:
`make KBUILDDIR="<KBuild directory>"`

Запускаємо ядро за допомогою QEMU:
`qemu-system-x86_64 -enable-kvm -m 512M -smp 4 -kernel "<bzImage path>" -initrd "<path BusyBox shell utilits .gz>" \
                    -append "console=ttyS0" -nographic \
                    -drive file=fat:rw:./<path to module>,format=raw,media=disk`
                    
Підготовчі дії:
`mkdir mnt`
`mount -t vfat /dev/sda1 /mnt`

Запуск модуля:
`insmode /mnt/<module_name.ko>`

Вигрузка модуля:
`rmmod <module_name>`

Висновки:
===

В ході виконання лабараторної роботи було розроблено простий модуль ядра. Було випробувано різні режими запуску (у вікні qemu або у власному термыналі)
Було отримано такі дані при вказуванны параметру:

```
/dev # insmod /mnt/lab_task.ko  mystring='sasha'
[ 1241.681599] Hello,  sasha!
[ 1241.682942] jiffies = 4295908844
```

Вимкнення модуля:
```
/dev # rmmod lab_task 
[ 2541.218317] Ave Kernel!
[ 2541.218317] time spent 1299 sec
```

Без параметрів:

```
/dev # insmod /mnt/lab_task.ko  
[ 2544.321542] Username was not entered into the command line
[ 2544.328790] Hello, $username!
[ 2544.328790] jiffies = 4297211489
```
Звернувши увагу на "логи ядра", які приведені вище, можна побачити вивід в "логи" виклик `_init` функції, та `_exit`, крім того, якщо не задані параметри при визові модуля, виводиться `KERNEL WARNING`. 

