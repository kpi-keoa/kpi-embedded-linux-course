==========================================================
**Лабораторна робота №1 Введення в розробку модулів ядра**
==========================================================

Завдання:
---------------

* Підротувати оточення для збірки ядра
* зібрати мінімальне ядро Linux
* зібрати мінімальний набір user-spae утиліт
* змінити модуль firstmod таким чином, щоб в нього можна було передавати аргумет у вигляди им'я     користувача. Також по звершенню роботи модуля він повинен повернути свій час роботи.
* зібрати перший модуль ядра та запустити його на зібраному ядрі

**Хід роботи**

Перед тим, як збирати ядро, було спершу встановлено наступні пакети:

* bsase-devel - група пакетів, які використовуються системами збірки ядра 
* qemu та qemu-arch-ex - емулятор, на якому запускається ядро (зазвичай він вже встановлений)
* bc та cpio потребуються системою збірки ядра

Встановлння необхідних пакетів виконується за наступною командою:

.. code-block:: bash

 sudo pacman -S base-devel qemu qemu-arch-extra bc cpio

Наступним чином було створено файл конфігурації лінукс ядра, його налагодження та сбірка. На
етапі збіркі було зібрано тільки ядро, модулі будуть збиратися окремо.

Збірка була зроблена за командою:

.. code-block:: bash

 make vmlinux -jN

Далі було створено юзер-спейс оточення busybox, яке необхідне для завантаження модулів до зібраного ранмше ядра. Збірка та завантаження busybox виконується за настуними командими:

.. code-block:: bash

 make -jN
 make -jN install

**Збірка та запуск першого модуля**

При розробці модулю ядра слід пам'ятати, що в них можна використовувати не всі стандартні функції мови С. Найчастіше при нписанні модулів використовують наступні функції:

``printk``  - одна з найбільш широко відомих функцій ядра Linux. По функціоналу дана функція майже нічим не відрізняється від ``printf``. Зазвичай дану функцію використовують для виводу информації чи при видлагодженні

``jiffies`` - глобальна змінна, яка містить в собі кількість тактів, що пройшли з моменту завантаження системи. 
При завантаженні вміст даної змінної рівний нулю, а при кожному перериванні таймера змінна інкрементується. 

``__init, __exit`` -  Макрос ``__init`` призводить до того, що функція init відкидається, а її пам'ять звільняється
після завершення функції init для вбудованих драйверів, але не для завантажуваних модулів. Існує також ``__initdata``, який працює подібно до ``__init``, 
але для змінних init, а не для функцій. 

Макрос __exit викликає пропуск функції, коли модуль вбудований в ядро, і, 
як і __exit, не впливає на завантажувані модулі. 

**Результат роботи створеного модуля**

Результат роботи модуля, без уведеного аргумента:

.. code-block:: bash

 / # insmod /mnt/firstmod.ko
 [   95.051717] firstmod: loading out-of-tree module taints kernel.
 [   95.080113] Username was not provided
 [   95.096382] Hello, $username!
 [   95.096382] jiffies = 4294762384
 [   95.133916] insmod (100) used greatest stack depth: 13568 bytes left
 / # rmmod firstmod
 [  185.375827] Long live the Kernel!
 [  185.375827] working time is 90 sec
 / # 

Результат роботи модуля з уведеним аргуметом:

.. code-block:: bash

 / # insmod /mnt/firstmod.ko name="Vitalii"
 [  268.447718] Hello, Vitalii!
 [  268.447718] jiffies = 4294935735
 / # lsmod
 firstmod 16384 0 - Live 0xffffffffc03da000 (O)
 / # 

**Використані бібліотеки**

* ``<linux/module.h>`` - потрібна для всіх модулів   
* ``<linux/moduleparam.h>`` - для використання макросів параметрів     
* ``<linux/kernel.h>`` - заголовки ядра    
* ``<linux/init.h>`` - використовується для ініціалізації та деініціалізації    
* ``<linux/jiffies.h>`` - лічильник

**Використані макроси та функції**


``MODULE_DESCRIPTION`` - макрос для опису модуля    

``MODULE_AUTHOR`` - автор модуля    

``MODULE_VERSION`` - версія модуля    

``MODULE_LICENSE`` - тип ліцензії  

``module_param`` - передача параметрів в модуль    

``MODULE_PARM_DESC`` - опис параметра

``printk`` - виведення інформації в лог ядра

``jiffies_delta_to_msecs`` - розрахунок проміжку часу.
    
Висновки:
-------------

В результаті виконання данної лабораторної роботи було зібрано лінукс ядро та модуль до нього. Для перевірки працездатності модуля, його разом із ядром було запущено у емуляторі qemu зі створеним юзер-спейсом busybox. В результаті завантаженя модуля було з'ясовано, що модуль працює оректно та вионує ті функції, які були поставлені у завднані до лабораторної роботи.