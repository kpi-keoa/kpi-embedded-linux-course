=================================================
**Лабораторна робота №0 Робота з потоками**
=================================================


**Завдання:**
~~~~~~~~~~~~~
Написати код в якому:

* Створити глобальну змінну та ініціалізувати її нулем;
* Створити функцію потоку,яка N разів додає до цієї змінної К - (в моєму випадку це 1);
* Запустити два потоки з цією функцією;
* Дочекатись завершення потоків використовуючи ``pthread_join()`` ;
* Вивести в ``stdout`` очікуване та фактичне значення глобальної змінної;

**Хід роботи:**
---------------
Для полегшення написання та відладки коду спочатку було вирішено створити MakeFile з рецептами для компіляції проекту та чистки артефактів

Особливістю написаного MakeFile є:

* змінна OPTFLAG (флаг оптимізації) - її ми можемо змінювати при запуску MakeFile. Це дозволить нам протестувати програму при різниї оптимізаціях;
* рецепт ``asm`` що дозволяє отримати асемблерний лістинг нашого коду;

Написаний код знаходиться в директорії ``src`` під назвою ``thread.c``.

Для роботи з потоками використовуємо біблотеку - ``pthread.h``

Ітерувати в потоці будемо змінну - ``global`` типу ``long``. Функція для ітерації має назву - ``thread_func``. Її ми будемо викликати в 
двох потоках. Код цієї функції:

.. code-block:: C

  void *thread_func(void *args)
  {
  	   long steps = *((long *)args);

	   for(int i = 0; i < steps; i++) {
	       global++;
	   }
  }

В функція ``main`` є дві змінні:

* ``steps`` - її ми ініціалізуємо аргументом командного рядку. Ця змінна використовується для визначення к-ті ітерацій;
* ``nthreads`` - константа що означає кількість створюваних потоків.

За допомогою функції ``pthread_create`` створються потоки
А функція ``pthread_join`` очікує їх завершення. Лістинг функції:

.. code-block:: C

	int main(int argc, char *argv[])
	{
		if(argc != 2) {
			fprintf(stderr, "It should be one arg\n");
			exit(EXIT_FAILURE);
		}

		long steps;
		assert(1 == sscanf(argv[1], "%ld", &steps));
		const int nthreads = 2;

		pthread_t *threads = calloc(nthreads,sizeof(*threads));

		for(long i = 0; i < nthreads; i++) {
			assert(!pthread_create(&threads[i], NULL, &thread_func, &steps));
		}

		for(long i = 0; i < nthreads; i++) {
			pthread_join(threads[i], NULL);
		}

		long after_thread = global;

		global = 0;		//to test normal result

		for(long i = 0; i < nthreads; i++) {
			thread_func(&steps);
		}
		printf("Expected: %ld, got: %ld, it is - %s\n", global, after_thread, (global == after_thread ? "OK" : "FAIL"));

		return 0;
	}

.. table:: Отримані результати

   +----------------------------------------------------------------------------------------------------+
   |                                      Результати                                                    |
   +------------------------+--------------------------+------------------------------------------------+
   | Оптимізація -О0        | Оптимізація -О2          | Оптимізація -О2 (global -> volatile)           |
   +------------------------+--------------------------+------------------------------------------------+
   | Результат              | Результат                | Результат                                      |
   +------------------------+--------------------------+------------------------------------------------+
   | 9955943                | 20000000                 | 11860273                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 12000504               | 20000000                 | 12000504                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 13142378               | 20000000                 | 13094729                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 13142378               | 20000000                 | 13461279                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 12586975               | 20000000                 | 13857363                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 13460147               | 20000000                 | 12257834                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 12008238               | 20000000                 | 12246232                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 12962007               | 20000000                 | 12423484                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 12809626               | 20000000                 | 11527433                                       |
   +------------------------+--------------------------+------------------------------------------------+
   | 11865717               | 20000000                 | 12564745                                       |
   +------------------------+--------------------------+------------------------------------------------+


Висновки
--------

Програма скомпільована з флагом -O2 при кожному запуску видає правильні результати за рахунок того, що код було оптимізовано. Замість того щоб
дійсно виконувати цикл та щоразу додавати 1, наш код додає до змінної число, що дорівнює ``steps``

Програма скомпільована з флагом -O0 при кожному запуску повертає неправильні результати. Це пов'язано з тим, що два потоки працюють конкурентно,
і оперують однаковими данними. 
Програма скомпільована з флагом -O2 та змінною ``global`` з ключовим словом ``volatile`` має аналогічні результати з програмою скомпільованою з -O2
так ``volatile`` забороняє оптимізацію дій з цією змінною.


Для того щоб програма виконувалась правильно необхідно використовувати наприклад: бар'єри пам'яті, спінлоки, м'ютекси тощо.

