=============================================
Лабораторна робота №2
=============================================

Тема
------

**Тасклети,таймери,аллокація пам'яті**

Завдання:
-------
Написати модуль ядра, який:
	* Приймає 2 параметри *cnt* і *delay*
		- *cnt* - кількість циклів, які повинен опрацювати таймер
		- *delay* - затримка між двома спрацюваннями таймера
		- Модуль повинен відпрацьовувати при *cnt* і *delay* рівних нулю
	* Спочатку *init* друкує поточне значення *jiffies* в лог ядра
	* Потім запускає тасклет, котрий повинен надрукувати своє значення *jiffies* в лог ядра
	* Потім виділяє масив розміру *cnt*, використовуючи динамічну алокацію
	* Потім *init* запускає таймер з затримкою *delay* і функція завершується
		- При спрацюванні таймер кладе поточне значення *jiffies* до масиву і перезапускається з затримкою *delay*
		- Загальна кількість разів, які запускається таймер дорівнює *cnt*
	* В *exit* модуль повинен надрукувати поточне значення *jiffies* і вивести всі значення з масиву

Хід роботи
-------

**Опис виконаної роботи**
В процесі виконання лабораторної роботи було вивчено методи алокації пам'яті в ядрі, таймери та їх API, тасклети.

Було написано модуль ядра за специфікацією.

Модуль приймає на вхід два параметри cnt - к-ть циклів та delay, введені данні перевіряються на коректність

Функція обробник тасклету `tasklet_kh(unsigned long arg)`, виводить значення *jiffies* на момент виклику тасклету.
Функція `jif_to_array` *cnt* разів записує до *array* значення *jiffies* .

Як вже було зауважено раніше в `init` функції данні перевіряються на правильність, також там виводиться *jiffies* при ініціалізації модулю. Крім того в ф-ції виділяється пам'ять для 
нашого масиву за допомогою kzalloc. В разі помилок модуль припиняє свою роботу повертаючи *-1*.

В `exit` ф-ї виводимо поточне значення *jiffies*, та виводимо заповнений массив, при тому враховуючи можливість того, що він не буде заповнений до кінця. Вивільняємо пам'ять


Результат:

.. code-block:: bash

	/ # insmod /mnt/khmod.ko
    [   44.609262] khmod: loading out-of-tree module taints kernel.
    [   44.622028] Initial Jiffies is 4294711945
    [   44.622709] Wrong cnt
    [   44.623339] Tasklet jiffies is 4294711947
    [   44.623997] Terminated
    insmod: can't insert '/mnt/khmod.ko': Operation not permitted
    [   44.662846] insmod (92) used greatest stack depth: 13928 bytes left
    / # insmod /mnt/khmod.ko cnt=10 delay=10
    [   58.329669] Initial Jiffies is 4294725653
    [   58.331023] Tasklet jiffies is 4294725655
    / # rmmod khmod
    [   89.769281] Exit jiffies is 4294757093
    [   89.770199] Array[0] = 4294725667
    [   89.771121] Array[1] = 4294725678
    [   89.771496] Array[2] = 4294725692
    [   89.772053] Array[3] = 4294725703
    [   89.772939] Array[4] = 4294725716
    [   89.773405] Array[5] = 4294725730
    [   89.773708] Array[6] = 4294725745
    [   89.774245] Array[7] = 4294725761
    [   89.774728] Array[8] = 4294725773
    [   89.774960] Array[9] = 4294725786
    / # insmod /mnt/khmod.ko cnt=1000 delay=10
    [  211.322516] Initial Jiffies is 4294878646
    [  211.323354] Tasklet jiffies is 4294878647
    / # rmmod khmod
    [  217.154167] Exit jiffies is 4294884478
    [  217.154523] Not passed
    [  217.154823] Array[0] = 4294878660
    [  217.155288] Array[1] = 4294878671
    [  217.155495] Array[2] = 4294878685


Висновки
-------
В ході роботи було розроблено власний модуль ядра та вивчено теоретичну частину.

	1. *jiffies*, яке друкується в *init* і яке виводить тасклет відрізняється, через те що ці операції відбуваються не одночасно.
	2. При виділенні пам'яті використовувався флаг `GFP_KERNEL` тому що`GFP_KERNEL` в кінцевому результаті викликає `__get_free_pages`. Функція виконує системний виклик від імені процеса. Використання `GFP_KERNEL` означає що `kmalloc` може помістити поточний процес в сон для очікування сторінки пам'яті в разі її відсутності.
	3. При *delay = 0* Таймер буде викликатися з мінімально допустимою затримкою.