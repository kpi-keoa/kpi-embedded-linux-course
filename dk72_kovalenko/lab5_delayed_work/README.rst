==========================================================
**Лабораторна робота №5. Workqueue**
==========================================================



**Завдання:**
~~~~~~~~~~~~~
 
* Написати та зібрати власний модуль ядра, який:
  
- принимает аргументы ``th_val``, ``wrk_val`` и ``jffdelay``, реализует два потока и ворк (в дефолтном work queue), а также таймер (на базе timer wheel)        
- Запускает таймер и ворк        
- При срабатывании таймера проверяет текущее значение ``jiffies``, если оно кратно ``th_val`` – остановить первый поток; иначе – таймер перезапускается через ``jffdelay`` jiffies        
- Внутри ворка проверяет текущее значение ``jiffies``, если оно кратно ``wrk_val`` – остановить второй поток; иначе – ворк должен уснуть на ``jffdelay`` jiffies и перезапустить себя.        
- Проверить работу. Для ``th_val`` и ``wrk_val`` желательно выбирать простые числа        
- Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies которые не привели к завершению первого и второго потоков соответственно. Получается связь "таймер – 1й список – 1й поток" и  "ворк – 2й список – 2й поток"        
- При выходе из потока распечатать список        
- Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию доступа к списку        
- Предусмотреть, что пользователь может выгрузить модуль досрочно        
    
    

**Хід роботи:**
~~~~~~~~~~~~~~~


**Використані бібліотеки**
--------------------------
    

* ``<linux/module.h>``				тут загальні макроси для модулів               	
* ``<linux/moduleparam.h>``			тут все для параметризації                    		
* ``<linux/kernel.h>``				тут заголовки ядра          	
* ``<linux/init.h>``				тут все для [де]ініціалізації          	
* ``<linux/jiffies.h>``				тут лічильник та допоміжні функції          	
* ``<linux/slab.h>``				тут і          	
* ``<linux/mm.h>``					тут засоби алокації пам'яті                 
* ``<linux/sched.h>``				тут плануівльник тредів       
* ``<linux/delay.h>``				тут затримки і функції сну       
* ``<linux/list.h>``				тут списки ядра       
* ``<linux/kthread.h>``				тут функції для роботи з тредами    
* ``<linux/workqueue.h>`` 			тут черги роботи


** Worqueue - Черги задач**
--------------------------

``#include <linux / workqueue.h> struct workqueue_struct; struct work_struct;`` - cтруктури, які є чергою завдань. 

``struct workqueue_struct * create_workqueue (const char * name); struct workqueue_struct * create_singlethread_workqueue (const char * name); void destroy_workqueue (struct workqueue_struct * queue);`` - функції для створення і знищення черг завдань. Виклик ``create_workqueue`` створює чергу з робочим потоком на кожному процесорі в системі; навпаки, ``create_singlethread_workqueue`` створює чергу завдань з одним робочим процесом. 

``DECLARE_WORK (name, void (* function) (void *), void * data); INIT_WORK (struct work_struct * work, void (* function) (void *), void * data); PREPARE_WORK (struct work_struct * work, void (* function) (void *), void * data);`` - макроси, які оголошують і ініціалізують записи черги завдань. 

``int queue_work (struct workqueue_struct * queue, struct work_struct * work); int queue_delayed_work (struct workqueue_struct * queue, struct work_struct * work, unsigned long delay);`` - функції, які послідовно працюють для запуску з черги завдань. 

``int cancel_delayed_work (struct work_struct * work); void flush_workqueue (struct workqueue_struct * queue);`` - для видалення запису з черги завдань; 

``flush_workqueue`` - гарантує, що ніякий із записів в черзі завдань не працює де-небудь в системі.

``int schedule_work (struct work_struct * work); int schedule_delayed_work (struct work_struct * work, unsigned long delay); void flush_scheduled_work (void);`` - функції для роботи із загальною чергою завдань.


Черги завдань (workqueue) поверхнево схожі на мікрозадачі; вони дозволяють коду ядра запросити, яка функція буде викликана в майбутньому. Є, однак, деякі суттєві відмінності між ними, в тому числі:

-Мікрозадачі працюють в контексті програмного переривання, в результаті чого весь код мікрозадачі повинен бути атомарним. Замість цього функції черзі завдань виконуються в контексті спеціального процесу ядра; в результаті чого вони мають більше гнучкості. Зокрема, ``функції в черзі завдань можуть спати``.

-Мікрозадачі завжди працюють на процесорі, який їх спочатку запланував. Черги завдань за замовчуванням працюють таким же чином.

-Код ядра може дати запит, щоб відкласти виконання функцій черзі завдань на заданий інтервал.

Ключовим відмінністю між ними двома є те, що мікрозадачі виконуються швидко, протягом короткого періоду часу і в атомарному режимі, а функції черзі завдань можуть мати більш високі затримки, але не повинні бути атомарними. Кожен механізм має ситуації, коли він доречний.

Черги завдань мають тип ``struct workqueue_struct``, яка визначена в ``<linux / workqueue.h>``. Черга завдань повинна бути явно створена перед використанням, використовуючи одну з двох наступних функцій:

``struct workqueue_struct * create_workqueue (const char * name);``

``struct workqueue_struct * create_singlethread_workqueue (const char * name);``

Кожна чергу завдань має один або більше спеціалізованих процесів ("потоки ядра"), які запускають функції, поміщені в чергу. Якщо ви використовуєте ``create_workqueue``, ви отримаєте чергу завдань, яка має спеціальний потік для кожного процесора в системі. У багатьох випадках всі ці потоки є просто зайвими; якщо одного робочого потоку буде досить, замість цього створіть чергу завдань за допомогою ``create_singlethread_workqueue``.


Щоб помістити завдання в чергу завдань, необхідно заповнити структуру ``work_struct``. Це можна зробити під час компіляції наступним чином:

``DECLARE_WORK (name, void (* function) (void *), void * data);``

Де ``name`` є ім'ям структури, яка повинна бути оголошена, ``function`` є функцією, яка буде викликатися з черги завдань, і ``data`` є значенням для передачі в цю функцію. Якщо необхідно створити структуру work_struct під час виконання, є наступні два макроси:

``INIT_WORK (struct work_struct * work, void (* function) (void *), void * data);``

``PREPARE_WORK (struct work_struct * work, void (* function) (void *), void * data);``

``INIT_WORK`` - робить більш серйозну роботу по ініціалізації структури, його треба використовувати його в перший раз при створенні структури. 

``PREPARE_WORK`` - робить майже таку ж роботу, але він не ініціалізує вказівники, які використовуються для підключення в чергу завдань структури ``work_struct``. Якщо є будь-яка можливість, що в даний час структура може бути поміщена в чергу завдань і ви повинні змінити цю структуру, то краще використовувати ``PREPARE_WORK`` замість ``INIT_WORK``.

Для приміщення роботи в чергу завдань Існують дві функції:

``int queue_work (struct workqueue_struct * queue, struct work_struct * work);``

``int queue_delayed_work (struct workqueue_struct * queue, struct work_struct * Work, unsigned long delay);``

Будь-яка з них додає work до даної черги. Однак, якщо використовується ``queue_delayed_work``, фактична робота не виконується, поки не пройде принаймні delay тіків. Значення, що повертається цих функцій є ненульовим, якщо ``work`` була успішно додана в чергу; нульовий результат означає, що ця структура ``work_struct`` вже чекає в черзі і не була додана вдруге.

В деякий час в майбутньому функція ``work`` буде викликана з заданим значенням ``data``. Ця функція буде працювати в контексті робочого потоку, тому він може заснути в разі необхідності, хоча ви повинні знати, як цей сон може вплинути на будь-які інші завдання, що знаходяться в тій же черзі завдань. Однак, така функція не може отримати доступ в призначений для користувача простір. Так як вона працює всередині потоку ядра і просто немає доступу в призначений для користувача простір.

Якщо необхідно скасувати очікуваний запис в черзі завдань, можна викликати:

``int cancel_delayed_work (struct work_struct * work);``

Значення, що повертається відмінне від нуля, якщо запис був скасований ще до початку виконання. Ядро гарантує, що виконання даного запису не буде розпочато після виклику ``cancel_delayed_work``. Однак, якщо ``cancel_delayed_work`` повертає 0, запис вже може працювати на іншому процесорі і може все ще бути запущений після виклику ``cancel_delayed_work``. Щоб мати абсолютну впевненість, що функція work не працює ніде в системі після того, як ``cancel_delayed_work`` повернула 0, необхідно потім зробити виклик:

``void flush_workqueue (struct workqueue_struct * queue);``

Після повернення flush_workqueue, ніяка з функцій, поміщених перед цим для виклику в чергу, більше ніде в системі не працює.

``void flush_scheduled_work (void);`` - функція очищення заданої черги робіт і використовується, щоб запобігти гоночним умовам. 

``void destroy_workqueue (struct workqueue_struct * queue);`` - функція, коли необхідно закінчити з чергою завдань і позбутися від неї.


Тест модуля при різних вхідних даних:   

.. code-block:: bash

    / # insmod /mnt/lab5.ko th_val=3 wrk_val=5 jffdelay=10
    [  163.089094] lab5: loading out-of-tree module taints kernel.
    [  163.099289] insmod (94) used greatest stack depth: 13928 bytes left
    / # rmmod lab5
    [  226.137238] Exit jiffies is 4294893340
    [  226.137618] Timer fail in jiff = 4294830300
    [  226.137776] Queue fail in jiff = 4294830301
    [  226.137955] Queue fail in jiff = 4294830312
    [  226.138109] Queue fail in jiff = 4294830323
    [  226.138250] Queue fail in jiff = 4294830334
    [  226.138396] lab5: exit
    [  226.138624] Ave Kernel!
    
    / # insmod /mnt/lab5.ko th_val=3 wrk_val=4 jffdelay=6
    / # rmmod lab5
    [ 4081.316561] Exit jiffies is 4298748519
    [ 4081.316980] Timer fail in jiff = 3777867
    [ 4081.317032] Queue fail in jiff = 3777867
    [ 4081.317209] Queue fail in jiff = 3777874
    [ 4081.317354] Queue fail in jiff = 3777881
    [ 4081.317508] lab5: exit
    [ 4081.317843] Ave Kernel!

    / # insmod /mnt/lab5.ko th_val=3 wrk_val=7 jffdelay=4
    / # rmmod lab5
    [ 4169.263976] Exit jiffies is 4298836467
    [ 4169.264299] Timer fail in jiff = 3866965
    [ 4169.264353] Queue fail in jiff = 3866966
    [ 4169.264574] lab5: exit
    [ 4169.265179] Ave Kernel!

    / # insmod /mnt/lab5.ko th_val=2 wrk_val=6 jffdelay=4
    / # rmmod lab5
    [ 4323.647090] Exit jiffies is 4298990850
    [ 4323.647262] Timer fail in jiff = 4021575
    [ 4323.647288] Queue fail in jiff = 4021576
    [ 4323.647383] Queue fail in jiff = 4021581
    [ 4323.647470] lab5: exit
    [ 4323.647613] Ave Kernel!

    / # insmod /mnt/lab5.ko th_val=4 wrk_val=6 jffdelay=4
    / # rmmod lab5
    [ 4436.444350] Exit jiffies is 4299103647
    [ 4436.444606] Timer fail in jiff = 4134851
    [ 4436.444733] Queue fail in jiff = 4134853
    [ 4436.444899] Queue fail in jiff = 4134858
    [ 4436.445054] Queue fail in jiff = 4134863
    [ 4436.445192] Queue fail in jiff = 4134868
    [ 4436.445332] Queue fail in jiff = 4134873
    [ 4436.445491] lab5: exit
    [ 4436.445843] Ave Kernel!

    / # insmod /mnt/lab5.ko th_val=5 wrk_val=6 jffdelay=7
    / # rmmod lab5
    [ 4633.314130] Exit jiffies is 4299300517
    [ 4633.314442] Timer fail in jiff = 4331497
    [ 4633.314496] lab5: exit
    [ 4633.314905] Ave Kernel!

    
У ході виконання лабораторної роботи були використані наступні джерела:
[1](http://dmilvdv.narod.ru/Translate/LDD3/Linux_Device_Drivers_3_ru.pdf), [2](https://www.doc-developpement-durable.org/file/Projets-informatiques/cours-&-manuels-informatiques/Linux/Linux%20Kernel%20Development,%203rd%20Edition.pdf), [3](https://elixir.bootlin.com/).



Висновки
~~~~~~~~

Було зібрано свій модуль ядра, що відповідає завданню та перевірено його працездатність. В ході виконання даної лабораторної роботи, було зібрано модуль ядра, який запускає таймер і ворк. Для спрощення виконання було використано флаги, які допомогли виконати роботу правильно. Workqueue служить для відкладеної обробки данних, є неатомарним, тому і може засипати. Якщо є завдання виконання великого обсягу роботи - доцільно використовувати workqueue. Як тільки функція буде додана в чергу, вона відпрацює лиш тоді, коли до цієї функції дійде черга у контексті обробки ядра. Також workqueue можна порівняти з tasklets, але другі дещо гірші. Workqueue має більше підтримуваних опцій, більш обширна, призначена для більш високої затримки.
