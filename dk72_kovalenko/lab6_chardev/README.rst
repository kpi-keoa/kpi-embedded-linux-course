=============================================
Лабораторна робота №6
=============================================

Тема
------

**Символьні пристрої**

Завдання:
-------
Напишите свое символьное устройство с ioctl. Оно должно делать что-то полезное. Например, предоставлять шареную память, или генерировать что-то, или рассчитывать. Например, считать количество вхождений определённого символа или сортировать строки или считать интеграл или ...

Хід роботи
-------

**Опис виконаної роботи** 
В ході роботи було написано модуль ядра мовою С.

Модуль генерує пароль довжиною *pass_length* шляхом запису у кожну комірку паролю випадкового символа(обирається із чотирьох типів: цифри, великі літери, малі літери та спеціальні символи). Також наявний параметр *spec_sym_en* який дає дозвіл на використання спеціальних символів(визначено у масиві *SPEC_SYM_ARRAY*) під час генерації паролю.

*Символьні пристрої*

Символьний пристрій - це такий пристрій, до якого можна звертатися як до потоку байтів (так само як до файлу); драйвер символьного пристрою відповідає за реалізацію такої поведінки. Такий драйвер зазвичай підтримує системні виклики open, close, read і write. 

*Major & minor*

Для реєстрації пристрою потрібно задати спеціальні номери, а саме ``major`` та ``minor``. Ці цифри являються старшим та молодшим номером пристрою для кожного з них. Традиційно, старший номер ідентифікує драйвер, асоційований з пристроєм. Наприклад ``/dev/null`` і ``/dev/zero`` керуються драйвером 1, тоді як віртуальні консолі і послідовні термінали керуються драйвером 4. Сучасні ядра Linux дозволяють декільком драйверам мати однакові старші номери, але більшість пристроїв організовані по принципу один старший номер - один драйвер. молодший номер використовується ядром, для того щоб точно визначити пристрій, про який йде мова.

Major номер для пристрою можна задати двома шляхами автоматично та вручну. Для ручного методу потрібно потрібно задати значення для параметра *major*, якщо залишити значення за замовчуванням, або задати його рівним "0", тоді модуль "попросить" ядро виділити для нього Major номер.

*register_chrdev_region & unregister_chrdev_region*

Одним з перших кроків, який необхідно зробити вашому драйверу при установці символьного пристрою, є отримання одного або декількох номерів пристроїв для роботи з ними. Необхідною функцією для виконання цього завдання є ``register_chrdev_region``, яка оголошена в ``<linux / fs.h>``:
``int register_chrdev_region (dev_t first, unsigned int count, char * name)``;
Тут ``first`` - це початок діапазону номерів пристроїв, який ви хотіли б виділити. Молодше число ``first`` часто 0, але не існує жодних вимог з цього приводу. ``count`` - запитувана загальне число суміжних номерів пристроїв. Зауважимо, що якщо число ``count`` велике, запитуваний діапазон може перекинутися на наступній старший номер, але все буде працювати правильно, якщо запитуваний діапазон чисел доступний. Нарешті, ``name`` - це ім'я пристрою, який повинен бути пов'язане з цим діапазоном чисел; воно буде відображатися в ``/ proc / devices і sysfs``.
Як і в більшості функцій ядра, яке значення ``register_chrdev_region`` буде 0, якщо виділення була успішно виконано. У разі помилки буде повернений негативний код помилки і ви не отримаєте доступ до запитуваного місця. ``register_chrdev_region`` працює добре, якщо ви знаєте заздалегідь, які саме номери пристроїв ви хочете. Однак, часто ви не будете знати, які старші номера пристроїв будуть використовуватися; є постійні зусилля в рамках спільноти розробників ядра Linux перейти до використання динамічно виділяються номерів пристроїв. Ядро буде щасливо виділити старший номер для вас "на льоту", але ви повинні запитувати цей розподіл, використовуючи іншу функцію:
``int alloc_chrdev_region (dev_t * dev, unsigned int firstminor, unsigned int count, char * name)``;
У цій функції dev є тільки вихідним значенням, яке при успішному завершенні містить перший номер виділеного діапазону. ``firstminor`` повинен мати значення першого молодшого номера для використання; як правило, 0. Параметри count та name аналогічні ``register_chrdev_region``.
Незалежно від того, як ви призначили номера пристроїв, ви повинні звільнити їх, коли вони більше не використовуються. Номери пристроїв звільняються функцією:
``void unregister_chrdev_region (dev_t first, unsigned int count);``
Звичайне місце для виклику ``unregister_chrdev_region`` буде в функції очищення вашого модуля.

*Опис ioctl*

``#include <linux / ioctl.h>`` - оголошує все макроси, які використовуються для визначення команд ``ioctl``. В даний час він підключається за допомогою ``<linux / fs.h>``.

``_IOC_NRBITS _IOC_TYPEBITS _IO C_SIZEBITS _IOC_DIRBITS`` - число біт, доступне для різних бітових полів команд ``ioctl``. Є також ще чотири макросу, які визначають MASK і чотири, що визначають ``SHIFTbi``, але вони в основному для внутрішнього користування. ``_IOC_SIZEBITS`` є важливим значенням для перевірки, так як воно змінюється в залежності від архітектури.

``_IOC_NONE``
``_IOC_READ``
``_IOC_WRITE``
- можливі значення бітового поля "напрямок". "Читання" і "Запис" є різними бітами і можуть бути складені командою ``OR (АБО)`` для вказівки читання/запису. Значення базуються на 0.

``_IOC (dir, type, nr, size)``
``_IO (type, nr)``
``_IO R (type, nr, size)``
``_IOW (type, nr, size)``
``_IOWR (type, nr, size)``
- макроси, використовувані для створення команд ioctl _IOC_DIR (nr)

``_IOC_TYPE (nr)``
``_IOC_NR (nr)``
``_IOC_SIZE (nr)``
- макроси, які використовуються для декодування команд. Зокрема, ``_IOC_TYPE (nr)`` є комбінацією по АБО для ``_IOC_READ`` і ``_IOC_WRITE``.

Було створено наступні call_back функції для пристрою:
	- cdev_open (в ній відкривається файл і до поля *private data* заносяться параметри пароля)
	- cdev_release (в ній просто звільняється місце, що займало *private data* і закривається файл)
	- cdev_read (в ній генерується пароль і записується до *__user *buf*)
	- cdev_ioctl (ця функція дозволяє змінити довжину пароля, а також змінити значення прапорця *spec sym en*)

Всі ці функції було також передано до *struct file_operations pass_gen_fops*.

В *init_callback* функції лише перевіряються введені параметри на корректність, реєструється пристрій і виводяться до терміналу значення параметрів, з якими запущено модуль.

В *exit_callback* функції видаляємо пристрій І завершаємо роботу модуля.


Тест модуля при різних вхідних даних:   

.. code-block:: bash

    / # insmod mnt/lab6.ko
    [   79.105441] lab6: loading out-of-tree module taints kernel.
    [   79.112716] Registered device with 248:0
    [   79.112946] Length of password is 5
    [   79.113067] Spec symbols is disabled
    [   79.114790] insmod (95) used greatest stack depth: 13720 bytes left
    / # cd /dev
    /dev # mknod cdev c 248 0
    /dev # cd /
    / # dd if=/dev/cdev of=/test bs=10 count=1
    [  166.657790] New file entry (____ptrval____) created
    [  166.659133] File close ((____ptrval____))
    0+1 records in
    0+1 records out
    5 bytes (5B) copied, 0.002193 seconds, 2.2KB/s
    / # 


    
У ході виконання лабораторної роботи були використані наступні джерела:

[1](http://dmilvdv.narod.ru/Translate/LDD3/Linux_Device_Drivers_3_ru.pdf),

[2](https://www.doc-developpement-durable.org/file/Projets-informatiques/cours-&-manuels-informatiques/Linux/Linux%20Kernel%20Development,%203rd%20Edition.pdf),

[3](https://elixir.bootlin.com/).



Висновки
~~~~~~~~

В ході роботи я познайомився з символьними пристроями. Було зібрано свій модуль ядра, який реалізовує символьний пристрій, який за запитом генерує пароль із заданими параметрами. Із параметрів можна задавати лише довжину паролю та давати дозвіл на використання спеціальних символів у паролі. Ці 2 параметра задаються при завантаженні модуля, але можуть бути змінені за допомогою релізованого *ioctl*.
