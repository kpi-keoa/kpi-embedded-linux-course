=================================================
**Лабораторна робота №1 засоби відкладеної роботи: тасклети таймери**
=================================================

Завдання
---------------------------------------------------------

* ознайомитись з зазначеною документацією
* на основі отриманих знань створити модуль  ядра що приймати 2 параметри з командної строки cnt та delay. При запуску init модуль повинен вивести поточне значення jiffies, потім потрібно запустити тасклет 
що зробить те саме. Далі потрібно запустити таймер що повторно запуститься cnt разів із затримкою delay 

Хід роботи
----------------------------------------------------------

**Написання модуля ядра**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Згідно з отриманим завданням було створено модуль ядра що приймає cnt та delay. Цим параметрам було завше задано значення ``NULL`` щоб позначити що їх значення ще не було задано
далі була створена функція тасклету що виконує поставлену в завданні задачу, по перериванню таймера виконується функція що рекурсивно перезапускає таймер змінюючи значення ``expiers`` поля структури 
при цьому перевіряє кількість запусків лічильника при досьягненні значення cnt лічильник престає модифікуватись. В exit функції з початку відбувається припинення роботи тасклету функцією ``tasklet_kill()`` тому що при використанні цієї функції під час відпрацювання ``tasklet_handler``-у його виконання не переривається 
а доводитсься до кінця, ``tasklet_kill()`` просто забороняє подальший ``scheduling`` цього тасклету. Для деалокації було викликано функцію ``kfree()`` яка звільнює пам'ять виділену раніше за допомогою ``kzalloc()``.
результат роботи модуля:

.. code-block:: bash

 / # insmod mnt/mymod.ko 
 [   68.812208] mymod: loading out-of-tree module taints kernel.
 [   68.841532] Invalid cnt value has to be(unsigned)cnt > 0
 insmod: can't insert 'mnt/mymod.ko': invalid parameter
 [   68.866237] insmod (99) used greatest stack depth: 13696 bytes left
 / # insmod mnt/mymod.ko cnt=10 delay=5
 [  102.881771] Init>> jiffies is 4294770209
 [  102.882619] tasklet>> jiffies = 4294770210
 / # lsmod
 mymod 16384 0 - Live 0xffffffffc03b9000 (O)
 / # rmmod mymod
 [  134.912584] exit>> tim_cnt 10
 [  134.912584] exit>> countrer number 0 has the 4294770217 jiffies val
 [  134.913821] exit>> countrer number 1 has the 4294770223 jiffies val
 [  134.914597] exit>> countrer number 2 has the 4294770232 jiffies val
 [  134.915331] exit>> countrer number 3 has the 4294770238 jiffies val
 [  134.916079] exit>> countrer number 4 has the 4294770245 jiffies val
 [  134.916778] exit>> countrer number 5 has the 4294770251 jiffies val
 [  134.917492] exit>> countrer number 6 has the 4294770258 jiffies val
 [  134.918191] exit>> countrer number 7 has the 4294770264 jiffies val
 [  134.918922] exit>> countrer number 8 has the 4294770270 jiffies val
 [  134.919457] exit>> countrer number 9 has the 4294770277 jiffies val
 [  134.920226] exit>> dealoc: array is deallocated
 [  134.920925] exit>> god save the Kernel!; jiffies = 4294802249
 
Сочатку було запущено модуль без вхідних параметрів, модуль відреагував на це відповідним чином, вказавши що параметер не задано та не запустившись указуючи на те що 
відсутні вхідні параметри. Запускаємо модуль ще раз тільки вже з параметрами в лог ядра виводиться значення jiffies з хендлера тасклету та з init функції при завершенні 
роботи модулю в лог відображаються всі значення таймеру які було занесено до масиву, відображається деалокація масиву та виводиться значення jiffies в кінці роботи.

Висновки
------------
в результаті роботи було створено свій модуль ядра, роботу та структуру якого описано вище, Jiffies в init та tasklet відрізняються,
тому що від початку ініціалізації і до ``botom half`` де і запускається хендлер тасклету проходить певний час,  GFP_KERNEL використовується через те 
що ми алокуємо пам'ять в процесі а не в скедюлері тобто можемо дати можливість процесу спати чекаючи звільнення простору для алокації пам'яті. використання даного флагу
при алокації пам'яті в скедюлері може призвести до дедлоку. При delay рівним нулю таймер буде
відпрацьовувати з мінімальною затримкою, зазвичай це 1 такт.
