Звіт з виконання лабороторної роботи №3
=============================================

**У даній лабораторній роботі було виконано наступні задачі:**


Написано найпростіший модуль ядра який:

* запускає на одночасне виконання M потоків 
* кожен поток інкрементує глобальну змінну N разів, після чого кладе поточне значення змінної до спику
* під час вилучення модуль виводить значення глобальної змінної, та значення елементів списку
* для задання значень N та M використано параметри модуля, яки передаються при підключенні модуля
* для пам'ять виділяється динамічно
* помилки при виділенні пам'яті перевіряються та оброблюються
* реалізовано функції ``lock()`` та ``unlock()`` за допомогою бібліотеки ``asm/atomic.h``
* за допомогою даних функцій було синхронізовано роботу двох потоків, та виконано захист спільного блоку пам'яті в якому зберігається глобальна змінна

Програмний лістинг можна переглянути у наступному файлі `firstmod.c <https://github.com/AlexOstrianko/kpi-embedded-linux-course/blob/master/dk62_ostrianko/lab3_kernel_threads/src/firstmod.c>`__

**Хід роботи:**
========
1. Створення M потоків
------------

Для початку необхідно виділити пам'ять під таблицю вказівників на подальші потоки.

.. code-block:: c
 
  struct task_struct **threads_pointer;
  threads_pointer = (struct task_struct **)kmalloc(sizeof(struct task_struct *) * number_of_threads, GFP_KERNEL);	

Після чого можна ініціалізувати потоки та прив'язувати до них вказівники.

.. code-block:: c
 
	for(i = 0; i < number_of_threads; i++){
		threads_pointer[i] = kthread_run(thread_function, (void *)count, 
			"thread_%d", i);
	}

Таким чином створюється така кількість потоків, яка зазначенна як ``number_of_threads``.

2. Інкрементація змінної. Потокова функція
---------

.. code-block:: c
 
	int i;
	for(i = 0; i < number_of_cycles; i++){
		lock(lock_key);	  	//ucomment if necessary
		*(int *)data = *(int *)data + 1;
		unlock(lock_key);	//uncomment if necessary
		schedule();
	}
  
Даний фрагмент коду інкрементує змінну яка передаеться в потокову функцію як вказівник 
``void *data`` таку кількість раз, 
скільки вказано в змінній ``number_of_cycles``. Для того щоб працювати з глобальною 
змінною яка має тип ``int``, вказівник необхідно інтерпритувати (кастувати) як вказівник на ціле ``(int *)data``, та розіменувати 
за допомогою зірочки для доступу до змінною по вказівнику ``*(int *)data``. 

Використання та опис фукцій ``lock()`` та ``unlock()`` розглянуто в наступному пункті.

3. Функціі ``lock()`` та ``unlock()``
--------

Функціі ``lock()`` та ``unlock()`` в минулому пункті були використані для того щоб "захистити" доступ до спільної для всіх потоків 
змінної ``count``.

Для того щоб зрозуміти як відбувається захист необхідно розглянути зміст функцій.

Для початку розглянемо вміст функції ``lock()``:

.. code-block:: c
 
  static void lock(atomic_t *arg){
    while(arch_atomic_xchg(arg, 1)){
      schedule(); 	
     }
  }

Дана функція в циклі виконує переключення черги виконання на наступний потік (процесс) за допомогою функції ``schedule()``. В умові 
циклу виконується атомарна команда ``arch_atomic_xchg(arg, 1)``, яка змінює значення ``arg`` на ``1``, та повертає поточне значення 
``arg``. Тобто якщо в ``arg`` на даний момент зберігаєтсья нуль, дана перевірка не виконається, в цикл ми не потрапимо, проте в 
змінну ``arg`` буде записано ``1``. Якщо після цього паралельний потік буде перевіряти дану умову, він потрапить у цикл, адже умова 
наразі виконається, бо функція ``arch_atomic_xchg(arg, 1)`` поверне ``1``. Запис одиниці у 
глобальну змінну яка зберігає поточний стан локу можна назвати "взяттям ключа". Адже всі наступні потоки які будуть намагатися 
"взяти ключ" будуть замкнуті у нескінченному циклі (loked), та будуть передавати свої права на виконання іншим потокам.

Та все ж таки для того щоб повернути даний "ключ" на місце існує наступна функція:

.. code-block:: c
 
  static void unlock(atomic_t *arg){
    arch_atomic_set(arg, 0);
  }

Дана функція за допомогою атомарної команди ``arch_atomic_set(arg, 0)`` встановлює значення ``arg`` в нуль. Іншими словами повертає
"ключ" на місце. Таким чином наступний потік, який перший встигде "взяти ключа" вже не потрапить у нескінченний цикл, та зможе виконувати 
свій код без втручання інших потоків.

Вище декілька разів було сказано про "атомарні" операції, та все ж таки, що це таке?

Атомарні операції (atomic operations) - це операції які виконуються атомарно, тобто не перериваючись. Іншими словами ніхто не зможе 
втрутитися у виконання даної операції, адже вона виконується одразу.

Засоби виконання атомарних операцій з цілими числами працюють з типом даних ``atomic_t``, це гарантує що компілятор помилково не оптимізує 
ділянки коду з атомарними операціями, та крім того тільки атомарні функції приймають даний тип даних як аргумет.

4. Списки
------

Для того щоб не створювати структури двозв'язного списку самотужки, не ініціалізувати дані та не гратися з вказівниками наразі 
у всіх підсистемах ядра використовується офіційна реалізація. Код роботи зі зв'язаними списками визначено у файлі <linux / list.h>.

Для того щоб скористатися можливостями даної бібліотеки, необхидно всього лишень добавиви елемент структури ``struct list_head`` 
до своєї структури даних. А далі можна користуватися функціями для роботи зі списком.

Структура даних:

.. code-block:: c
 
  typedef struct struct_for_saving_results_n {
    struct list_head list;
    int num;
  }struct_for_saving_results;

Для роботи зі списками необхідно ініціалізувати список:

.. code-block:: c
 
	INIT_LIST_HEAD(&main_struct.list);

Для того щоб додати елемент до списка необхідно використати наступну функцію:

.. code-block:: c
 
 list_add(&struct_pointer->list, &main_struct.list);

,де ``&struct_pointer->list`` - елемент який необхідно додати до списка, ``&main_struct.list`` - список.

Далі можна використовувати функції для взаємодії зі списками:

.. code-block:: c
 
 list_for_each_safe(head_pointer, temp, &(main_struct.list)){
 /*виконуваний код*/
 }

Дана фрагмент коду являе собою аналог циклу ``for(;;)`` тільки для списків. Як видно з назви, даний цикл проходить по всім 
елементам списка. Приставка ``_safe`` означає що даний макрос використовує тимчасові змінні, щоб зробити проходження списком 
беспечнішим. Зазвичай така конструкція використовується для видалення списку.

та

.. code-block:: c
 
 struct_pointer = list_entry(head_pointer, struct_for_saving_results, list);

Макрос ``list_entry()`` повертає структуру даних, яка містить відповідний елемент ``list_head``. Цей макрос приймає три параметри: 
вказівний на поточний вузол, тип структури даних, в яку включений вузол списку, та ім'я поля структури даних, в якій 
зберігається цей вузол.

Які зазвичай використовуються в парі. 

Приклад видалення списку:

.. code-block:: c
 
 list_for_each_safe(head_pointer, temp, &(main_struct.list)){
		struct_pointer = list_entry(head_pointer, 
			struct_for_saving_results, list);
		printk(KERN_NOTICE "Deleting list element #%d!\n",
			struct_pointer->num);
		list_del(head_pointer);
		kfree(struct_pointer);		
	}

У даному прикладі вказівник ``head_pointer`` по черзі вказує на на кожен вузол списку, а вказівник ``struct_pointer`` на кожну структуру, 
що мистить елемент даного списоку.

Таким чином ми можемо видаляти вузли списку за допомогою функції ``list_del(head_pointer)``, та чистити пам'ять зарезервовано під структуру 
за допомогою ``kfree(struct_pointer)``.

Рузультат роботи:
=======

На результат роботи програми без синхронізації можна подивидись на рис. нижче:

   .. image:: img/kthreads_without_lock.png
   
На результат роботи програми з синхронізацією на рис. нижче:

   .. image:: img/kthreads_with_lock.png

Виходячи с рисунків можна зробити висновок, що без синхронізації потоків, виникає ефект "гонок" та боротьби за право доступу до спільної 
області пам'яті. Тому кінцевий результат не є вірним. У той час як синхронізовані потоки мають індивідуальний доступ до змінної, по черзі.
Тому результат є вірним.

