Звіт з виконання лабороторної роботи №4
=============================================

**У даній лабораторній роботі було виконано наступні задачі:**

* Вивчити особливості роботи таймерів і workqueue
* Реалізувати два потоки, запустити таймер і ворк в shared workqueue
* При спрацьовуванні таймера перевірити поточне значення jiffies, якщо воно кратно 11 - зупинити потік 1, інакше - таймер повинен перезапустити себе через 17 jiffies
* Усередині ворку перевірити поточне значення jiffies, якщо воно кратно 11 - зупинити потік 2, інакше - ворк повинен заснути на 17 jiffies і перезапустити себе
* Додати два зв'язих списки, в які аллоціювати та додавати елементи зі значеннями jiffies, які не привели до завершення потоків 1 і 2. Виходить зв'язок таймер - список 1 - потік 1. І ворк - список 2 - потік 2
* При виході з потоків роздруковувати списки
* Усередині ворку і таймера використовувати правильні аллокації для нових елементів списку, правильну синхронізацію роботи зі списком
* Передбачити, що користувач може вивантажити модуль до відпрацювання всіх таймерів і ворків

Програмний лістинг можна переглянути у наступному файлі `firstmod.c <https://github.com/AlexOstrianko/kpi-embedded-linux-course/blob/master/dk62_ostrianko/lab4_delayed_work/src/firstmod.c>`__

**Хід роботи:**
========

1. Таймер
------------

Особливим видом відкладених робіт, якими дуже часто користуються, є таймери. Вони визначаються за структурою ``timer_list``. 
Працюють у контексті переривання та реалізуються у верхній частині ``softirq``.

Щоб використовувати, таймер потрібно його спочатку ініціалізувати, викликавши ``timer_setup()``.

.. code-block:: c
 
	timer_setup(&timer, &timer_func, 0);

Дана функція ініціалізує внутрішні поля структури ``timer`` та асоціює функцію ``timer_func`` як обробник таймера.

Планування таймера виконується за допомогою ``mod_timer()``.

.. code-block:: c
 
	mod_timer(&timer, jiffies + msecs_to_jiffies(110));

Де ``jiffies + msecs_to_jiffies(110)`` - це час (в майбутньому) для запуску функції обробника. Функцію можна використовувати для перезапуску таймеру.

Одиниця часу для таймера зазначена у jiffies. Абсолютне значення jiffies залежить від платформи, і його можна знайти за допомогою макросу HZ, 
який визначає кількість тіків лічильника jiffies за 1 секунду.

Щоб зупинити таймер, використовуеться ``del_timer_sync()``.

.. code-block:: c
 
	del_timer_sync(&timer);

Дана функція використовується для усунення перегонів, які можуть виникнути в багатопроцесорних системах, оскільки по поверненню з функції 
гарантується, що функція обробки таймера більне не працює на жодному процесорі.

2. Workqueues
-----------------

Workqueues використовуються для планування дій, які потрібно виконати в контексті процесу. Базова одиниця, 
з якою вони працюють, називається work. Існує два типи work:

* struct work_struct - планує виконати завдання
* struct delaned_work - планує виконання завдання після заданого інтервалу часу

``struct delaned_work`` використовує таймер для запуску після зазначеного інтервалу часу. Виклики з цим типом схожі на виклики 
для ``struct work_struct``, але мають ``_delayed``  в назвах функцій.

Перед використанням структури необхідно ініціалізувати. Для цього є два задекларованих макроси.

.. code-block:: c
 
  DECLARE_WORK(name , void (*function)(struct work_struct *));
  DECLARE_DELAYED_WORK(name, void(*function)(struct work_struct *));

  INIT_WORK(struct work_struct *work, void(*function)(struct work_struct *));
  INIT_DELAYED_WORK(struct delayed_work *work, void(*function)(struct work_struct *));

``DECLARE_WORK()`` та ``DECLARE_DELAYED_WORK()`` декларують та ініціалізують елемент ``work``, у той час як 
``INIT_WORK()`` та ``INIT_DELAYED_WORK()`` ініціалізують вже задеклорований елемент ``work``.

Після оголошення та ініціалізації ми можемо запланувати ``work`` за допомогою ``schedule_work()`` та ``schedule_delayed_work()``.

.. code-block:: c
 
  schedule_work(struct work_struct *work);
  
  schedule_delayed_work(struct delayed_work *work, unsigned long delay);

``schedule_delayed_work()`` можна використовувати для планування елемента ``work`` з заданою затримкою. Одиниця виміру 
часу затримки - ``jiffies``.

Елементи ``work`` не можна замаскувати, але їх можна скасувати, за допомогою  ``cancel_delayed_work_sync()`` або ``cancel_work_sync()``.

.. code-block:: c
 
  int cancel_work_sync(struct delayed_work *work);

  int cancel_delayed_work_sync(struct delayed_work *work);

Виклик зупиняє лише подальше виконання елемента ``work``. Якщо елемент ``work`` вже запущений під час виклику, 
він продовжуватиме працювати. У будь-якому випадку, після повернення, гарантується, що ``work`` більше не буде виконуватися.

Ми можемо чекати, поки ``work`` буде виконано викликавши ``flush_delayed_work()``.

.. code-block:: c
 
 bool flush_delayed_work (struct delayed_work * work);

Таймер із затримкою скасовується, а запланований ``work`` встановлюється на негайне виконання. 

Реалізація
==================


Синхронізація
-------

Річ на яку треба звернути увагу у даному модулі - це синхронізація таймеру на відповідного йому потоку.

Чому саме таймера? Томущо обробник таймера на відміну від work-а виконується у контексті переривання, тому скористатися вже існуючою 
функцією ``kthread_stop()`` не є можливим.

Саме через це було вирішено скористатися "флагами". Для цього було створено відповідну структуру.

.. code-block:: c
 
  struct flags_str {
    bool first_thr_run;
    bool second_thr_run;
    bool timer_run;
    bool work_run;
  };

Дана структура містит чотири флага:

* ``first_thr_run`` - флаг, що індикує про роботу першого потоку;
* ``second_thr_run`` - флаг, що індикує про роботу другого потоку;
* ``timer_run`` - флаг, що індикує про роботу таймера;
* ``work_run`` - флаг, що індикує про роботу ворка;

Перші два флаги можушь спровокувати потоки на вихід з нескінченного циклу, у той час як наступні два використовуються для зручності 
подальшого вилучення модулю.


Потокові функції
----------

По своїй суті обидві потокові функції виконують однакові дії, але для різних списків. Це можна було описати однією функцією, проте 
це приведе до збільшення вкладеності, та поскладнення коду через зайві ``if-else`` блоки. Тому було вирішено створити дві окремі функції.

Для прикладу розглянемо одну з них.

.. code-block:: c
 
  int first_th_func(void *data)
  {	
    while (flags.first_thr_run) {
      schedule();
    }

    struct struct_for_saving_results *f_tmp_st_p = NULL;

    list_for_each_entry(f_tmp_st_p, &(first_res_list.list), list) {
      printk(KERN_NOTICE "Timer list element #%li!\n",
        f_tmp_st_p->num);
    }

    do_exit(0);
  }

Ось де добре видно використання флагу ``first_thr_run``. Даний флаг "крутить" нескінченний цикл ``while`` який в свою чергу передає 
права на виконання іншим процессам. Це зроблено для того, щоб затримати подальше виконання потокової функції, поки не прийшов час.

Після виходу з циклу, функція виводить список значень які не призвели до закінчення пошуків, тобто не були кратні 11, та завершується.

Функції work-у та таймера
---------

Знову ж таки функції таймера та work-у схожі за своїм функціоналом, тому розглянуто буде лише одну з них.

.. code-block:: c
 
  void timer_func(struct timer_list *data)
  {
    long int temp_j = jiffies;
    struct struct_for_saving_results *timer_func_st_p = NULL;
    if ((temp_j%11) == 0) {
      printk(KERN_INFO "Final timer val is: %li\n", temp_j);
      flags.first_thr_run = false;
    } else {
      timer_func_st_p = kmalloc(sizeof(*timer_func_st_p), GFP_ATOMIC);
      if (timer_func_st_p) {
        timer_func_st_p->num = temp_j;
        list_add(&timer_func_st_p->list, &first_res_list.list);
        //printk(KERN_INFO "t - %li", temp_j);
      } if (flags.timer_run) {
        mod_timer(&timer, jiffies + 17);
      }
    }
  }

Дана функція виконує пошук ``jiffies`` кратного 11. Якщо ця функція одразу наткнеться на таке значення, вона переведе флаг ``first_thr_run`` 
у стан ``false``, що призведе до завершення циклу у відповідному потоці, а в подальшому до завершення потоку. Та виведе це значення у лог ядра.

Якщо ж вона натрапляє на значення ``jiffies`` які не є кратними 11, функція добавляє новий елемент у відповідний список з даним значенням, 
та виставляє новий таймер на виконання через 17 ``jiffies``.

Quick stop або передчасне вимкнення
--------

Розглянемо ситуацію якщо користувач передчасно вилучить модуль, тобто до того як таймер та ворк знайшли підходяще значення. У такому разі 
необхідно вручну виставити відповідні флажки завершення потоків, таймеру та ворку, та дочекатися іх завершення.

.. code-block:: c
 
  flags.work_run = false;
	while (flush_delayed_work(&work));
	
	flags.timer_run = false;
	del_timer_sync(&timer);


	if (flags.first_thr_run) {
		flags.first_thr_run = false;
		kthread_stop(threads_pointer[0]);
	}
	if (flags.second_thr_run) {
		flags.second_thr_run = false;
		kthread_stop(threads_pointer[1]);
	}

Як працюють ``flush_delayed_work()`` та ``del_timer_sync()`` вже було розглянуто вище. Зараз нас цікавить завершення потоків.

Для того щоб потоки змогли самостійно завершитись, флаг ``first_thr_run`` переведено у стан ``false``. Але також не охідно дочекатись 
їх завершення, адже одразу після цього блоку коду йде видалення списків, тих самих які потоки виводять по завершенню. Якщо не зачекати 
може виникнути конфлікт, який ні до чого хорошого не приведе. Очікування відбуваеться за допомогою ``kthread_stop()``.


Результат роботи
==================

Одже даний модуль запускає таймер і work з інтервалом 17 ``jiffies`` та кожне нове значення ``jiffies`` перевіряє на кратність 11. Всі 
не піходящі значення заносить до відповідного списку невдалих спроб. По знаходженню обох значень, виводить цей список у лог ядра та завершується.

На рисунках нижче можна побачити, що кожен запуск модуля відбувається у невідоме для користувача значення ``jiffies``, і для знаходження 
необхідних значень майже кожного разу необхідна різна кількість семплів (спроб).

   .. image:: img/4lab_first_simple.png
   
   .. image:: img/4lab_second_simple.png
   
Давайте подивимось як проходить вибірка:

   .. image:: img/4lab_samples.png

``w`` на рисунку відповідає значенням які не підійшли ворку, а ``t`` - значенням які не підійшли таймеру.

Для того щоб бути впевненими шо це саме ті значення, подивимося вибірку та вихідний спискок для ворку:

   .. image:: img/4lab_samples_proof.png

Як же нам перевірити передчасне вилучення модулю, якщо вибірка проходить за долі секунд?

Для цього було змінено значення яке шукає ворк з 11 за 113. А також для індикаціх передчасного вилучення додано ``printk()``, який спрацює 
саме тоді, коли модуль буде вилучено передчасно.

   .. image:: img/4lab_early_shutdown_finc_code.png

Подивимося що буде виведено в лог у такому разі:

   .. image:: img/4lab_early_shutdown_long_listing_proof.png

Як видно з рисунку вище, лістинг настільки довгий, що навіть не поміщається у 21 стрічку терміналу. До речі це лістинг самого лише ворка, 
адже вивід таймера під час даного тесту було вилучено.

Тепер настав час тесту. Для цього необхідно якомога швидше вилучити модуль, після його підключення. Для цього користуючись стрілками на 
клавіатурі можна застосувати команди використані в терміналі раніше, а саме ``make run`` та ``make stop``. Результат наступний:

   .. image:: img/4lab_early_shutdown_quick_shutdown.png

Як видно з рисунку, виклик та вилучення модулю вмістилися у 21-ій стрічці терміналу, це світчить про те, що модуль було вилучено досить швидко. 
Також можна побачити що необхідне значення знайдено не було, адже про це немає відповідного повідомлення ``Final work val is``, проте є 
повідомлення ``I need to stop!`` яке свідчить про те, що модуль вилучено передчасно.

Одже можна зробити висновок, що завчасне вилучення модуля не призводить до помилок у ядрі. А отже код написано правильно, та синхронізація 
працює доволі непогано.
