Звіт з виконання лабороторної роботи №2
=============================================

**У даній лабораторній роботі було поставлено наступну задачу:**


Написати найпростіший модуль ядра який має можливість приймати аргумент при підключенні модуля та виводити отриманий аргумент в лог ядра. Даний модуль повинен містити tasklet який в свою чергу виводить поточне значення глобальної змінної jiffies. Для перевірки відповідності розрахункового та реального часу необхідно засікти час між двома виводами jiffies за допомогою секундоміра, переведене значення jiffies порівняти з часом на секундомірі.

Програмний лістинг можна переглянути у наступному файлі `firstmod.c <https://github.com/AlexOstrianko/kpi-embedded-linux-course/blob/dev/dk62_ostrianko/lab2_simplest_kernel_modules/firstmod.c>`__

**Результат наступний:**

1. Запуск секундоміра на BBXM
--------

У якості часу для тестування було рекомендовано взяти 10 хвилин. Результат засікання 10 хвилин на BBXM зображено на рис. нижче:

   .. image:: img/test_on_BBXM.jpg


З рисунку видно що попереднє значення jiffies дорівнює 53466, у той час як поточне значення дорівнює 113481. Для того щоб дізнатися скільки часу минуло необхідно відняти ці два значення.

.. code-block::

  jiffies_dif = 113481 – 53466 = 60015

Для того щоб перевести це значення у секунди застосовуємо наступну формулу: 

.. code-block::

  sec = jiffies_dif / HZ 

де HZ – кількість переривань системного таймера за одну секунду. Іншими словами за одну секунду jiffies збільшиться на HZ разів.

Для BBXM HZ дорівнює 100. Отже:

.. code-block::

  sec = 60015 / 100 = 600.15

перевівши в хвилини отримаємо:

.. code-block::

  min = 600.15 / 60 = 10.0025

У той час як значення на секундомірі дорівнює 10.0023. 

Порівнявши ці значення можна зробити висновок що результат співпадає, навіть досить точно співпадає. А отже переведене значення jiffies можна пов’язувати з реальним часом.

2. Запуск секундоміра на х86
------

Результат засікання 10 хвилин на х86 зображено на рис. нижче:

   .. image:: img/test_on_x86.png

Проведемо розрахунки аналогічні розрахункам у попередньому пункті:

.. code-block::

  jiffies_dif = 239426 – 58277 = 181149

.. code-block::

  sec = jiffies_dif / HZ 

Значення HZ для х86 дорівнює 300. Отже:

.. code-block::

  sec = 181149 / 300 = 603.83

.. code-block::

  min = 603.83 / 60 = 10.0638

Значення зняті з секундоміру – 10.

Перед тим як порівнювати ці два значення, хотілося сказати що результат переведений зі значення jiffies виявився дещо більшим за результат на секундомірі через те що запуск команди 

.. code-block:: c

  sudo insmod firstmod.ko incoming_str=Alex
 
запросив введення паролю адміністратора, на що було втрачено декілька секунд, у той час як секундомір вже було зупинено.

Порівнявши ці значення, враховуючи те, що декілька секунд було втрачено на введеня пароля, можна зробити висновок,
що значення співпадають. А отже переведене значення jiffies знову таки виявилося досить точним.

3. Отримання аргументу при підключенні модуля
------

Для того щоб при підключенні модуля в нього можна було передавати аргумент в самому модулі необхідно задекларувати змінну яка буде приймати значення аргументу командної строки а потім скористатися module_param() 

Фрагмент коду з декларацією наведено нижче:

.. code-block:: c

  static char *incoming_str = "Nothing incomed";

  module_param(incoming_str, charp, 0000);

Після чого дана змінна може приймани аргумент командної стрічки наступним чином:

.. code-block:: 

  insmode module_name.ko incoming_str=Some_text

4. Використання tasklet-ту
---------

Використання tasklet-ту чимось нагадує використання thread-ів в попередній лабораторній роботі.

Для того щоб задекларувати тасклет використовується наступна команда:

.. code-block:: 

  DECLARE_TASKLET(tasklet_name, tasklet_function, tasklet_arg);

Щоб викликати (запланувани на виконання) тасклет виристовується функція:

.. code-block:: 

 	tasklet_schedule(&tasklet_name);

Сам тасклет у даному прикладі лише виводить поточне значення jiffies:

.. code-block:: 

  printk(KERN_INFO "Tasklet jiffies = %lu!\n", jiffies);
  
Під час відключення модулю необхідно вимикати (вбивати)  тасклет:
  
.. code-block:: 
  
	  tasklet_kill(&tasklet_name);

5. Результат виводу jiffies в init блоці та за допомогою tasklet-ту
----------

В обох прикладах, на обох платформах, результат виводу jiffies в init блоці та за допомогою tasklet-ту співпадав. Це пояснюється тим, що між виконанням обох запитів проминуло не так багато часу. Проте, наскільки я зрозумів, якщо процессор буде надто завантажений, або на виконання прийдуть таксклети з більш високим пріорітетом, виконання даного таксклету може буди відкладене, а отже значення jiffies за цей час може збільшитись, и тоді вони можуть відрізнятися на 1 чи на 2 значення.



