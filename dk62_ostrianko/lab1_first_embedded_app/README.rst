Звіт з виконання лабороторної роботи №1
=============================================

**У даній лабораторній роботі було поставлено наступну задачу:**


Написати програму яка створює два потоки кожен з яких в свою чергу збільшує значення змінної на 1.
Скомпілювати та запустити програму з флагами оптимізації -О0 та -О2. Також запустити програму на bbxm. Порівняти результати.

Програмний лістинг можна переглянути у файлах `thread.c <https://github.com/AlexOstrianko/kpi-embedded-linux-course/blob/dev/dk62_Ostrianko/lab1_first_embedded_app/src/thread.c>`__ та   `func.c <https://github.com/AlexOstrianko/kpi-embedded-linux-course/blob/dev/dk62_Ostrianko/lab1_first_embedded_app/src/func.c>`__.

Результат запуску програми на компьютері можна спостерігати на рисунку нижче:

   .. image:: img/Results.png

**Результат наступний:**

1. Програма скомпільована без оптимізації дорахувала до 101130226, хоча якби обидва потоки дорахували
до 100000000, результат мав би бути 200000000. Отже можна зробити висновок, що програма порахувала не вірно. Чому так 
могло статися? Це можна пояснити роботою потоків. Оскільки ітерація змінної може виконуватися в декілька кроків, наприклад: 

.. code-block:: с

  temp = var;
  temp = temp + 1;
  var = temp;

У такому разі інший поток може перехопити ініціативу ще до того як нове значення буде записано, та почати працювати зі змінною самостійно.
Адже обидва потоки працюють з одним адресним простором, та мають доступ до однієї і тієї самої змінної, має місце такий баг. Наступний 
раз коли першиий потік перейме ініціативу, в першу чергу він перезапише значення змінної на те, яке він попередньо зберіг.

Для того щоб уникнути такого багу необхідно використовувати блокування інших потоків під час ітерації змінної:

.. code-block:: с

  pthread_mutex_lock(&lock);
  var++;
  pthread_mutex_unlock(&lock);

Таким чином інші потоки не зможуть перейняти ініціативу під час виконаня коду який знаходиться всередині такої конструкції.

2. У свою чергу программа зкомпільована з оптимізацією -О2 рахуе вірно, тобто результатом обчислення є 200000000. Але якщо поглянути на 
час виконання цієї программи та порівняти цас з виконанням програми без оптимізації закрадаються сумніви. Адже маловірогідно що программа 
могла пройти 200000000 циклів за такий короткий час. Скоріше за все оптимізація зробила наступним чином. Дивлячись на те, що в тілі циклу 
виконується лише ітерація однієї змінної, вона просто додала до значення цієї змінної те число, яке дорівлює кількості циклів. Таким чином 
один потік поклав у змінну 100000000 а інший додав свої 100000000.

Щодо результатів тестування на bbxm, мені не вдалося протестувати дану програму на beagleboard. На beagleboard було запущено програму 
яка запускала два потоки, які ітерували різні змінні, тому результат завжди був вірний, з різними оптимізаціями змінювався тільки час 
виконання програми.

