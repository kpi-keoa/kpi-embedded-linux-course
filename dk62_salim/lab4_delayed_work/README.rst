Звіт з виконання лабораторної роботи №4  
=======================================

1. Завдання 
-----------

Метою даної лабораторної роботи було написати простий модуль ядра, який:

  * вивчити особливості роботи таймеру і work queue
  * реалізувати два потоки, запустити таймер і ворк в shared work queue
  * при спрацюванні таймера перевірити поточне значення jiffies, якщо воно кратне 11 - зупинити потік 1, інакше - таймер повинен перезапустити себе через 17 jiffies
  * усередині ворку перевірити поточне значення jiffies, якщо воно кратне 11 - зупинити потік 2, інакше - ворк повинен заснути на 17 jiffies і перезапустити себе
  * додати два зв'язих списки, в які аллоціювати та додавати елементи зі значеннями jiffies, які не привели до завершення потоків 1 і 2
  * при виході з потоків роздруковувати списки 
  * всередині ворку і таймера використовувати правильні аллокації для нових елементів списку, правильну синхронізацію роботи зі списком
  * передбачити, що користувач може вивантажити модуль до відпрацювання всіх таймерів і ворків

2. Теоретичні відомості та реалізація
-------------------------------------

2.1. Timer
"""""""""""

Таймери(timers), або як їх ще називають, динамічні таймери, або таймери ядра, необхідні для керування ходом часу в ядрі. В коді
ядра часто необхідно відкласти виконання деяких функцій на більш пізній час. Таймер - це засіб, який дозволяє відкласти виконання
роботи на деякий інтервал часу. Якщо цей інтервал не дуже маленький, але й не дуже великий, то для вирішення цієї проблеми
використовуються таймери ядра. 
Таймери дуже легко використовувати. Необхідно виконати деякі початкові дії, вказати момент часу закінчення очікування, вказати
функцію, яка буде виконана, коли закінчиться інтервал часу очікування, і активувати сам таймер. Таймера не являються циклічними.
Коли закінчується інтервал часу очікування, таймер анулюється. Це одна з причин, чому таймери називають динамічними. Таймери 
постійно створюються і анулюються, на кількість створюваних таймерів не накладаються ніякі обмеження. Таймери використовуються
практично в усіх частинах ядра. 
Таймери представляються в ядрі за допомогою структури ``timer_list``, яка визначена в файлі ``<linux/timer.h>`` наступним чином

.. code-block:: c

  struct timer_list {
	/*
	 * All fields that change during normal runtime grouped to the
	 * same cacheline
	 */
	struct hlist_node	entry;
	unsigned long		expires;
	void			(*function)(struct timer_list *);
	u32			flags;

  #ifdef CONFIG_LOCKDEP
	struct lockdep_map	lockdep_map;
  #endif
  };
  
Перед початком використання таймера, його необхідно задекларувати

.. code-block:: c

  struct timer_list mytimer;
  
А вже потім потрібно заповнити всі інші поля структури. Щоб не робити це все вручну, можна використати макрос, який в якості
аргументів приймає вказівник на таймер та на функцію-обробник таймеру 

.. code-block:: c

  DEFINE_TIMER(mytimer, tmr_handler);
  
А потім задати інтервал часу, через який таймер буде запущено та запустити його, за допомогою макросу

.. code-block:: c

  mod_timer(&mytimer, jiffies + msecs_to_jiffies(1000));
  
Також описану вище функцію можна використовувати для перезапуску таймеру.
Для того щоб зупинити таймер, використовується функція 

.. code-block:: c

  del_timer(&mytimer);
  
Цю функцію можна використовувати як з запущеними, так і не запущеними таймерами. Також потрібно враховуати те, що дану функцію 
не потрібно викликати, якщо інтервал очікування таймеру вже закінчився, так як такі таймери зупиняються автоматично.
Для того щоб зупинити таймер і зачекати, доки завершиться виконуватись його функція-обробник, використовується функція 

.. code-block:: c

  del_timer_sync(&mytimer);
  
На відміну від попередньої функції, дана функція не може викликатися з контексту переривання.

2.2. Work queue
"""""""""""""""

Черги відкладених дій(work queue) - це один з способів  реалізації  відкладених операцій. Такі черги дозволяють відкласти деякі
операції для подальшого  виконання в потоці ядра. Даний тип обробників з нижніх половин завжди виконується в контексті процесу, і
як наслідок, використовує всі переваги контексту процесу. Головною перевагою є те, що таким процесом керує системний планувальник,
тому код, який виконуэться може переходити в стан очікування. 
В загальному випадку підсистема черг відкладених дій - це інтерфейс для створення потоків ядра, які виконують дії, які кимось
були поставлені в чергу. Ці потоки називаються робочими потоками(worker threads). Але, крім того, в підсистемі черг відкладених
дій передбачений спеціальний стандартний робочий потік, який виконує потрібну дію. Стандартні робочі потоки називаються events/n, 
де n - номер ядра(core) процесору. Стандартні робочі потоки виконують відкладені дії, які були ініційовані з різних місць.
Більшість драйверів в ядрі перекладають обробку своїх нижніх половин  на стандартні робочі потоки. Тому якщо немає строгої
необхідності в створенні власного потоку ядра, тому краще використовувати стандартні робочі потоки. Але тим не менш, ніхто не
забороняє коду ядра створювати свої робочі потоки. Це може знадобитись, якщо в робочому потоці виконується велика кількість 
обчислювальних операцій. Для операцій, які інтенсивно використовують центральний процесор або критичні до часу виконання також
має сенс створювати окремі робочі потоки. В результаті буде зменшене навантаження на стандартні робочі потоки і усунена проблема
нехватки ресурсів для виконання інших відкладених дій. 
Всі робочі потоки реалізовані як звичайні потоки ядра, які виконують функцію ``worker_thread()``. Після початкової ініціалізації
ця функція входить в бескінечний цикл і переходить в режим очікування. Коли яка-небудь дія ставиться в чергу, потік активується і
починає виконувати її. Після того як в черзі не залишається роботи, яку потрібно виконати, потік знову переходить в режим
очікування. 
Тепер розглянемо стуктуру ``work_struct``, яка визначена в файлі ``<linux/workqueue.h>``

.. code-block:: c

  struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
  #ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
  #endif
  };
  
Існує також ще одна структура ``delayed_work``, за допомогою якої дія може бути запланована через визначений інтервал часу, на 
відміну від попередньої

.. code-block:: c

  struct delayed_work {
	struct work_struct work;
	struct timer_list timer;

	/* target workqueue and CPU ->timer uses to queue ->work */
	struct workqueue_struct *wq;
	int cpu;
  };
Першим етапом в створенні відкладенної відкладеної дії є створення статичної структури за допомогою макросу

.. code-block:: c

  DECLARE_DELAYED_WORK(mywork, work_handler);
  
В результаті буде задекларований та ініціалізований елемент **work** типу ``delayed_work`` з іменем ``mywork`` та функцією-
обробником ``work_handler``.
Запланувати дію на виконання через визначений інтервал часу можна за допомогою функції

.. code-block:: c

  schedule_delayed_work(&mywork, msecs_to_jiffies(1100));
  
Так як дана функція приймає значення затримки в одиницях jiffies, то було використано функцію ``msecs_to_jiffies()``, яка
конвертує значення, задане в мілісекундах, в jiffies. 
Для того щоб зачекати на закінчення виконання елементу **work** була використана наступна функція

.. code-block:: c

  flush_delayed_work(&mywork)
  
Дана функція враховує лише останній екземпляр черги. 

2.3. Інші дії
"""""""""""""

Так як в даній роботі потрібно було створити всього два потоки, обидва з яких будуть записувати в свої зв'язні списки значення
jiffies, які не призвели до завершення цих потоків, то для кожного з них були створені окремі функції. Якби потрібно було
створити більше потоків, та щоб не описувати функцію для кожного з них, можна було б це зробити за допомогою однієї функції.
Даний механізм більш детально розглянуто в звіті Богдани Довженко. 
Тепер розглянемо функцію-обробник для таймеру та ворку на прикладі однієї з них, так як вони схожі за своєю логікою роботи

.. code-block:: c

  static void tmr_handler(struct timer_list *data)
  {
	long int j = jiffies;
	struct struct_for_res *tmr_ptr = NULL;
	if (j%11 == 0) {
		printk(KERN_INFO "Stop timer jiffies value is: %li\n", j);
		frst_kth_flag = false;
	} else {
		tmr_ptr = kmalloc(sizeof *tmr_ptr, GFP_ATOMIC);
		if (tmr_ptr) {
			tmr_ptr->num = j;
			list_add(&tmr_ptr->list, &frst_list.list);
		} /*else {
			printk(KERN_ERR "kmalloc didn`t allocate memory for timer!\n");
			frst_kth_flag = false;
		} */	
		if (tmr_flag) {
			mod_timer(&mytimer, jiffies + 17);
		}
	}
  }
  
Дана функція реалізує такий механізм: після спрацювання таймеру перевіряється значення jiffies, якщо ж воно кратне 11, то поток
зупиняє свою роботу, якщо ж ні, то таймер перезапускає себе через 17 jiffies. Також значення jiffies, з кроком 17, які не 
призвели до завершення потоку, записуються до зв'язного списку. 
Можна подумати що ця функція не реалізує завершення потоку, коли знайдеться значення jiffies кратне 11, так як не 
використовується функція ``kthread_stop()`` (це обумовлено тим, що таймер не може спати та працює в режимі переривання). Але це не
так, для синхронізації був придуманий механізм з прапорцями, який більш детально описаний в звіті Олександра Острянко(p.s. не
бачу сенсу описувати тут те ж саме, тому що тільки автор може найкраще розкрити головну ідею).
Цей самий механізм з прапорцями використовується для того, щоб запобігти ситуації, коли користувач може вигрузити модуль, ще до
того як спрацюють всі таймери та ворки.

Теоретичні дані були запозичені з книги **Robert Love, Linux Kernel Development. Third Edition**.

3. Результат
------------

Результат роботи на архітектурі **x86**, який відповідає заданій умові, наведено на рисунку нижче

	.. image:: img/pic.png

