Звіт з виконання лабораторної роботи №3  
=======================================

1. Завдання 
-----------

Метою даної лабораторної роботи було написати простий модуль ядра, який:

  * містить глобальну змінну
  * запускає М потоків на одночасне виконання
  * кожний потік інкрементує змінну N разів та кладе значення змінної в список та завершується
  * при вигрузці, модуль виводить значення змінної та вміст списку
  * використати параметри модулю для задання інкременту N та кількості потоків M
  * для змінної, списку, потоків використати динамічну аллокацію 
  * змінну передавати в потік по ссилці аргументом
  * реалізувати функції ``lock()`` та ``unlock()`` з використанням атомарних операцій ядра
  * враховувати та правильно відпрацьовувати можливі помилки

2. Теоретичні відомості
-----------------------

2.1. Потоки
"""""""""""

Багатопоточність - це популярна сьогодні програмна абстракція. Вона забезпечує виконання декількох потоків в в спільно 
використовуваному адресному просторі пам'яті. Потоки також можуть спільно використовувати відкриті файли і інші ресурси. 
Багатопоточність використовується для паралельного програмування - **concurrent programming**, що на багатопроцесорних системах 
забезпечує істинний паралелізм. Для ядра Linux не існує окремої концепції потоків. У ядрі Linux потоки реалізовані так само, як 
і звичайні процеси. Поток - це просто процес, який використовує деякі ресурси спільно з іншими процесами. Кожен потік має 
структуру і представляється для ядра звичайним процесом (який спільно використовує ресурси, такі як адресний простір, з іншими 
процесами).

2.2. Списки
"""""""""""

На даний момент в ядрі Linux використовується циклічний двозв'язний список. Розглянемо переваги використання таких списків:

  * Незалежність від типу. Можна використовувати будь-яку структуру даних, яку заманеться.
  * Переносимість. 
  * Простота використання. В силу незалежності списків від типу даних записів для ініціалізації, доступу до елементів списку, для проходження за списком використовуються одні й ті ж функції.
  * Простота сприйняття. Макроси та **inline**-функції роблять код дуже елегантним і простим для розуміння.
  * Економія часу. Використання списків дозволяє істотно заощадити час на налагодження і повторне створення списків для кожної структури даних, яка використовується в програмі.

2.3. Атомарні операції
""""""""""""""""""""""

Атомарні операції - **atomic operations** надають інструкції, які виконуються атомарно, - тобто не перериваючись. Так само як і 
атом спочатку вважався неподільною часткою, атомарні операції є неподільними інструкціями. 
Ядро надає два набори інтерфейсів для виконання атомарних операцій: один - для роботи з цілими числами, а інший - для роботи з 
окремими бітами. Ці інтерфейси реалізовані для всіх апаратних платформ, які підтримуються операційною системою Linux. Більшість 
апаратних платформ підтримують атомарні операції або безпосередньо, або шляхом блокування шини доступу до пам'яті при виконанні 
однієї операції (що в свою чергу гарантує, що інша операція не може виконатися паралельно).

3. Реалізація 
-------------

Для списків, потоків, глобальної змінної та функції ``lock()`` потрібно було динамічно виділяти пам'ять, а також відловлювати 
можливі помилки та правильно їх відпрацьовувати. Для виділення памяті була використана функція ``kmalloc()`` з бібліотеки 
``<linux/slab.h>``. Основною властивістю такого механізму виділення пам'яті є те, що виділена область являється неперервною в
фізичній пам'яті. Приклад виділення памяті для змінної типу ``atomic_t`` наведено нижче.

.. code-block:: c

  atomic_t *ptr = kmalloc(sizeof *ptr, GFP_ATOMIC);
  
Як видно з фрагменту коду ``kmalloc()`` примймає два аргументи, перший з яких це розмір блоку, який буде виділений, а другий - це
флаг, який контролює поведінку ціє функції, в залежності від використаного флагу. В нашому випадку використано флаг ``GFP_ATOMIC``
який означає що процес не може бути поміщений в сон, а саме виділення пам'яті відбувається ззовні контексту процесу. Іншим 
найчастіше використовуваним флагом є ``GFP_KERNEL`` - він означає що виділення памя'яті відбувається від імені процесу, на відміну
від попереднього.

Далі розглянемо механізм обробки помилок при виділенні пам'яті. Якщо на якомусь етапі виділення пам'яті не відбулось, то за
допомогою ``goto`` ми зразу перепригуємо по мітці, та виводимо повідомлення про помилку. Також, якщо наприклад на 3 етапі з 4
відбулась помилка, виділена пам'ять очищається в зворотньому порядку. Приклад такого відловлювання та обробки помилок наведено
нижче.

.. code-block:: c

  arg = new_lock();
	if (!arg) 
		goto lock_Error;
	cnt = kmalloc(sizeof *cnt, GFP_KERNEL);
	if (!cnt) 
		goto cnt_Error;
	*cnt = 0;
	kth_ptr = kmalloc(sizeof *kth_ptr * kth_num, GFP_KERNEL);
	if (!kth_ptr) 
		goto kth_Error;	
	for (int i = 0; i < kth_num; i++) {
		kth_ptr[i] = kthread_run(&thread_func, (void *)cnt, "thread_%d", 
			i);
	}
	return 0;
	
	kth_Error:
		kfree(kth_ptr);
		kth_ptr = NULL;
	cnt_Error:
		kfree(cnt);
		cnt = NULL;
	lock_Error:  
		printk(KERN_ERR "kmalloc didn`t allocate memory!\n"); 
	return 0;
  
Далі розглянемо реалізацію функцій ``lock()`` і ``unlock()``. Дані функції використовуються в якості так званих **spinlock'ів**,
а саме для синхронізації потоків. Механізм роботи такої синхронізації оснований на механізмі **CAS - Compare-And-Swap**. Головною
ідеєю даного механізму є те, що операція порівняння і заміни атомарно порівнює вміст пам'яті з заданим значенням і, тільки якщо 
вони співпадають, змінює вміст даної області на нове задане значення. Даний трюк виконується за допомогою функції 
``arch_atomic_cmpxchg()`` з бібліотеки ``<linux/atomic.h>``. Конструкцію даної функції можна розглянути нижче.

.. code-block:: c

  static __always_inline int arch_atomic_cmpxchg(atomic_t *v, int old, int new)
  {
	  return arch_cmpxchg(&v->counter, old, new);
  }

Як видно з фрагменту коду, поданого вище, дана функція приймає три аргументи, перший з яких це вказівник на область пам'яті де 
зберігається старе значення, другий - значення, яке порівнюється з старим значенням, третій - значення яке буде записано в область
памя'яті на яку вказує перший аргумент, у випадку, якщо старе значення і значення з другого аргументу рівні. В іншому випадку
буде перезаписано старе значення.

4. Результат
------------

Результат роботи на архітектурі **x86** з та без синхронізації потоків наведено на рисунках нижче.

	.. image:: img/pic.png

	.. image:: img/pic1.png

