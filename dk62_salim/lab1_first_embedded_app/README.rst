Звіт з виконання лабораторної роботи №1  
=======================================

1. Виконання 
------------

Під час виконання даної лабораторної роботи була опрацьована та проаналізована 
реалізація багатопоточності на різних архітектурах, а саме x86(PC) та ARM(Beagle 
Board). Для цього була написана програма на мові С з використанням бібліотеки 
lpthread та Makefile для її збірки та запуску. В програмі запущено два потоки, 
кожен з яких інкрементує одну й ту саму глобальну змінну. Вихідний файл 
``thread.c`` програми знаходиться в піддерикторії ``src`` 

2. Результат
------------

Програма була скомпільована з прапорцями оптимізації ``O0`` та ``O2`` та 
запущена на кожній з архітектур. 
Результат роботи на архітектурі **x86**:

.. code-block::

  [maksimo0@maksimo0-pc lab1_first_embedded_app]$ make all
  gcc -o main_1 -O0 -Wall -Wextra -Wpedantic -lpthread thread.c
  gcc -o main_2 -O2 -Wall -Wextra -Wpedantic -lpthread thread.c
  ./main_1
  Sum from the thread 13267686
  Execution time 0.083206
  ./main_2
  Sum from the thread 20000000
  Execution time 0.000294
  rm -rf main_1 main_2

Результат роботи на архітектурі **ARM**:

.. code-block::

  debian@beagleboard:~/build$ make all
  gcc -o main_1 -O0 -Wall -Wextra -Wpedantic -lpthread thread.c
  gcc -o main_2 -O2 -Wall -Wextra -Wpedantic -lpthread thread.c
  ./main_1
  Sum from the thread 12547782
  Execution time 2.4946
  ./main_2
  Sum from the thread 20000000
  Execution time 0.001404
  rm -rf main_1 main_2

3. Висновок
-----------
Не вірні результати з використанням оптимізації ``O0`` на обох архітектурах 
можна пояснити тим, що планувальник задач передає контроль іншому потоку, ще до 
того, як основний потік закінчить свою роботу, тому й відбуваються такі казуси. 
Щоб цьому запобігти, можна використовувати так званий **mutex**, робота якого
полягає в тому, що він блокує роботу іншого потоку, поки основний потік не 
закінчить свою роботу. 
При використанні оптимізації ``O2`` результат майже завжди вірний. Це повязано з
тим, що компілятор оптимізує код так, щоб зменшити використання аппаратних
ресурсів і т.д. В нашому випадку замість того щоб додавати в циклі до глобальної 
змінної по одиниці, компілятор зробив так, що до цієї змінної додається зразу
задане число циклів за одну дію. 
 
