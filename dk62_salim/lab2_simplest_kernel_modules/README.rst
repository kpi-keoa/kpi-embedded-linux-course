Звіт з виконання лабораторної роботи №2  
=======================================

1. Виконання 
------------

Дана лабораторна робота була виконана завдяки командній роботі бригади з трьох
чоловік в яку входять:
 - Острянко Олександр
 - Салім Максим
 - Дана Довженко
Кожен з студентів вніс вагомий внесок в написання коду до лабораторної роботи. 
Також кожен пояснив свою та розібрався з частиною роботи інших учасників.

Метою даної лабораторної роботи було написати простий модуль ядра та
та протестувати його. За основу було взято `демо-код <https://bit.ly/2kLBtD9>`_.
В одному з завдань потрібно було вивести і'мя, передане в якості модуля. Для
цього був використаний макрос ``module_param()`` з бібліотеки 
``linux/moduleparam.h``. Другим завданням було додати так званий **tasklet** до 
отриманого модуля ядра який також буде виводити поточне значення **jiffies**.
Для цього була використана бібліотека ``<linux/interrupt.h>``.
Після цього модуль був скомпільваний та завантажений за допомогою
команди ``insmod``.

2. Результат
------------

Модуль був скомпільований та завантажений на обох архітектурах. Також потрібно 
було за допомогою секундоміру засікти час між двома включеннями модуля і 
порівняти цей результат з отриманими **jiffies** з логів ядра. 

Результат роботи на архітектурі **x86** наведено на рисунку нижче:

	.. image:: img/pic.jpg

Тепер переведемо **jiffies** в секунди за формулою ``jiffies * HZ = sec``, де
``HZ`` частота роботи системного таймеру в герцах(це значення можна перевірити 
за допомогою команди ``zcat /proc/config.gz | grep CONFIG_HZ``, в нашому випадку
це значення рівне 300 Гц). 
  1) 4296306666 - 4296125863 = 180803 jiffies
  2) 180803 / 300 = 602,676 sec ~ 10,0446 min
Як видно з розрахунку, результат майже співпадає з тим, який був отриманий за 
допомогою секундоміру.

Результат роботи на архітектурі **ARM**:

Так як за браком часу не вдалося перевірити роботу модулю на BBXM, та за 
дозволом викладача було взяте середнє значення результатів колег по бригаді.
Маємо наступний результат:
  1) jiffies = 60023
  2) 60023 / 100 = 600,23 sec ~ 10,0038 min (частота роботи системного таймеру на платі рівна 100)
  3) результат з секундоміру ~ 10,0046 min
Результат розрахунку теж майже співпадає з отриманим часом за допомогою 
секундоміру.

3. Висновок
-----------

На архітектурі **x86** результат наступний:

+-------------------------------+-------------------------------------+ 
| Теоретичне значення 1 jiffies | Експериментальне значення 1 jiffies |
+===============================+=====================================+ 
|          3,333333 ms          |              3,320078 ms            |
+-------------------------------+-------------------------------------+ 

На архітектурі **ARM** результат наступний:

+-------------------------------+-------------------------------------+ 
| Теоретичне значення 1 jiffies | Експериментальне значення 1 jiffies |
+===============================+=====================================+ 
|              10 ms            |             10,000833 ms            |
+-------------------------------+-------------------------------------+ 

Похибку в результатах можна пояснити людським фактором, так як такий експеримент
не відповідає 100% точності. 
Також, як видно з результатів значення jiffies за один і той самий проміжок часу 
на різних платформах досить відрізняється. Це пояснюється тим, що ядра на цих
платформах працюють з різною частотою. 
Різницю в 0, 1 або 2 jiffies з **tasklet** та **init** залежить від того,
наскільки завантажена система. **tasklet** буде починати свою роботу ще до
наступного тіку системного таймеру, якщо система не навантажена, тоді різниця 
буде рівна 0. В іншому ж випадку тасклет буде стартувати в наступному тіку, тоді
різниця буде відмінна від 0.

