Лабораторна робота 2
====================

Завдання:
---------

Написати модуль ядра, який:
	* Приймає 2 параметри *cnt* і *delay*
		- *cnt* - кількість циклів, які повинен опрацювати таймер
		- *delay* - затримка між двома спрацюваннями таймера
		- Модуль повинен відпрацьовувати при *cnt* і *delay* рівних нулю
	* Спочатку *init* друкує поточне значення *jiffies* в лог ядра
	* Запускає тасклет, котрий повинен надрукувати своє значення *jiffies* в лог ядра
	* Виділяє масив розміру *cnt*, використовуючи динамічну алокацію
	* Потім *init* запускає таймер з затримкою *delay* і функція завершується
		- При спрацюванні таймер кладе поточне значення *jiffies* до масиву і перезапускається з затримкою *delay*
		- Загальна кількість разів, які запускається таймер дорівнює *cnt*
	* В *exit* модуль повинен надрукувати поточне значення *jiffies* і вивести всі значення з масиву

Хід роботи
----------
Було створено два параметри *cnt* і *delay* за допомогою:
    -`module_param()`
    -`MODULE_PARM_DESC`

Створено массив *assert_array* розміром *cnt* в який буде записуватися значення *jiffies* при виклику функції обробника таймеру *study_timer*. Алокація пам'яті до цього масиву відбувається за допомогою *kzalloc*, тобто усі комірки цього масиву ініціалізовані нулями.

Після цього створено таймер *study_timer* та його функцію обробник *study_timer_callback*. У функції обробнику значення *jiffies* буде записуватися *cnt* разів до масиву *assert_array*.
    - Для об'явлення таймеру використовуємо `DEFINE_TIMER`, використовуючи цей метод кернел сам створить необхідну структуру *timer_list*
    - Для модифікації і запуску таймеру `mod_timer()`

Створено тасклет *study_tasklet* та його функцію обробник *study_tasklet_handler*.
    - Для об'явлення тасклету використовуємо `DECLARE_TASKLET()`
    - Для запуску тасклету зі звичайним пріорітетом викоривуємо `tasklet_schedule()`

У функції `init` перевіряємо вхідні параметри на корректність (якщо ні, виводимо повідомлення у лог), ініціазуємо масив, тасклет та запускаємо таймер, якщо параметри корректні.

У функції `exit` виводимо поточне значення *jiffies*, виводимо значення масиву та виконуємо деалокаію ресурсів:
    - тасклет - `tasklet_kill()`
    - таймер - `del_timer()`
    - масив - `kfree()`

Результат
---------

.. code-block::

	/ # insmod /mnt/mod_lab2.ko cnt=5 delay=100
    [   60.944370] mod_lab2: loading out-of-tree module taints kernel.
    [   60.959550] Mod Init: jiffies = 4294728273
    [   60.960134] Tasklet: jiffies = 4294728274
    [   60.963049] insmod (99) used greatest stack depth: 13656 bytes left
    / # insmod /mnt/mod_lab2.ko cnt=5 delay=100
    [   60.944370] mod_lab2: loading out-of-tree module taints kernel.
    [   60.959550] Mod Init: jiffies = 4294728273
    [   60.960134] Tasklet: jiffies = 4294728274
    [   60.963049] insmod (99) used greatest stack depth: 13656 bytes left

    Якщо *cnt* дорівнює 0. Друкує помилку в лог ядра за допомогою `pr_err()`.
    Не створює масив і не запускає таймер.
    / # insmod /mnt/mod_lab2.ko cnt=0 delay=100
    [ 2786.227362] Mod Init: jiffies = 4297453541
    [ 2786.227937] Mod Init: cnt <= 0
    [ 2786.228247] Tasklet: jiffies = 4297453542
    insmod: can't insert '/mnt/mod_lab2.ko': Operation not permitted

    Якщо *delay* дорівнює 0. Друкує попередження в лог ядра за допомогою `pr_warn()`.
    Не створює масив і не запускає таймер.

    / # insmod /mnt/mod_lab2.ko cnt=10 delay=0
    [   96.711850] Mod Init: jiffies = 4294764029
    [   96.713405] Mod init: delay = 0
    [   96.714854] Tasklet: jiffies = 4294764032
    / # rmmod mod_lab2
    [  108.401808] Mod Exit: jiffies = 4294775719
    [  108.403079] Timer Result:
    [  108.403296] [0] = [4294764036]
    [  108.404169] [1] = [4294764040]
    [  108.404979] [2] = [4294764041]
    [  108.405422] [3] = [4294764042]
    [  108.406227] [4] = [4294764043]
    [  108.406940] [5] = [4294764045]
    [  108.407736] [6] = [4294764046]
    [  108.408328] [7] = [4294764048]
    [  108.408946] [8] = [4294764049]
    [  108.409274] [9] = [4294764050]


    Якщо модуль вигрузити ніж таймер встигне відпрацювати повністю вивести повідомлення в лог.

    / # insmod /mnt/mod_lab2.ko cnt=100 delay=100000
    [  212.436807] Mod Init: jiffies = 4294879754
    [  212.437326] Tasklet: jiffies = 4294879755
    / # rmmod mod_lab2
    [  215.925324] Mod Exit: jiffies = 4294883243
    [  215.925723] Exit called while timer is pending



Висновок
--------
Отже було створено модуль який відповідає завданню, вивчено теоретичну частину:
    - Таслкети, зазвичай, використовуютсья для відкладеного оброблення переривань. Через те, що обробники переривань мають виконуватися швидко, в обробнику зчитуються основні данні від джерела перериваня, а потім планують тасклет, який повністю обробить переривання і буде визвний ядром пізніше, "безпечно" затриманий (в атомарному режимі). Такий метод називають *soft_irq*
    - Таймери дозволяють планувати завдання, які мусять бути виконані пізніше, без блокування поточної програми.
