# Звіт з виконання лабораторної роботи №3
## Завдання
Написати модуль ядра який:
- містить глобальну змінну
- запускає М потоків на одночасне виконання
- кожний потік інкрементує змінну N разів та кладе значення змінної в список та завершується
- при вигрузці, модуль виводить значення змінної та вміст списку
- використати параметри модулю для задання інкременту N та кількості потоків M
- для змінної, списку, потоків використати динамічну аллокацію
- змінну передавати в потік по ссилці аргументом
- реалізувати функції lock() та unlock() з використанням атомарних операцій ядра
- враховувати та правильно відпрацьовувати можливі помилки

## Хід роботи
Почалося виконання роботи зі створенні можливості динамічного створення енної кількості потоків, кількість який задавалася параметром модуля ядра.
Потоки було створено за допомогою функції 
`kthread_run(thread_fun, (void *)inc_var, "my_thread");`
де першим аргументом є функція, яка буде виконуватись у цьому потоці, другий аргумент це власне змінна, яка передається у потокову функцію та третій аргумент це назва потоку. Щодо третього аргументу, то в Лінуксі на рівні ядра потоки є ніщо іншим, як ще одні процеси, які мають свої піди, але оскільки під не може бути безіменним, то на рівні ядра потрібно обовязково називати поток якимось іменем.
### Списки
Наступним етапом було запис результату виконання потоку у список
Спершу потрібно створити обєкт списку.
`static LIST_HEAD(list_of_ints);`
Наступним кроком є створення вузлової структури списку, 
```с
struct int_node {
	struct list_head list;
	int data;
};
```
обовязковим членом струкутри є хедер списку
`struct list_head list;`
які містять в собі вказівник на наступний та попередній вузол списку.
Для додавання елементу до списку використовується функція 
`list_add();`
Для видалення 
`list_del();`

Також в цій роботі було написано функцію, яка автоматично при її виклику обходить повністю список та виводення значення вузла в лог ядра та після видаляє його.
```c
void print_and_erase_list(struct list_head *print_list)
{
	if(NULL == print_list) {
    	printk(KERN_ERR "Cant print NULL list\n");
      	return;
    }
	
	struct list_head *current_pos = NULL;
	struct list_head *tmp = NULL;
	struct int_node * current_node = NULL;
	list_for_each_safe(current_pos, tmp, print_list) {
         
         current_node = list_entry(current_pos, struct int_node, list);
         
         printk ("List element = %d\n" , current_node->data);
         
         list_del(current_pos);
         kfree(current_node);
    }
}
```
### Перші тести
На цьому етапі можна почати робити тестування
Спершу запущу 10 потоків, які рахують до 10

    [ 4818.354222] Num of threads  	10
    [ 4818.354224] Num of increments 10
    [ 4818.354266] Thread 0 started
    [ 4818.354348] Thread 1 started
    [ 4818.354439] Thread 2 started
    [ 4818.354465] Thread 3 started
    [ 4818.354515] Thread 4 started
    [ 4818.354567] Thread 5 started
    [ 4818.354583] Thread 6 started
    [ 4818.354596] Thread 7 started
    [ 4818.354610] Thread 8 started
    [ 4818.354622] Thread 9 started
    [ 4818.354623] Main thread end
    [ 4828.365466] Closing the module
    [ 4828.365467] List element = 100
    [ 4828.365468] List element = 90
    [ 4828.365468] List element = 80
    [ 4828.365469] List element = 70
    [ 4828.365469] List element = 60
    [ 4828.365470] List element = 50
    [ 4828.365470] List element = 40
    [ 4828.365470] List element = 30
    [ 4828.365471] List element = 20
    [ 4828.365471] List element = 10
    [ 4828.365472] See you later aligator!
    
Бачимо коректні результати навіть без синхронізації.
Тепер змусимо рахувати потоки до 1000000
```
[ 5151.558143] Closing the module
[ 5151.558145] List element = 10036545
[ 5151.558145] List element = 9000301
[ 5151.558146] List element = 8003455
[ 5151.558146] List element = 7032453
[ 5151.558147] List element = 6032535
[ 5151.558148] List element = 5005436
[ 5151.558148] List element = 4054656
[ 5151.558149] List element = 3006453
[ 5151.558149] List element = 2003654
[ 5151.558150] List element = 1000324
[ 5151.558151] See you later aligator!
```
Бачимо що результат неправильний, навіть кінцевий. Такі ж результати отримали на платі BBB.
### Синхронізація
Для синхронізації було написано 2  фундаментальні функції
```c
void lock(atomic_t *var)
{		
	while(atomic_cmpxchg(var, UNLOCK, LOCK));
}

void unlock(atomic_t *var)
{
	atomic_set(var, UNLOCK);
}
```

В ядрі Лінукса є атомарні змінні. Ідея полягає в тому, що атомарна змінна може приймати значення або заблоковано або розблоковано. Але по-справжньому красиве рішеня можна за домогою функції 
`atomic_cmpxchg(var, UNLOCK, LOCK)`

Щоб зрозуміти як вона працює достатньо глянути на її псевдокод та промоделювати роботу блокування
Псевдокод

    //how to work atomic_cmpxchg 
    //old = *p
    //*p = (old == UNLOCK) ? LOCK : old
    //return old;
    
### Результат
Результат роботи модуля з синхронізацією

    [ 1795.294723] Num of threads  	10
    [ 1795.294724] Num of increments 10000
    [ 1795.294828] Thread 0 started
    [ 1795.294958] Thread 1 started
    [ 1795.294995] Thread 2 started
    [ 1795.295040] Thread 3 started
    [ 1795.295310] Thread 4 started
    [ 1795.295340] Thread 5 started
    [ 1795.295375] Thread 6 started
    [ 1795.295408] Thread 7 started
    [ 1795.295440] Thread 8 started
    [ 1795.295476] Thread 9 started
    [ 1795.295476] Main thread end
    [ 1812.989740] Closing the module
    [ 1812.989741] List element = 100000
    [ 1812.989741] List element = 90000
    [ 1812.989742] List element = 80000
    [ 1812.989742] List element = 70000
    [ 1812.989742] List element = 60000
    [ 1812.989743] List element = 50000
    [ 1812.989743] List element = 40000
    [ 1812.989744] List element = 30000
    [ 1812.989744] List element = 20000
    [ 1812.989744] List element = 10000
    [ 1812.989745] See you later aligator!
    
Як бачимо все правильно
## Висновок
Отже, в цій роботі було вивчено роботу потоків ядра, списки, та методи синхронізації потоків.
