#  Результати виконання лабораторної роботи №7

Роботу виконували спільними зусиллями Шваюк та Якименко.

## DebugFS
**DebugFS** - це спеціальна файлова система, яка дозволяє спостерігати та змінювати деякі змінні чи дільниці памяті в модулях ядра. Доступна ця фіча починаючи з ядра 2.6.10

Щоб можна було користуватись цією фічею треба виставити додаткову опції в menuconfig, що ця файлова система скомпілювалась разом з ядров і була доступна для розробника.

Дебаг за допомогою цієї фічі полягає в тому, що в коді модуля ядра розробник може створити папку модуля ядра та розміщувати там файли довільної назви, які можна привязати до якоїсь змінної. Переглядаючи зміст цих файлів, можна дізнаватись значення змінних до яких власне привязаний дебаг файл і також можна записувати свої значення в дебаг файл і тим самим змінивши прямо в рантайм значення змінної, але це працює не для всіх типів файлів, які можна створити для дебагу.

### Практичне використання DebugFS в коді модуля ядра Hivemod

Перше, що потрібно зробити це створити папку, де будуть знаходитись дебаг файли.
Це робиться функцією
`struct dentry *debugfs_create_dir(const char *name, struct dentry *parent);`

Знайти її можна за адресою */sys/kernel/debug*

Тепер можемо створювати файли.
Найпростіший випадок, це створення файлу для беззнакової змінної
`struct dentry *debugfs_create_u8(const char *name, mode_t mode, struct dentry *parent, u8 *value);`

Але ще є функції для різних розрядностей та форматів

- struct dentry *debugfs_create_u16
- struct dentry *debugfs_create_u32
- struct dentry *debugfs_create_u64

Вивід в 16річці

- struct dentry *debugfs_create_x16
- struct dentry *debugfs_create_x32
- struct dentry *debugfs_create_x64

Та навіть булеве значення
- debugfs_create_bool

Але ще є особливий клас дебаг файлів це blob
Він собою являє дебаг великого масиву бінарних даних. В ньому також є заборона на зміну всісту, тому від тільки доля читання. Згідно до завдання нам саме його потрібно реалізувати в лабораторній для перегляду буферу даних.

Для його створення спершу потрібно створити обгортку 
`struct debugfs_blob_wrapper blob_wrapper;`
яка має 2 поля розмір буферу та сам буфер
```c
struct debugfs_blob_wrapper {
	void *data;
	int size;
}
```
Створення файлу відбувається за допомогою функції
`debugfs_create_blob(str, 0777, dirret, &(item->blob_wrapper));`

Після всьго що наробили потрібно все видалити. Це робиться за допомогою функцій
`void debugfs_remove(struct dentry *dentry)`

або щоб відразу все

`void debugfs_remove_recursive(struct dentry *dentry)`

### Пояснення за код
Перше, що було зроблено це створення папки в init
`dirret = debugfs_create_dir("hivemod", NULL); `

Та рекурсивне видалення в exit
`debugfs_remove_recursive(dirret);`

Наша ідея полягала в тому, що потрібно створювати дебаг файл блоб для кожного відкритого файлу нашого модуля ядра, щоб отримати на кожний відкритий файл, окремий дебаг файл конкретнеого буферу.

Для цього було змінено структуру 
```c
struct hive_ftree_item {
	struct rb_node node;
	struct file *file;
	char *buffer;
	long length;
	long rdoffset;
	long wroffset;
	struct debugfs_blob_wrapper blob_wrapper;
	struct dentry *blob_entry;
};
```
Додалася обгортка та сам ідпентифікатор дебаг файлу

При створенні обєкту обгортка ініціалізується
```c
	item->blob_wrapper.data = (void *)buf;
	item->blob_wrapper.size = buffer_size;
```

А вже в функції open створюється сам блоб файл
`	item->blob_entry = debugfs_create_blob(str, 0777, dirret, &(item->blob_wrapper));`

При закритті в функції release йде видалення
`debugfs_remove(item->blob_entry);`

### Практика

Було написано просту тестову програму яка 2 рази відкриває наш модуль ядра. Вже продемонстврована у минулій лабораторній

Та у лозі ядра бачимо написи про успішне створення
```c
[ 2414.060873] hivemod: New file entry 000000008382ecad created, debugfs name - 0000000002
[ 2414.060897] hivemod: New file entry 000000006f8a03c6 created, debugfs name - 0000000003

```
Тепер переглянемо вміст нашої дебаг папки
```c
root@oleh:/sys/kernel/debug/hivemod# ls
0000000000  0000000001
root@oleh:/sys/kernel/debug/hivemod# cat 0000000000
CLASSIC BEES TWERKING

```

Все працює супер.



#### Частина 2. Дебаг модуля ядра у KGDB та GDB.
1. Запуск образу Linux в QEMU
QEMU - це програма для віртуалізації, яка дозволяє запустити на звичайній х86 машині образ Linux (або іншої ОС), що був розроблений під іншу архітектуру. Це дозволяє спростити розробку, бо для тесту нового функціоналу вам не потрібно буде кожен раз запускати образ Linux на цілювій платформі (яка, враховуючи суворі реалії українського аутсорсу може розташовуватися на іншому континенті, а єдиний доступ до неї у вас буде через VPN-тунель).
 
Спочатку вам необхідно зібрати ядро та отримати файл bzImage - стиснутий образ ядра. 

Щоб ядро могло запуститися, йому необхідна мінімальна файлова система - initramfs. Створимо її найпростішим способом.
Створюємо папку, у який буде розміщуватися наша файлова система:
```
mkdif initramfs
mkdir initramfs/{bin,dev,etc,lib,lib64,mnt/root,proc,root,sbin,sys} 
cd initramfs
```
Скопіюємо необхідні для старту системи файли із директорії /dev/:
```
cp --archive /dev/{null,console,tty,sda1} ./dev/
```
Тепер нам необхыдно створити init скрипт, який буде запускати стандартну першу програму (термінал bash).
```
touch init
nano init
```
і записуємо у нього такий вміст:
```
#!/bin/sh
 
mount -t proc none /proc
echo 0 > /proc/sys/kernel/randomize_va_space
mount -t sysfs none /sys
mount -t debugfs none /sys/kernel/debug
mount -t devtmpfs none /dev
mount /dev/sda /mnt

echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"

exec /bin/sh
```
Тепер ми можемо запускати ядро, але у нас не буде жодних програм і це погано. Необхідно їх або власноруч скомпілювати за допомогою крос-компілятору під цільову платформу (у нашому випадку крос-компіляція не потрібна, адже ціьова платформа - х86, із міркувань економії часу), або взяти готові бінарники, за допомогою ldd  з'ясувати від яких динамічних бібліотек вони залежать та скопіювати ці бінарники та .so файли динамічних бібліотек у тільки-но створену initramfs, зі збереженням розташування файлів у файловій системі. Або просто скоритатися busybox - інструментом, який все це зробить за нас та надасть нам можливість користуватися всіма необхідними утилітами на цільовій системі. 

Завантажуємо вихідний код busybox, компілюємо її, потім вводимо команду `` make install `` та отримуємо папку __install_, у якій будуть розташовані папки bin, sbin, usr та файл linuxrc. Їх всі необхідно скопіювати у папку із initramfs.

Далі необхідно із папки з файловою системою отримати повноцінний файл із нею. Цей файл буде мати розширення .igz . Просто запустіть скрипт _create_rootfs_binary.sh_, вміст якого наведено у наступному лістингу:
```
rm ../binaries/initramfs.igz
cd ./../initramfs/
find . | cpio -H newc -o > ../binaries/initramfs.cpio
cat ./../binaries/initramfs.cpio | gzip > ./../binaries/initramfs.igz
rm ../binaries/initramfs.cpio
```

Тепер ми можемо повноцінно запускати ядро у qemu. Для того щоб воно там запустилося, необхідно передати цілу купу аргументів:
```
qemu-system-x86_64 \
-kernel ../binaries/bzImage \ передаємо розташування файлу ядра
-initrd ../binaries/initramfs.igz \ передаємо розташування файлової системи
-nographic \ щоб вивід був у терміналі, а не у окремому вікні
-append "earlyprintk=serial,ttyS0 console=ttyS0,115200 nokaslr" \ задаємо консоль через яку буде відбуватися вивід ядра, її бодрейт, вимикаємо Kernel Address Space Layout Randomization
-s \ одразу запустимо в qemu GDB-сервер
-drive file=../ext4_rootfs.img,cache=none,format=raw \ це ми примонтуємо завнішню файлову систему
-net nic,model=rtl8139 -net bridge,br=brkvm тут я намагався прокинути мережу в qemu, але в мене нічого не вийшло
```

Вуаля, ви всередині. Тапер у вас є два шляхи щоб запустити у отриманій віртуальній системі ваш модуль: додати його всередину іnіtramfs та перезібрати її, або додати його прямо під час роботи системи у shared ext4 файлову систему (тут я не розписую як її налаштувати, бо нема часу і я хочу спати, можу пояснити при особистому спілкуванні).

2. Дебаг ядра за допомогою GDB
В мене цей спосіб не вийшов, опишу чого я зміг добитися. Беремо ядро, при запуску в qemu запускаємо GDB-сервер аргументом командного рядка _-s_. Потім нам необхідно із папки зі скомпільованим ядром взяти файл _vmlinux_ - нестиснуте ядро, у якому присутня вся дебаг-інформація. Переходимо у папку зі скомпільованим ядром (де вихідний код) та вводимо команду:
```
gdb vmlinux --command=/home/max/work_dir/_University/-4_kurs/embedded_linux/labs/lab7_kernel_debuging/try2/scripts/gdb_commands_list
```
тут ми передали в GDB виконуваний файл із дебаг-інформацією та розташування файлу із командами для коректної ініціалізації GDB із таким вмістом:
```
target remote :1234 це означає, що GDB-сервер має бути на порті 1234
```
І тут є один момент через який нічого не працює. Для нормального дебагу ми маємо передати в GDB файл дампу ядра (повний зліпок пам'яті системи), що розташований у /proc/kcore. Але витягнути його із qemu нам з Олегом не вдалося с цілого ряду причин, які вже озвучувалися викладачу.

3. Дебаг ядра за допомогою KGDB
Щоб дебажити ядро за допомогою KGDB - необхідно обмінюватися дебаг інформацією через якийсь serial terminal. При запуску qemu необхідно передати такі аргументи ядру: ``kgdboc=ttyS1,115200 kgdbcon``. У kgdboc ви вказуєте через який із наявних у хост-системі терміналів ви будете проводити обмін інформацією. У гайдах в інтернеті це працює, а у нас видавало якусь помилку тому так продебажити такой не вийшло.

#### Висновок
Підсумовуючи, можу із впевненістю сказати: справжній (а не костильний щоб здати лабу) дебаг ядра, що запущене в qemu - це дуже нетривіальна задача і в нас не вийшло до кінця з нею розібратися, нажаль. Тому, як вже казали: _"printk - наше все"_.








