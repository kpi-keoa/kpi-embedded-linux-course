# Звіт до лабораторної роботи №1

## Завдання
Написать на С программу, которая:
- запускает два потока (используя pthread);
- каждый поток увеличивает значение глобальной переменной на 1 в цикле 100000000 раз
- в конце делает join потоков и выводит полученное значение переменной
- собрать с флагами -O0 и -O2 для x86 и для платы
- сравнить и объяснить полученные результаты
- Написать Makefile и README.rst (ваш протокол к лабораторной) в соответствии с требованиями репозитория. 
- Добавить лицензию и .gitignore.  
- Сделать Pull Request в репозиторий

У якості плати використовувалась **BeagleBone Black rev C**

## Хід роботи



У ході виконання роботи було написано багатопоточну програму на С, яка може інкрементувати число в двох потоках задану користувачем кількість разів. Щоб задати кількисть циклів потрібно її напсиати відразу після назви програми *Наприклад* `./name 1000`.

Програма запускалась на двох платформах: **х86** та **BeagleBone Black rev C**. 
Запуск проводився для кожного виду оптимізації з циклами від 100 до 10000000 разів. Також дослідження проводилось **з** затримкою та **без**.

Результати наведені в таблицях нижче. 

*Примітка Буква **П** означає, що результат вийшов правильний тобто якщо 100 разів, то результат вийшов 100. **Н** означає, що результат при 100 циклів вийшов відмінним від 100.*

##### З затримкою х86
|Оптимізація| 100 | 1000 | 10000 | 100000 | 1000000 | 10000000 |
|:---------:|:---:|:----:|:-----:|:------:|:-------:|:--------:|
|  **о0**   |  Н  |   Н  |   Н   |    Н   |    Н    |     Н    |
|  **о2**   |  Н  |   Н  |   Н   |    Н   |    Н    |     Н    |
|  **о3**   |  Н  |   Н  |   Н   |    Н   |    Н    |     Н    |  

Всюди результат вийшов неправильний, бо операція інкременту не атомарна і не було застосовано примітивів синхронізації.

##### Без затримки х86
|Оптимізація| 100 | 1000 | 10000 | 100000 | 1000000 | 10000000 |
|:---------:|:---:|:----:|:-----:|:------:|:-------:|:--------:|
|  **о0**   |  Н  |   Н  |   П   |    П   |    П    |     П    |
|  **о2**   |  Н  |   Н  |   П   |    П   |    П    |     П    |
|  **о3**   |  Н  |   Н  |   П   |    П   |    П    |     П    | 

Тут вийшло диво, починаючи з леякого числа компілятор незалежнео від рівня оптимізації всодно робить оптимізацію і відразу інкрементує на число, а не крутиться в циклі, тому і резуольтати вийшли правильними.

##### З затримкою ВВВ

|Оптимізація| 100 | 1000 | 10000 | 100000 | 1000000 | 10000000 |
|:---------:|:---:|:----:|:-----:|:------:|:-------:|:--------:|
|  **о0**   |  Н  |   Н  |   Н   |(50х50) | (50х50) |  (50х50) |
|  **о2**   |  Н  |   Н  |   Н   |(50х50) | (50х50) |  (50х50) |
|  **о3**   |  Н  |   Н  |   Н   |(50х50) | (50х50) |  (50х50) | 

##### Без затримки ВВВ

|Оптимізація| 100 | 1000 | 10000 | 100000 | 1000000 | 10000000 |
|:---------:|:---:|:----:|:-----:|:------:|:-------:|:--------:|
|  **о0**   |  Н  |   Н  |   Н   |(50х50) | (50х50) |  (50х50) |
|  **о2**   |  Н  |   Н  |   Н   |(50х50) | (50х50) |  (50х50) |
|  **о3**   |  Н  |   Н  |   Н   |(50х50) | (50х50) |  (50х50) |  

Для обох варіантів вийшли однакові результати, починаючи з деякого числа результат може бути правильним або ні, в залежності від везіння, це свідчить про те, що планувальник задач починає втручатись і залежно від везіння може вийти різний результат.

Також було написано*Makefile *, який дозволяє скомпілювати програму відразу в три способа: з прапорами о0, о2 та о3 (генерується відразу три бінарника). Також можна скомпілювати програму кожним способом окремо. Його код можна переглянути в корні директорії цієї лабораторної.

## Висновок

У ході лабораторної роботи було вперше в житті запущено Embedded Linux на мікрокомпютері та навіть запущена там перша програма. Результати її роботи виявились не такими очікуваними, як вважалось раніше. Виявилось, що на невеликій складності алгоритму прапори компіляції взагалі не впливають, що впринципі вже є досить логічним. Також було виявлено, що запуски на різних платформах одного коду також дають різні резулььтати, тому бажано тестувати той чи інший код на всіх цільових платформах.
