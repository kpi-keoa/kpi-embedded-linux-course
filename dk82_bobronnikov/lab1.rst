 ******************************************************
 Лабораторна робота 1. Введення у розробку модулів ядра
 ******************************************************

 Мета роботи:
	- Провести збірку Linux-ядра
	- Запустити скомпільоване ядро за допомогою QEMU з використанням BusyBox
	- Запустити тестовий модуль у середовищі зібраного ядра
	- Трохи змінити функціонал модулю і переконатись в його роботі

 Спочатку були встановлені групи пакетів ``base-devel`` (інструменти збірки)
 та ``QEMU`` (емулятор ядра). Були завантажені вихідні коди ядра з сайту kernel.org.
 За допомогою інструменту Kconfig було сконфігуровано ядро. Для цього використали
 псевдографічний інтерфейс:
 ``make menuconfig``
 Хоча і це не є необхідністю на машинах з великою кількістю пам'яті,
 ядро було зібране у стиснутому форматі bzImage:
 ``make -j3 bzImage``
 де 3 - кількість ядер CPU + 1, що використовується для збірки
 Розмір складає 9,2 МБ.
 Для запуску ядра використана команда:

 ``qemu-system-x86_64 -m 256M -smp 2 -kernel "./bzImage" -append "console=ttyS0" -nographic``
 де	256M - кількість використовуваної ОП
	``-smp``  - кількість ядер процесора, що буде використовуватись в системі
	``-kernel`` - файл ядра
	``-append`` - поток виводу
	``-nographic`` - не використовувати емуляцію GPU
 Параметр enable-kvm не використовувався через помилку

 Далі маємо використовувати BusyBox для створення ramdisk (розділ у RAM для завантаження системи)
 Інтерфейс налаштування BusyBox схожий на інтерфейс menuconfig для QEMU. Запуск:
	``make menuconfig``
 Встановлення BusyBox:
	``make -j3 install``
 де 3 - кількість ядер CPU + 1, що використовується для збірки

 В якості прикладу модуля був взятий firstmod.c
 Для його збірки треба написати makefile.
 Після команди
	``make modules``
 поряд з вихідними файлами мають з'явитись об'єктні файли модуля, в тому числі і firstmod.ko
 Поява цього файлу вказує на нормальний процес збірки модуля.
 Тепер цей модуль треба підключити до ядра, тому команда для QEMU змінюється:

	``qemu-system-x86_64 -m 256M -smp 2 -kernel "./bzImage" -initrd "./initramfs.cpio.gz" \
                   -append "console=ttyS0" -nographic \
                   -drive file=fat:rw:./mymodule,format=raw,media=disk``
				   
 Команда ідентична попередній команді QEMU, але додається ramdisk
 Вже на запущеному ядрі в QEMU маємо спочатку підмонтувати диск з модулем:
	``mkdir /mnt		 
 mount -t vfat /dev/sda1 /mnt``
 Запуск ядра:
	``insmod /mnt/firstmod.ko``
 Інформація про працюючі модулі та вивантаження модулю:
	``lsmod
 rmmod firstmod``

 Останнім завданням є змінити код ядра таким чином, щоб:
	- модуль виводив ім'я користувача, що передане в якості параметра до модуля
	- у фукції ..._exit (виконується при вивантаженні) виводити час роботи модуля, 
	розрахований за допомогою jiffies.
 Для цього додаємо в код вказівник на строку, що буде містити ім'я та змінну,
 що буде зберігати момент часу запуску ядра. Для повідомлення про відсутність
 переданого аргументу імені використовуємо тип повідомлення KERN_WARNING.
 Функція jiffies_delta_to_msecs приймає різницю між наявним та початковим значенням jiffies,
 а повертає різницю в мілісекундах.
 Щоб передати параметр при запуску модуля, робимо:
	``insmod /mnt/mymodule.ko name="Name"``
 Для форматування до coding style:
	``clang-format -i style=file ./mymodule.c``

 Висновки:
 #########
 Для зборки ядра з вихідних файлів використовується група пакетів base-devel, ядро
 можна точно налаштувати під будь-які задачі. Для емуляції використовуємо QEMU з підмонтованим
 ramfs для ініціалізації системи та модулів, що додаємо.
 Для відповідності вихідних файлів модулів з kernel coding style можна використовувати 
 clang-format з відповідним шаблоном.
