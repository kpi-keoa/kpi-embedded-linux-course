=================================================
**Лабораторна робота №1 засоби відкладеної роботи: тасклети таймери**
=================================================

Завдання
---------------------------------------------------------

* ознайомитись з зазначеною документацією
* на основі отриманих знань створити модуль  ядра що приймати 2 параметри з командної строки cnt та delay. При запуску init молдуль повинен з початку вивести поточне зеначення jiffies потім потрібно запустити тасклет 
що зробить те саме. Далі потрібно запустити таймер що повторно запуститься cnt разів із затримкою delay 

Хід роботи
----------------------------------------------------------

**Написання модуля ядра**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Згідно з отриманим завданням було створено модуль ядра що приймає cnt та delay. Цім параметрам було завше задано значення ``NULL`` щоб позначити що їх значення ще не було задано
далі була створена функція тасклету що виконує поставлену в завданні задачу, по перериванню таймера виконується функція що рекурсивно перезапускає таймер змінюючи значення ``expiers`` поля структури 
при цьому перевіряє кількість запусків лічильника при досьягненні значення cnt лічильник престає модифікуватись. В exit функції з початку відбувається припинення роботи тасклету функцією ``tasklet_kill()`` тому що при використанні цієї функції під час відпрацювання ``tasklet_handler``-у його виконання не переривається 
а доводитсься до кінця, ``tasklet_kill()`` просто забороняє подальший ``scheduling`` цього тасклету. Для деалокації було створено окрему функцію та структуру хоча без цього можна було цілком обійтись це було створено для демонстрації на мою думку оптимального варіанту деалокації великої кількості пам'яті, сенс використання структури при деалокації пам'яті полягає в тому що 
при алокації певної змінної це позначається в спеціальному бітовому полі а потім функція деалокування просто зчитує бітові поля та деалокує відповідні змінні. результат роботи модуля:

.. code-block:: bash

 / # insmod mnt/mymod.ko 
 [   68.812208] mymod: loading out-of-tree module taints kernel.
 [   68.841532] Invalid cnt value has to be(unsigned)cnt > 0
 insmod: can't insert 'mnt/mymod.ko': invalid parameter
 [   68.866237] insmod (99) used greatest stack depth: 13696 bytes left
 / # insmod mnt/mymod.ko cnt=10 delay=5
 [  102.881771] Init>> jiffies is 4294770209
 [  102.882619] tasklet>> jiffies = 4294770210
 / # lsmod
 mymod 16384 0 - Live 0xffffffffc03b9000 (O)
 / # rmmod mymod
 [  134.912584] exit>> tim_cnt 10
 [  134.912584] exit>> countrer number 0 has the 4294770217 jiffies val
 [  134.913821] exit>> countrer number 1 has the 4294770223 jiffies val
 [  134.914597] exit>> countrer number 2 has the 4294770232 jiffies val
 [  134.915331] exit>> countrer number 3 has the 4294770238 jiffies val
 [  134.916079] exit>> countrer number 4 has the 4294770245 jiffies val
 [  134.916778] exit>> countrer number 5 has the 4294770251 jiffies val
 [  134.917492] exit>> countrer number 6 has the 4294770258 jiffies val
 [  134.918191] exit>> countrer number 7 has the 4294770264 jiffies val
 [  134.918922] exit>> countrer number 8 has the 4294770270 jiffies val
 [  134.919457] exit>> countrer number 9 has the 4294770277 jiffies val
 [  134.920226] exit>> dealoc: array is deallocated
 [  134.920925] exit>> god save the Kernel!; jiffies = 4294802249
 
з початку було запущено модуль без вхідних параметрів, модуль відреагував на це відповідним чином, вказавши що параметер не задано та не запустившись указуючи на те що 
відсутні вхідні параметри. далі запускаємо модуль ще раз тільки вже з параметрами в лог ядра виводиться значення jiffies з хендлера тасклету та з init функції при завершенні 
роботи модулю в лог відображаються всі значення таймеру які було занесено до масиву, відображається деоалокація масиву та виводиться значення я jiffies в кінці роботи.

Висновки
------------
в результаті роботи було створено свій модуль ядра, роботу та структуру якого описано вище, Jiffies в init та tasklet відрізняються,
тому що від початку ініціалізації і до ``botom half`` де і запускається хендлер тасклету прохходить багато часу,  GFP_KERNEL використовується чререз те 
що ми алокуємо пам'ять в процеісі а не в скедюалері тобто можемо дати можливість процесу поспати чекаючи звільнення простору для алокації пам'яті. використання данного флагу 
при алокації пам'яті в скедюалері може призвести до дедлоку. При delay рівним нулю таймер буде
відпрацьовувати з мінімальною затримкою, зазвичай це 1 такт.
