==========================
Звіт з лабораторної роботи №1
==========================
"Двупоточний лічильник"
________________________________________________

Завдання
~~~~~~~~~~
1. Налаштування плати:
	* Завантажити Debian Stretch на плату BeagleBoard через SD-карту.
	* Виставити IP-адресу  192.168.7.1/24.
	* Підключитися до плати по SSH.

2. Написати програму, яка інкрементує змінну в 2 потоки, кількість ікрементацій вказано в аргументах виклику програми. 
   Для реалізації многопоточності необхідно використовувати бібліотеку ``pthread``.
   Програму зібрати з флагами ``-O0`` та ``-O2``.
   Перевірити оба варіанта на платі та на комп’ютері (архітектура *X86*).

Опис програми
~~~~~~~~~~~~~~~~
*POSIX threads* є класичним засобом для реалізації багатопоточності на UNIX подібних системах, тому застосування даної бібліотеки є доцільним у даному проекті. У бібліотеці ``pthreads`` визначено типи даних, функції для багатопоточності та їх синхронізації. 

Змінна для ікрементації є зовнішньою, що дозволяє обом потокам інерементувати одну і ту ж змінну.

.. code-block:: C

	int global_inc = 0;

Функція ``main`` приймає на вхід аргументи виклику програми та їхня кількість. 
Першим аргументом виступає назва програми, у другому вказується число, до якого введеться інкрементація.

Спочатку виконується перевірка на кількість аргуменів та правильність вказання.

.. code-block:: C

        if (argc != 2) {
                printf("Error: Incorrect number of arguements\n");
                exit(1);
        }
	char *endptr;
	
        limitcount = strtol(argv[1], &endptr, 10);

        if (*endptr != '\0') {
                printf("Error: arguement could be anything except digit.\n");
                exit(EXIT_FAILURE);
        }

Якщо чисельний аргумент вказано правильно, то за адресою ``endptr`` зберігається символ кінця рядку ``\0``.

Для створення потоків необхідно створити змінні потоків:

.. code-block:: C
 
	pthread_t thread0, thread1;

Далі необхідно створити потоки

.. code-block:: C

	pthread_create(&thread0, NULL, &global_increment, &limitcount);
        pthread_create(&thread1, NULL, &global_increment, &limitcount);
	

У функції ``global_increment`` виконується цикл, що інкрементує значення глобальної переміної. Опис функції наведенно нижче.

.. code-block:: C

	void *global_increment(void *limitcount)
	{
        	int limit = *((int*)limitcount);

        	for (int i = 0; i < limit; i++) {
                	global_inc++;
        	}

        	pthread_exit(0);
	}

Аргумент ``limitcount`` має тип ``void *``. Цей тип є унверсальним посиланням, але потрбіно вказати тип посилання при зчитуванні даних за посиланням.

.. code-block:: C

        int limit = *((int*)limitcount);

Оскільки в змінну ``global_inc`` вже було записано ``0`` при декларації, необхідність записати повторно в тілі функції відпадає.
Далі йде інкрементація змінної ``limit`` разів.

.. code-block:: C

        for (int i = 0; i < limit; i++) {
                global_inc++;
        }

Функція ``pthread_exit`` завершує роботу потока.

.. code-block:: C

        	pthread_exit(0);

Для очікування завершення роботи потоків у функціх ``main`` використовується функція ``pthread_join``.

.. code-block:: C

	pthread_join(thread0,NULL);
	pthread_join(thread1,NULL);

Оскільки ``retval`` присвоюється ``NULL``, то функція не повертає статус завершення потоку, вказаного в ``pthread_exit``.

Для відсідження часу виконання використовується бібліотека ``time``.

Для зберігання часу початку та кінця виконання використовуються змінні ``time_begin``, ``time_end``.
Фунуція ``clock`` повертає кількість тіків від початку виконання програми.

.. code-block:: C
	
	        clock_t time_begin = clock();
		...
		time_t time_end = clock();

Час виконання в мікросекундах визначаєтсья за формулою ``(time_end-time_begin)/(CLOCKS_PER_SEC/1000000)``.
``CLOCKS_PER_SEC`` це константа, яка рівна кількості тіків за секунду.


Для виводу даного значення використовується функція ``printf``.

.. code-block:: C

        printf("Time spent for counting using 2 cores:\n%li us\nCounted value is:\n%i\n",
        (time_end-time_begin)/(CLOCKS_PER_SEC/1000000), global_inc);


Повний код знаходиться в директорії **src**.

Зборка
~~~~~~~~~~~

Для зборки використовувася *MakeFile*.
**Makefile** - це файл з інструкціями для програми make, яка допомагає зібрати програмний проект.

Використовуються різні флаги оптимізації *O0* та *O2*.
*O0* виключає всі можливі оптимізації для швидкого компілювання.
*O2* включає майже всі оптимізації, але час компіляції більше.

При компіляції написаної програми з флагом ``-O0`` зберігається цикл з інкрементацією змінної ``inc`` ``limit`` разів.
При компіляції написаної програми з флагом ``-O2`` в змінну ``inc`` записується значення змінної ``limit`` помножене на *2*.



.. code-block::

	CFLAGS = -c -Wall -std=c11 -O0 -save-temps -Werror -lpthread
 
де

	* ``-O0`` - флаг оптиміції. Цей флаг означає відключення оптимізації, і основна ціль являю собою високу шкидкість компіляції;
 	* ``-O2`` - флаг оптимізації (використовується також в цьому файлі але пізніше), включає майже всі доступні оптимізації;
	* ``-save-temps`` - флаг для перегляду асемблерських листів;
	* ``-lpthread`` - для того, щоб підключити бібліотеку Pthread до програми.


Програма запускаєтсья на архітектурі *х86* та на платі з різними флагами оптимізаціями. 

**Результати:**

.. list-table:: **х86**

	* - Число інкрементацій в потоці
	  - 100
	  - 10000
	  - 1000000
	* - Результат лічильника з O0
	  - 200
	  - 20000
	  - 1010556
	* - Результат лічильника з O2
	  - 200
	  - 19182
	  - 2000000

Таблиця 1.

**Висновок з результатів**

Різниця чисел для ``O0`` та ``O2`` обумовлена тим, що для ``O0`` інкрементація змінної в двух потоках була не синхронізованою. При оптимізації ``O2`` в змінну відразу записується значення, яке теоретично повинно бути в ньому після завершення інкрементацій. Це значення змінної ``limit``, помножене на *2*. Тобто в ``O0`` виконувалась інкрементація змінної без синхронізації потоків, а в ``O2`` виконувалось присвоєння теоретично розрахованого значення компілятором.

**Висновок**

Під час виконання даної лабораторної роботи було проведено ознайомлення з плвтою BiggleBoard, яка працює під Debian Stretch. На плату було завантажено даний дистрибутив, а також налаштовано IP-адресу та під'днано до комп'ютера по SSH. 
Потім необхідно було написати программу під linux для лічення змінної в два потоки, вказаним при виклику раз. Дану програму необхідно було зібрати з різними флагами опптимізації для порівняння. Результати наведені в Таблиці 1.
Отже завдання на дану лабораторну роботу було виконано.
