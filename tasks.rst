==============================
Задания на лабораторные работы
==============================

ЛР 1: Первое Embedded-приложение
--------------------------------

Название директории ЛР: ``lab1_first_embedded_app``

#. Ознакомиться с `Reference Manual BBXM <https://github.com/beagleboard/beagleboard-xm>`__.
   Это референсный документ, нет необходимости читать его от корки до корки. Вместо этого, стоит обращаться к конкретным
   интересующим топикам.

#. Выкачать последний оффициальный Debian Stretch for BeagleBoard образ с https://beagleboard.org/latest-images

#. Разархивировать и записать на SD-карту
   
   **Внимание**: команда ``dd``, запущенная с привилегиями, берет и пишет.
   Если указать ``of=``, скажем ``/dev/sda`` – винчестер будет испорчен. Перед
   запуском стоит посмотреть вывод ``ls /dev`` и убедиться, что назначение действительно
   указано верно.
   
   .. code-block::
     
     sudo sh -c "xz --decompress --keep --stdout bbxm-debian.img.xz | dd status=progress bs=4M of=/dev/mmcblk1; sync"
   
   Процесс занимает порядка 5..10 минут.
   
   *Контрольные вопросы*:
   
   - Что делает оператор ``|``? Привести пример аналогичной команды без его использования. В чем будет её недостаток?
   - Что содержит ``/dev`` и какой принцип энумерации у блочных устройств Linux?
   - Как работает указанная выше команда? Что значит каждый из флагов и операторов?

#. Подключиться RS-232 шнуром к плате. Открыть терминал с настройками 
   `115200 8/N/1 <https://en.wikipedia.org/wiki/Serial_port#Conventional_notation>`__
   
   *Внимание*: RS-232 – старый интерфейс, он не поддерживает горячее подключение. Поэтому, предварительно необходимо отключать
   питание устройства перед каждым подключением/отключением RS-232.

#. Вставить SD-карту в BBXM и подключить питание
   
   *Важно*: в момент когда плата работает, файловая система подмонтирована, к ней происходят регулярные
   обращения. Например, пишутся логи. Поэтому отключать питание платы выдергиванием шнура не рекомендуется –
   возможно повреждение файловой системы. Она, конечно, является журналируемой и может восстановиться с практически
   стопроцентной вероятностью после любого сбоя питания. Тем не менее, это может потребовать запуска проверки файловой
   системы, что является накладным (аналогией можно считать регулярное завершение работы десктопного ПК зажатием кнопки питания).
   Хорошей практикой является завершение работы командами ``shutdown now``, ``poweroff -p`` и подобными.

   *Контрольные вопросы*:
   
   - Что можно наблюдать в терминале? Почему использование последовательного интерфейса оправдано?
   - Каково назначение светодиодов на плате в конфигурации по-умолчанию?

#. На данном этапе RS-232 больше не требуется, поскольку плата BBXM имеет USB OTG, а используемый дистрибутив
   реализует Ethernet over USB. Отключите питание платы, отключите RS-232 шнур и подключите miniUSB **в OTG**
   разъём платы. Включите питание.
   
   
   Убедитесь, что софтверный USB-хаб *ID 1d6b:0104 Linux Foundation Multifunction Composite Gadget* присутствует в выводе
   ``lsusb`` и соответствующий сетевой интерфейс был распознан и добавлен (в выводе ``ip``).
   
   .. code-block::
     
     lsusb
     ip link show

   Добавьте `правила udev из mkudevrule.sh <https://beagleboard.org/getting-started#troubleshooting>`__, следуя инструкциям.

#. Дистрибутив BBXM реализует DHCP-сервер. При подключении сетевого интерфейса, компьютер должен сам получить IP-адрес по
   DHCP. Если этого не происходит, можно выставить IP-адрес вручную (192.168.6.1/24 или 192.168.7.1/24).

   Проверить, что сетевые пакеты доходят нормально

   .. code-block::
     
     ping 192.168.6.2
   
   или
   
   .. code-block::
     
     ping 192.168.7.2
   
   После чего отключить компьютер от интернета и в браузере вбить соответствующий IP-адрес BBXM. Должна открыться
   страница встроенного веб-сервера.

   *Контрольные вопросы*:
   
   - Чем USB Host отличается от USB OTG?
   - Как работает Ethernet over USB BBXM?
   - Для чего необходимо добавление правил udev? Объяснить содержимое файла
     `mkudevrule.sh <https://beagleboard.org/static/Drivers/Linux/FTDI/mkudevrule.sh>`__

#. Подключиться к BBXM по ssh. По-умолчанию логин – ``debian``, пароль – ``temppwd``
   
   .. code-block::
     
     ssh debian@192.168.6.2
   
   Для получения root-доступа, можно использовать ``sudo su``. Тем не менее, **настоятельно не рекомендуется**
   работать от имени *root*, предпочтительным способом является выполнение отдельных привелегированных 
   команд, используя ``sudo``.

   *Контрольные вопросы*:
   
   - Какая версия ядра запущена на BBXM? Что необходимо сделать, что бы её посмотреть?
   - Какие демоны и сервисы запущены? Как это посмотреть?
   - Какой объём оперативной памяти свободен на данном этапе? Как это посмотреть?
   - Предложить варианты освобождения оперативной памяти
   - Как изменить пароль по-умолчанию на пользовательский?
   
#. Написать программу, которая:
   
   - Содержит глобальную переменную (изначально инициализируется значением ``0``);
   - Запускает два потока pthread
   - Каждый поток в цикле инкрементирует значение глобальной переменной 100 000 000 раз
   - Дожидается завершения потоков, используя ``join``
   - Выводит итоговое значение глобальной переменной в *stdout*
   
   На всякий случай, хотя это очевидно:
   
   - не нужно делать две абсолютно одинаковых функции реализующих поток, одной хватит
   - потоки нужно запустить работать одновременно, а не по-очереди
   - переменная инкрементируется именно именно 100 000 000 **раз**, а не до 100 000 000
   - при бездумном использовании *ctrl+c* *ctrl+v*, ошибки множатся, а качество декомпозиции падает
   
#. Написать *Makefile*, собрать программу с флагами ``-O0`` и ``-O2`` на **x86** и **BBXM**.
   Многократно запустить. Проанализировать, сравнить, дать объяснение полученным результатам.
   
#. Сделать выводы по работе

Некоторые рекомендации:

Для переноса файлов можно использовать ``scp``. Более того, можно подмонтировать директорию по ``ssh`` с использованием
``sshfs`` — так будет в разы удобнее работать.

Для поиска информации именно по BBXM, что бы поисковик не подсовывал результаты по BeagleBone, можно использовать
следующую строку поиска (Google): ``-beaglebone "beageboard" ......``


ЛР 2: Написание простейших модулей ядра
---------------------------------------

Название директории ЛР: ``lab2_simplest_kernel_modules``

Модули ядра в embedded-системах
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*Для чего применяются кастомные модули ядра в embedded?* —Простой, но не полный ответ: для использования периферии. 
Embedded-системы, в отличии от десктопных и серверных машин, являются узкоспециализированными и существенно отличаются
от задачи к задаче.

В качестве типичного примера можно взять коммерческое устройство – "умный" холодильник.
С точки зрения пользователя, это выглядит как холодильник с большой (а с учетом современных тенденций – огромной)
сенсорной панелью, на которой запущен Android, есть набор стандартных приложений (управление температурой и энергопотреблением,
рукописные заметки, приложения новостей, YouTube и так далее). С точки зрения системной архитектуры на выском уровне,
это набор оборудования холодильника, смарт-панель и интерфейс между ними.

Управление силовыми агрегатами прибора (компрессор, тен, ...) может осуществляться отдельной платой контроля, на которой наверняка
будет установлен свой микроконтроллер с RTOS. Смарт-панель будет связываться с этой платой контроля по какому-нибудь интерфейсу,
посылать команды управления и получать данные о работе. Смарт-панель может также использовать набор датчиков, не входящих
в состав *платы контроля* (например, 1-wire датчик температуры, I2C датчик освещенности, SPI АЦП с подключенным микрофоном
и так далее). Все это вопросы архитектуры, в которые сейчас не стоит углубляться. Главное – сама концепция.

А концепция в следующем. "Каноническая" embedded-система состоит из микропроцессора и набора связанной с ним периферии,
к которой необходимо иметь интерфейс. 




*Так зачем писать модули ядра, если многие задачи можно решать в userspace?* —А они и решаются. Действительно, за последние
десятилетия сообщество хорошо потрудилось, для того что бы расширить объём возможного из userspace (например, с использованием
``ioctl`` и ``mmap``, о которых мы поговорим позже).
Более того, в IT все крутится вокруг code reuse и создавая современную embedded систему, большая часть компонентов ядра
и системы в целом уже доступна. И основная часть времени уходит на внесение небольших исправлений, адаптацию этих компонентов
к решаемой задаче, интеграцию и тестирование, как это все работает вместе. Тем не менее:

- для того, что бы работать с имеющимися модулями ядра, необходимо понимать как они устроены
- и все равно, без написания кастомных модулей ядра не обойтись
- очень многие задачи проще, правильнее и удобнее решать именно в пространстве ядра

Другими словами, к вопросу "зачем модули ядра, если есть юзерспейс" можно подойти так: если код все равно писать, и проще и
правильнее именно в пространстве ядра, то зачем тратить время на решение задачи в юзерспейсе.

**И конечно**, это не значит, что "или юзерспейс, или пространство ядра". В большинстве случаев, модуль ядра реализует
интерфейс, который затем используется из юзерспейса.

На деле вопрос оказывается не таким простым. В реальных коммерческих проектах много времени уделяется именно архитектуре и
решаемая задача разбивается на user space- и kernel space-части, где отдельные команды работают, каждая над своими подзадачами.



*Вывод*: умение работать с модулями ядра крайне важно. Особенно сейчас. Смартфоны, бортовые компьютеры автомобилей,
роутеры, промышленные контроллеры, фитнесс-браслеты, планшеты, принтеры, бытовая техника, микшерные пульты, видеокамеры,
медицинское оборудование, ...

Рыночная тенденция в том, что смарт-устройство продается **на порядок лучше**, чем не смарт. Значит потребность
в специалистах будет только расти.


Ключевые особенности и отличия модулей ядра
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Модули ядра, как следует из названия, работают в пространстве ядра. Ядро Linux – монолитное, модульное.
Особенности:

- Являются привелегированными по отношению к юзерспейс-приложениям. Бесконечный цикл или ожидание освобождения
  ресурса в цикле могут запросто повесить всю систему (не многоядерную или без preemption, о котором поговорим
  позже) или заставить ее работать очень медленно. Поэтому модули ядра должны быть быстрыми. Особое внимание
  уделяется возможности/невозможности deadlock, о которых несколько позже

- Модули ядра не содержат ``main()`` и не выполняются линейно. При подключении модуля, он линкуется к ядру и
  запускается функция инициализации модуля. Эта функция выполняет необходимые инициализации и **завершается,
  модуль продолжает работать**

- Модули ядра не используют стандартных библиотек и соответствующих вызовов. Нет, при желании использовать можно
  (ядро имеет доступ ко всему), но это выглядит иначе, чем в юзерспейс-приложениях

- Следствие из предыдущего пункта: ``printf`` (а также другие плюшки из стандартных библиотек) недоступны.
  Вместо ``printf`` чаще всего используют `printk <https://www.kernel.org/doc/html/v4.16/core-api/printk-formats.html>`__
  и `его друзей <https://www.kernel.org/doc/html/v4.16/core-api/kernel-api.html?highlight=print#basic-c-library-functions>`__

- Не могут просто так работать с числами с плавающей запятой. Это связано с особенностями FPU. Когда работает
  юзерспейс-приложение, возможность работать FPU ему предоставляет ядро как данность. При работе в kernel space,
  модуль должен самостоятельно обеспечить доступность FPU на время проведения транзакции.
  
  *Но есть один нюанс*: модули ядра должны быть быстрыми. Разработчики стараются всеми возможными способами
  избежать задержек, связанных с использованием FPU. Например, при помощи fixed point арифметики. Также модуль
  ядра может использовать ``float`` при условии его **софтверной** реализации (что чаще всего, но не всегда,
  не эффективно). Конечно, при необходимости, можно выполнить операцию и на FPU (и это тоже используется)

- Не освобождают ресурсы автоматически. Все выделенные ресурсы должны освобождаться вручную. При этом, важно предусмотреть
  нормальную отработку ситуаций, когда на этапе выделения определенного ресурса возникает ошибка

- Могут прерываться, и делают это чаще многопоточных userspace-приложений. При написании кода следует уделять этому особое
  внимание, задумываясь, а что будет, если между двумя идущими друг за дружкой инструкциями произойдет передача управления


Пример модуля ядра
~~~~~~~~~~~~~~~~~~

В директории `demo/lab1 <demo/lab1>`__ находится пример `firstmod.c <demo/lab1/firstmod.c>`__,
демонстрирующий базовую структуру модуля ядра.
Модуль выводит приветственное и прощальное сообщение, а какже текущее значение ``jiffies``. 


*... в процессе написания ...*

.. code:: C
  
  static int __init firstmod_init(void)
  {
  	printk(KERN_INFO "Hello, $username!\njiffies = %lu\n", jiffies);
  	return 0;
  }

.. code:: C
  
  module_init(firstmod_init);
  module_exit(firstmod_exit);

.. code:: C
  
  MODULE_LICENSE("Dual MIT/GPL");		// this affects the kernel behavior


Сборка модулей ядра
~~~~~~~~~~~~~~~~~~~

Модули ядра собираются Kbuild, которая *чуть менее, чем полностью* основана на использовании
возможностей *make*.

В директории `demo/lab1 <demo/lab1>`__ находится пример `Makefile <demo/lab1/Makefile>`__,
собирающего модуль ядра.


*.. со временем тут появится более детальное описание ..*


Загрузка, выгрузка модулей ядра и некоторые аспекты работы с ними
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- В общем случае, модули могут зависеть друг от друга и должны загружаться в порядке, разрешающем
  зависимости между ними. Например, так делает ``modprobe``. Мы пока не затрагиваем этих аспектов
  и будем загружать и выгружать модули вручную
  
- Список загруженных в данный момент модулей можно посмотреть, используя:
  
  .. code::
  
    lsmod

  Для поиска удобно использовать ``grep``:
  
  .. code::
  
    lsmod | grep part-of-module-name

- Информацию о модуле можно посмотреть, натравив ``modinfo`` на файл модуля ядра:
  
  .. code::
  
    modinfo ./firstmod.ko

  Пример вывода:
  
  .. code::
  
    debian@beagleboard:~/kmod$ modinfo firstmod.ko
    filename:       /home/debian/kmod/firstmod.ko
    license:        Dual MIT/GPL
    version:        0.1
    author:         thodnev
    description:    Basic module demo: init, deinit, printk, jiffies
    srcversion:     E36B5885188779177077932
    depends:        
    name:           firstmod
    vermagic:       4.18.11-armv7-x11 SMP preempt mod_unload modversions ARMv7 p2v8 

- Модуль можно загрузить следующим образом:
  
  .. code::
  
    insmod modulename.ko

  (требует root-привелегий)
  
  При загрузке модулю можно передавать аргументы. Более подробно в ``man insmod`` и в документации
  `вот тут <https://www.tldp.org/LDP/lkmpg/2.6/html/x323.html>`__
  
- Модуль можно выгрузить следующим образом:
  
  .. code::
  
    rmmod modulename

  (требует root-привелегий)
  
- Лог ядра можно посмотреть, используя ``dmesg``:

  .. code::
  
    dmesg -k

  (требует root-привелегий)
  
  Что бы не прокручивать весь лог, можно использовать ``tail -N``, где *N* – количество **строк**:
  
  .. code::
  
    sudo dmesg -k | tail -20


Задание на лабораторную работу
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. Перенести на плату и установить заголовки ядра
   
   Первым делом, необходимо посмотреть версию ядра, выполнив ``uname -r``
   
   На плате используется дистрибутив на основе Debian, использующий apt. В частности, можно заглянуть в 
   ``/etc/apt/sources.list`` и увидеть указание на репозиторий, содержащий заголовки ядра (и чуть выше —
   ссылку на исходники):
   
   .. code::
   
     #Kernel source (repos.rcn-ee.com) : https://github.com/RobertCNelson/linux-stable-rcn-ee
     #
     #git clone https://github.com/RobertCNelson/linux-stable-rcn-ee
     #cd ./linux-stable-rcn-ee
     #git checkout `uname -r` -b tmp
     #
     deb [arch=armhf] http://repos.rcn-ee.com/debian/ stretch main
     #deb-src [arch=armhf] http://repos.rcn-ee.com/debian/ stretch main

   Нас будет интересовать последняя не закомментированная строка. Как можно видеть, дистрибутив собран на основе
   Debian Stretch. Необходимо открыть браузер и перейти по указанному URL. Веб-сервер, обслуживающий репозиторий,
   отобразит его внутреннюю структуру. `Вот тут <https://wiki.debian.org/DebianRepository/Format>`__
   можно более детально почитать о структуре apt-репозиториев (а можно не читать, нас репозиторий интересует в чисто
   утилитарных целях).
   
   Сами пакеты лежат в `pool/main <http://repos.rcn-ee.com/debian/pool/main>`__, но не все так просто. Дело в том,
   что пакетов очень много. Веб-сервер, пытаясь сгенерировать содержимое директории, прервет соединение по таймауту.
   Сам apt (как и другие менеджеры пакетов) работает с репозиторием, используя индекс. В данном случае, придется
   проделать эти действия вручную, залезть в индекс и посмотреть точное название интересующего нас пакета.
   
   Переходим в `dists/stretch/main <http://repos.rcn-ee.com/debian/dists/stretch/main>`__. Как можно увидеть,
   выполнив ``uname -a``, используется архитектура *armhf*. Переходим в соответсвтвующую директорию в репозитории
   пакетов. Файл ``Packages`` содержит индекс пакетов. В нем необходимо найти интересующий нас пакет *linux-headers*
   для той версии ядра, которая запущена на плате:
   
   .. code::
   
     Package: linux-headers-4.18.11-armv7-x11
     ....

   (Может отличаться. Конкретную версию можно узнать из ``uname -r``)
   
   В строке ниже будет указано название файла в репозитории и контрольные суммы:
   
   .. code::
   
     Filename: pool/main/l/linux-upstream/linux-headers-4.18.11-armv7-x11_1stretch_armhf.deb
     ....
     SHA256: 00201c1172d0d6ceb3d4080c82a93c16fc9a23aee59d5292ff5682cb59e63a94

   Переходим по указанному пути и скачиваем пакет из репозитория. Проверяем контрольную сумму.
   
   
   Далее пакет заголовков ядра необходимо перебросить на плату (можно использовать ``scp`` или ``sshfs``) и установить:

   .. code::
   
     sudo dpkg -i ./linux-headers-4.18.11-armv7-x11_1stretch_armhf.deb
   
   *Примечание*: сами по себе, заголовки в распакованном виде не занимают много места (~60 MB), но состоят из множества
   файлов. Как известно, SD-карты обычно медленно отрабатывают операции со множеством файлов. Если кажется, что
   все зависло – вероятно это не так.

#. Собрать модуль ядра из примера выше на **x86** и **BBXM**. После каждого подключения и отключения модля к ядру смотреть
   логи ядра (лучше всего, с использованием ``dmesg``)
   
#. Взять секундомер. Засечь время между двумя включениями модуля на **x86** и **BBXM**. Взять соответствующие значения
   ``jiffies`` из логов. Зависит ли разница в двух значениях ``jiffies`` от платформы? Почему? Обоснование включить в протокол.
   
   Экспериментально рассчитать время (в миллисекундах), равное 1 ``jiffies``.
   Сравнить с `теоретическим <https://stackoverflow.com/a/57879202/5750172>`__ значением.
   Результаты включить в протокол по работе.
   
   .. TODO: improve quality of the below
   
#. Внести исправления в модуль из примера, что бы вместо ``username``, выводилось имя, переданное в качестве параметра модуля
   при его подключении ``insmod``
   
   *Примечание*: Параметр должен иметь описание `MODULE_PARM_DESC <https://www.tldp.org/LDP/lkmpg/2.6/html/x323.html>`__
   
#. Изучить материалы по работе с тасклетами, особенностям ``jiffies`` (а также материалы INOB, выдаванные преподавателем)

#. Добавить в *init* полученного модуля ядра тасклет, который также выведет текущее значение ``jiffies``

#. Объяснить, почему разница между двумя выводимыми ``jiffies`` (в *init* и в тасклете) может быть равна 0, 1 или 2

.. TODO: add questions


ЛР 3: Потоки ядра, примитивы синхронизации
------------------------------------------

Название директории ЛР: ``lab3_kernel_threads``


#. Изучить принципы работы со списками в ядре, потоки и механизмы синхронизации

#. Написать модуль ядра, который:
   
   - содержит переменную
   - запускает *M* потоков на одновременное выполнение
   - каждый поток инкрементирует переменную *N* раз, кладет значение переменной в список и завершается
   - при выгрузке модуль выводит значение переменной и содержимое списка
   - использовать параметры модуля для задания инкремента *N* и количества потоков *M*
     (в коде параметры должны называться осмысленно)
   - для переменной, списка, потоков использовать динамическую аллокацию. Переменную передавать в поток по ссылке аргументом

#. Проверить на **x86** и **BBXM**. Продемонстрировать, что без синхронизации итоговое значение глобальной
   переменной неправильное

#. Реализовать функции ``lock()`` и ``unlock()`` с использованием атомарных операций ядра (``atomic.h``, отличается
   в зависимости от архитектуры). Предусмотреть возможность работы как на x86, так и на BBXM (например, можно 
   использовать макроопределения ядра для условной компиляции).
   Продемонстрировать работоспособность.

#. Защитить доступ к шареным элементам (список тоже к ним относится).
   Продемонстрировать правильность работы на **x86** и **BBXM**

#. Необходимо учитывать и корректно отрабатывать возможные ошибки. Например, ``kmalloc`` может не выделить память.
   При ошибке ресурсы должны деаллоцироваться в порядке обратном аллокации (можно использовать ``goto`` или
   битовое поле с флагами), а в лог ядра выводится ошибка (``KERN_ERR`` или другой подобный уровень лога, но не 
   ``KERN_INFO``)

#. Все промежуточные результаты описать и включить в отчет
