Лабораторна робота № 2
======================

``Тема``: Написання найпростіших модулів ядра
++++++++++++++++++++++++++++++++++++++++++++

``Мета``: Використовуючи мову програмування С, розробити та проаналізувати роботу програми, яка запускає виконання модулів ядра на платформах x86 та BBXM
++++

``Завдання``:
++++

1. Перенести і встановити на плату заголовки ядра
2. Зібрати модуль ядра з прикладу на архітектурах x86 и BBXM. Після кожного увімкнення та вимкнення необхідно переглядати логи ядра (використовуючи команду dmesg)
3. Необхідно взяти секундомір. Засікти час між двома включеннями модуля на  x86 и BBXM. Відповідні значення ``jiffies`` взяти з логів. Чи буде залежати від платформи різниця між двома значеннями jiffies. Чому? Обґрунтування включити в протокол.
4. Експериментально розрахувати час (в мілісекундах), який дорівнює 1 ``jiffies``. Результати додати в протокол по роботі.


``Хід роботи``:
++++

У ході виконання лабораторної роботи було написано програму, яка демонструє роботу найпростішого модуля ядра. 
В результаті виконання даної програми, модуль виводить на екран ім'я, яке передається в якості параметра модуля при його 
підключенні за допомогою команди ``insmod``. Крім цього, на екран виводиться значення змінної ``jiffies``, 
яка містить кількість імпульсів системного таймера, які були отримані, починаючи з часу запуску системи.
Також на екран виводиться значення цієї ж самої змінної ``jiffies``, пропущеної через ``tasklet`` - який є чимось подібним 
до маленького потоку, що не має ні власного стеку, ні контексту. Детальніше про ``tasklet'и`` можна почитати за 
`посиланням <https://habr.com/ru/company/embox/blog/244071/>`_.
Для можливості використання ``tasklet'ів`` у програмі треба додати бібліотеку ``linux/interrupt.h``. 
Такі бібліотеки, як ``linux/module.h``, ``linux/kernel.h``, ``linux/init.h`` необхідні для написання будь-якого модуля.
Бібліотека ``linux/jiffies.h`` містить у собі дані про ``jiffies``, та їх використання.
Компіляція програми буде виконуватися за допомогою ``Makefile``.
Весь етап компіляції програми, включно з очищенням результатів роботи програми матиме наступний вигляд:
::

  ~$ make
  ~$ sudo insmod src/firstmod.ko entered_string="Enter name, that equals to parameter of the module"
  ~$ sudo dmesg -k | tail -4
  ~$ sudo sudo rmmod src/firstmod.ko
  ~$ make tidy
  ~$ clear

1. В результаті виконання першого завдання даної лабораторної роботи (модуль виводить на екран ім'я, 
яке передається в якості параметра модуля при його підключенні за допомогою команди ``insmod``, а також значення змінної ``jiffies``), 
отримали такі результати (Рис.1, 2): 

    .. image:: img/username_x86_before_timer.png

Рисунок 1. Результати виконання програми на ``x86`` до запуску таймера

Як можна бачити на рисунку 1, програма коректно виконує поставлену ціль на ``x86``, і виводить набір символів, 
введений при підключенні модуля, в якості параметра модуля. Також програма виводить значення змінної ``jiffies``, 
результати якої будуть проаналізовані нижче, при отриманні результатів виконання цієї ж програми на ``x86`` через 10 хвилин.

    .. image:: img/username_bbxm.png

Рисунок 2. Результати виконання програми на ``bbxm`` до запуску таймера

На рисунку 2 можемо спостерігати результати виконання програми на ``bbxm``. Можна зробити висновок, 
що програма коректно виконує своє призначення на обох архітектурах.Також програма виводить значення змінної ``jiffies``, 
результати якої будуть проаналізовані пізніше, при отриманні результатів виконання цієї ж програми через 10 хвилин на платі ``bbxm`` 
(результати будуть внесені до звіту окремим коммітом).

Як можна бачити на рисунку 3, в результаті виконання програми після запуску таймера на ``x86`` (на 10 хвилин), 
отримали такі результати: 

    .. image:: img/username_x86_after_timer.png
    
Рисунок 3. Результати виконання програми на ``x86`` після запуску таймера

Тепер проведемо деякі розрахунки. Отримане значення змінної ``jiffies`` після закінчення рахунку таймера віднімемо від 
значення змінної ``jiffies`` до початку рахунку. Маємо:
::

  jiffies_before_count = 4313756025
  jiffie_after_count = 4313943274
  jiffies_differnce = jiffie_after_count - jiffies_before_count = 4313943274 - 4313756025 = 187249

Тепер можемо перевести отримане значення ``jiffies_difference`` у число в секундах ``seconds``, використовуючи формулу:
::

  seconds = jiffies_difference / HZ

В цій формулі значення ``HZ`` - це константа ядра платформи (у нашому випадку це платформа x86), 
яка визначає кількість імпульсів системного таймера ``jiffies``. Відповідно, 
для платформи x86 значення константи HZ дорівнює 300. Для більш детальної інформації про системний таймер, 
``jiffies``, ``HZ``, звертатися за `посиланням <http://man7.org/linux/man-pages/man7/time.7.html>`_.

Отже, використовуючи попередню формулу, маємо:
::

  seconds = jiffies_difference / HZ = 187249 / 300 = 624 с.

Аналізуючи  значення ``seconds = 624 с``, можна сказати, що у розрахунках присутня похибка, 
оскільки таймер був запущений на 10 хв, тобто 600 с. Це означає, що значення ``seconds`` повинно становити 600 с, 
а не 624 с. Похибку можна пояснити тим, що виконання команд, які необхідні для повної компіляції, 
та декомпіляції програми, потребує певного часу, який і становить ці 24 секунди. Враховуючи, що похибка становить ~4% 
від еталонного часу, результати можна вважати задовільними.


В результаті виконання програми після запуску таймера на ``bbxm``(на 10 хвилин), отримали такі результати:
::

  Аналіз результатів для ``bbxm`` будуть доповнені окремим коммітом впродовж деклькох днів.

Експериментальний розрахунок часу (в мілісекундах), який дорівнює ``1 jiffies``
++++

Для переведення значення змінної ``jiffies`` в мілісекунди використовують наступну формулу:
::

  miliseconds = (jiffies * 1000) / HZ

``HZ`` - це константа ядра платформи (у нашому випадку це платформа x86), 
яка визначає кількість імпульсів системного таймера ``jiffies``. Для платформи x86 значення константи HZ дорівнює 300. 
Число 1000 - множник, який дозволяє перевести час у секундах в мілісекунди.
Тепер, маючи необхідні дані, проведемо розрахунок. Отримаємо:
::

  miliseconds = (jiffies * 1000) / HZ = 1 * 1000 / 300 = 3 мс.
  
Отже, шляхом розрахунків, отримали, що для платформи ``x86`` ``1 jiffies`` чисельно дорівнює ``3 мс``.

2. В результаті виконання другого завдання даної лабораторної роботи (виведення програмою  змінної ``jiffies`` використовуючи ``tasklet``), 
отримали такі результати на платформі ``x86`` (Рис.5): 

    .. image:: img/username_x86_tasklet.png

Рисунок 5. Результати виконання програми з ``tasklet'ом`` на ``x86``

Аналізуючи виконання програми на платформі x86, бачимо, що результат виводу програмою змінної ``jiffies`` є однаковим 
як для макросу ``__init``, так і для функції ``func(jiffies)``. Це співпадіння можна пояснити тим, 
що виконання обох процесів, і вивід результатів цих процесів були проведені майже одночасно. Також
можна сказати, що ``tasklet`` є такою собі спрощеною версією потоку, який виконує свою функцію без затримок, і дуже швидко, 
чим і пояснюється показаний результат. Однак, ``tasklet'и`` виконуються по принципу невитісняючого планування, 
тобто один за одним, в порядку черги. Їх можна планувати з двома різними пріоритетами: ``normal`` и ``high``. 
Тобто, якщо ми створимо ще один ``tasklet``, але з вищим пріоритетом, ніж у теперішнього ``tasklet'а``, 
і виведемо значення обох ``tasklet'ів``, то побачимо, що ``tasklet`` з пріоритетом ``high`` співпадатиме зі значенням ``jiffies``,
а ``tasklet`` з пріоритетом ``normal`` матиме значення, трохи більше за значення ``jiffies`` та ``tasklet`` з пріоритетом ``high``, 
тобто процес його виконання завершиться трохи пізніше.

Результати та аналіз виконання другого завдання на платформі ``bbxm`` буде доданий впродовж наступних декількох днів окремим коммітом.

``Висновки``:
++++

В цій лабораторній роботі я написав модуль ядра, і спробував запустити його на мікрокомп'ютері. 
Порівнюючи результати роботи написаної програми на різних платформах, можна зробити висновок, 
що програма коректно виконує свою роботу на обох платформах. Також було обчислено відповідність ``1 jiffies`` мілісекундам. В результаті обрахунків вийшло, що ``1 jiffies`` - це ``3 мс``.

Отже, можна зробити висновок, що перший досвід роботи з модулями ядра, 
та їх запуском на одноплатному комп'ютері та на платформі x86 був успішним. 

