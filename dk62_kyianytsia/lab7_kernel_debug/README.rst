=====================
Лабораторна робота №7
=====================

**Завдання:**

* розібратися с ``debugfs``.

* додати до попередньої лабораторної роботи можливість зчитувати і писати в буфери за допомогою ``debugfs`` (при відкриванні файлу і аллкокації буффера, в debugfs створюється entry з іменем в виді адресу ``file``, вмістом в якості ``blob``).

* розібратися з відладкою модулів ядра засобами ``GDB``.

* спробувати відлагоджувати модуль ``hive`` засобами ``gdb`` на ядрі, запущеному в qemu.

* спробувати крашнути ядро, записати ``crash dump`` і потім дослідити його за допомогою ``crash`` (замість крашнути можна використати ``sysrq`` ).

-------------------------

**Теорія:**

``Debugfs`` існує як простий спосіб для розробників ядра збирати інформацію доступно для робочих просторів. На відміну від ``/proc`` , який призначений тільки для інформації про процес, або ``sysfs`` , який має суворі правила одне значення для файлу, У debugfs немає ніяких правил. Розробники можуть розмістити будь-яку інформацію, яку бажають.

``GDB`` , відладчик проекту ``GNU`` , дозволяє вам бачити, що відбувається "всередині" інший програми під час її виконання - або що інша програма робила в момент її збою.

``GDB`` може виконувати дії чотирьох основних типів, для того щоб допомогти виявити помилку:

* Почати виконання програми, перед цим задати все, що може вплинути на її поведінку;
* Зупинити програму при зазначених умовах;
* Дослідити, чому програма зупинилася;
* Змінити програму, так щоб була можливість експериментувати з усуненням ефектів однієї помилки і продовжити виявлення інших.

**Хід роботи:**

* Для початку необхідно підготувати ядро. Для цього переходимо за наступним посиланням та скачуємо тут ядро (було завантажено ``v.5.4.8`` ):
``https://www.kernel.org/``

* Далі за допомогою наступного гайду було зібрано ядро та створений userland для роботи в qemu:
``https://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html``

* Далі необхідно додати створений модуль з попередньої лабораторної роботи та додати його в папку drivers .

* Далі створюємо конфігураційний файл ``Kconfig``:

.. code-block::

  #
  # hivemod as part of kernel source
  #

  menu "hivemod Driver"

  config HIVEMOD
        tristate "hivemod module"
        default y
        help
  hivemod kernel module integrated as part of kernel source.

  endmenu

* та ``Makefile``:

.. code-block::

  obj-$(CONFIG_HIVEMOD) += hivemod.o
  MY_CFLAGS += -g -DDEBUG
  ccflags-y += ${MY_CFLAGS}
  CC += ${MY_CFLAGS}

  all:
  	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

  debug:
  	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules EXTRA_CFLAGS="$(MY_CFLAGS)"

  clean:
  	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean



* Наступним кроком є запуском середовища qemu. Тому для цього використовуємо наступну 
команду:

.. code-block::

  qemu-system-x86_64 -kernel obj/linux-x86-alldefconfig/arch/x86_64/boot/bzImage -initrd obj/initramfs-busybox-x86.cpio.gz -nographic -append "console=ttyS0 nokaslr" -enable-kvm -S -s

* Далі необхідно працювати з ``gdb``, тому для цього передаємо йому файл vmlinux, який відповідає ядру, яке збираємося дебажити.

* Далі під'єднуємо ``gdb`` до нашого ядра за допомогою наступної команди (налаштований порт 1234):

.. code-block::

  target remote localhost:1234

* Далі підключаємо даний модуль до ядра, тому в ``gdb`` прописуємо c , що запустить ядро в ``qemu``, після чого в ядрі викликаємо: 

.. code-block::

  insmod hivemod.ko

* Далі в папці ``sys/module/hivemod/sections`` вичитаємо значення наступних файлів, після чого отримуємо певний результат:

.. code-block::

  cat .text .data .bss


