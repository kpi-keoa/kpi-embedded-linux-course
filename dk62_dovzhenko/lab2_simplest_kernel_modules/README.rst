==========================
Звіт з лабораторної роботи
==========================
Лабораторна робота №2: "Написання простих модулей ядра"
________________________________________________

Зміст:
_____

#. `Теоретичні відомості`_ 
	#. `Вбудована система`_
	#. `Ядро`_
	#. `Jiffies`_
#. `Хід роботи`_   
	#. `Підготовка до виконання роботи`_
	#. `Завдання`_
	#. `Результат роботи`_
#. `Використана література`_
#. `Висновок`_

Теоретичні відомості
~~~~~~~~~~~~~~~~~~~~

Вбудована система
"""""""""""""""""

**Вбудована система (embedded system)** - спеціалізована мікропроцесорна система управління, контролю і моніторингу, концепція розробки якої полягає в тому, що така система буде працювати, будучи вбудованою безпосередньо в пристрій, яким вона керує. Така система призначена для виконання обмеженої кількості функцій, дивлячись на цей факт, розробники можуть її оптимізувати, зменшуючи вартість продукту, або збільшуючи надійність та швидкодію. Вбудовувані системи служать для управління пристроями, збору даних, контролю і моніторингу.

Ядро
""""

**Ядро** - це найнижчий рівень програмного забезпечення, яке взаємодіє з апаратними засобами комп'ютера. Воно відповідає за взаємодію всіх програм, які працють в просторі користувача аж до фізичного обладнання.
Більшість ядер можуть бути одного з трьох типів: 
		* монолітне ядро
		* мікроядро
		* гібрид 
Ядро Linux являє собою ``монолітне ядро``.
*Монолітні ядра* охоплюють не тільки процесор, пам'ять, але і включають в себе такі речі, як драйвери пристроїв, управління файловою системою, систему введення-виведення. Монолітні ядра дають кращий доступ до обладнання та реалізують кращу багатозадачність, тому що якщо програмі потрібно отримати інформацію з пам'яті або іншого процесу, їй не доведеться чекати в так званій черзі. Але це і може викликати деякі проблеми, тому що багато речей виконуються в режимі суперкористувача. І це може принести шкоду системі при неправильній поведінці.

  .. table::
  Плюси і мінуси такого ядра:

+-------------------------------------------+-----------------------------------+
| Плюси                                     | Мінуси                            |
+===========================================+===================================+
| Більш прямий доступ до апаратних засобів  | Більший розмір                    |
+------------+------------------------------+-----------------------------------+
| Простіше обмін даними між процесами       | Займає багато оперативної пам'яті |
+------------+------------------------------+-----------------------------------+
| Процеси реагують швидше                   | Менш безпечно                     |
+-------------------------------------------+-----------------------------------+


Також, один із недоліків такої архітектури є: неможливість установки нових драйверів без перезбирання ядра. Проте розробники знайшли рішення і цієї проблеми, *додавши систему модулів* .

Ядро Linux дозволяє драйверам обладнання, файлових систем, і деяким іншим компонентам бути скомпільованими **окремо - як модулі, а не як частина самого ядра**.

Jiffies
"""""""

Глобальна змінна ``jiffies`` містить в собі кількість імпульсів системного таймера, які були отримані з моменту заргузки системи. При загрузці ядро встановлює значення цього параметра в **0** і він збільшується на **1** при кожному перериванню системного таймера. Так як в секунду виникає HZ переривань системного таймера, то за одну секунду значення зміної ``jiffies`` збільшується на HZ.

**CONFIG_HZ** — це системний таймер, до якого прив'язаний лічильник ``jiffies``. Він незалежний від платформи.
Для перевірки його значення, використовуємо команду:

.. code-block::

  zcat /proc/config.gz | grep CONFIG_HZ

Хід роботи
~~~~~~~~~~

Підготовка до виконання роботи
""""""""""""""""""""""""""""""

Для початку роботи потрібно завантажити  приклад `firstmod.c <https://github.com/kpi-keoa/kpi-embedded-linux-course/blob/master/demo/lab1/firstmod.c>`_ який знаходиться в `demo/lab1 <https://github.com/kpi-keoa/kpi-embedded-linux-course/tree/master/demo/lab1>`_. Даний приклад
демонструє базову структуру ядра. В даній директорії також знаходиться  `Makefile <https://github.com/kpi-keoa/kpi-embedded-linux-course/blob/master/demo/lab1/Makefile>`_, який збирає модуль ядра.

Для **х86** було завантажено пакет заголовків: ``linux419-headers 4.19.69-1``, а для **BBXM** - ``linux-headers-4.18.11-armv7-x11_1stretch_armhf.deb``. 
Щоб безпомилково завантажити заголовки, потрібно перед цим дізнатися версію ядра на платформі, це можна виконати за допомогою команди:

.. code-block:: 

  uname -a

Після того, як завантажили потрібні пакети виконується ``Makefile``, що збирає модуль ядра. Після такої операції створюється вихідний код модуля 
``firstmod.ko``. Для того, щоб завантажити отриманий модуль, виконується

.. code-block:: 

	insmod modulename.ko

Відповідно для того, щоб вигрузити модуль:

.. code-block:: 

	rmmod modulename

Для того, щоб подивитися лог ядра, використовується команда

.. code-block:: 

	dmesg -k | tail -N

де ``tail -N`` - дозволяє подивитися **N** рядків лог ядра.
Описані вище **3** команди використовуються з ``root-прав``.

Завдання
""""""""

В даній лабораторній роботі, було завдання, таке як:
	 подправить модуль из примера, что бы вместо username, выводилось имя, переданное в качестве параметра модуля при его подключении ``insmod`` [1]_.

Щоб виконати цю задачу, було задано нову переміну *username*, в яку і "покладемо" дані, які передаються в якості параметра.
За допомгою макроса ``module_param()`` відбувається передача параметрів модулю. Цей макрос приймає три параметра: *ім'я переміної, тип, біти прав доступу*. В даному випадку, це виглядає ось так:

.. code-block:: C

  module_param(username, charp, 0000)

де  *username* - назва зміної, *charp* - тип даних параметру(вказівник на рядок символів), *0000* - права доступу


Наступним завданням було:
	 добавить в init полученного модуля ядра тасклет, который также выведет текущее значение `Jiffies`_.
Декларація ``tasklet``. Для статичного створення тасклета (і відповідно, забезпечення прямого доступу до нього) необхідно використовувати один з макросів, які визначені в файлі ``<linux / interrupts.h>``, в даному випадку використовується:

 .. code-block:: C

  DECLARE_TASKLET(name, func, data);

Такий макрос статично створює екземпляр структи ``struct_tasklet_struct`` (структура визначенна у заголовочному файлі *linux/interrupt.h*) з вказаним ім'ям *name*. Коли тасклет запланований на виконання, то буде
викликатися функція *func*, в яку передається аргумент *data*. 
Вище згадана структура виглядає наступним чином:

 .. code-block:: C

  struct tasklet_struct {
 	  struct tasklet_struct *next;    // вказівник на наступний тасклет в списку 
 	  unsigned long state;            // стан тасклета 
  	  atomic_t count;                 // лічильник силок 
  	  void (*func)(unsigned long);    // функція обробки тасклета
  	  unsigned long data; 		  // аргумент функції обробки тасклета 
  );

Вигляд оголошення тасклета в даному випадку:

 .. code-block:: C

  DECLARE_TASKLET(tasklet, tasklet_jiffies, (unsigned long)NULL);


Планування виконання тасклета можливе за допомогою використання функції `tasklet_schedule()`, у яку в якості аргументу передається
вказівник на відповідний екземпляр в структі.
Існує три варіанта виклику цієї функції:

.. code-block:: C

  void tasklet_schedule(struct tasklet_struct *t);           // з нормальним пріоритетом
  void tasklet_hi_schedule(struct tasklet_struct *t);        // з високим пріоритетом
  void tasklet_hi_schedule_first(struct tasklet_struct *t);  // поза чергою

Функція `tasklet_kill()` отримує вказівник на відповідний екземпляр в структурі в якості аргумента. Така функція чекає спочатку, поки тасклет закінчить виконання, а потім вже виконує його видалення. 


Результат роботи
""""""""""""""""

Для початку збираємо модуль за допомогою команди ``make``.  Далі завантажуємо вихідний код модуля, передаючи йому задані параметри, а саме ім'я користувача. 

.. code-block:: 
  
  sudo insmod firstmod.ko username=Dana

Після цього дивимося лог ядра, а саме 5 його останніх рядків.
Команда для перегляду:

.. code-block:: 

  sudo dmesg -k | tail -5

Результат:

.. code-block:: 

  [30794.919018] Hello, Dana!
                  jiffies from init = 4304115656
  [30794.919037] Jiffies from tasklet = 4304115656

Наступним завданням було:
	Взять секундомер. Засечь время между двумя включениями модуля на x86 и BBXM.

Час очікування між двома включеннями модуля становить **10 хвилин** (600000мс).

**х86**
Результат, який отримали видно на наступному рисунку:

	.. image:: img/results_х86.jpg

:*початкове* значення ``jiffies``: 4295212727  
:*друге* значення ``jiffies``: 4295393703

**ВВХМ**
Результат для цієї платформи зображено на рисунки нижче: 

	.. image:: img/results_bbxm.JPG

:*початкове* значення ``jiffies``: 275207  
:*друге* значення ``jiffies``: 335238

Для того, щоб перевести дане значення у **ms** використовуємо формулу:

    +-----------------------------------+
    | ms_jiffies = jiffies * 1000 / HZ  |           
    +-----------------------------------+

де HZ = 300 для *x86*
HZ = 100  для *BBXM*

Розрахувавши потрібні значення, отримуємо такі результати:

:x86: 600310мс = 10,0052с
:ВВХМ: 603267мс = 10,054с 

Похибки розрахунків:

  +-------------------+
  | δ = (Δ/x) * 100%  |           
  +-------------------+

де Δ = x - x\ :sub:`i`\ , *x* - результат, який розрахували, x\ :sub:`i`\ - істинне значення.

+-----------+---------+
| Платформа | Похибка |
+===========+=========+
| x86       | 0,05%   |
+-----------+---------+
| ВВХМ      | 0,5%    |
+-----------+---------+

Висновок
~~~~~~~~

Похибку, яку отримали вище, можна пояснити, як похибкою користувача. Оскліьки, пройшло не рівно 10хв, а з певним відхиленням(як видно на рисунках вище, на секундомірі). Також при повторному виконанні ``insmod`` потрібно було ввести пароль для root-прав, на що також було витрачено деякий час. Але так як, похибка незначна і значення, майже, співпадають, то можна зробити висновок, що значення ``jiffies`` можна пов'язати із значенням реального часу. Також, видно, що значення jiffies з init i tasklet співпадає повністю. 


Використана література
~~~~~~~~~~~~~~~~~~~~~~

.. [1] https://www.tldp.org/LDP/lkmpg/2.6/html/x323.html




