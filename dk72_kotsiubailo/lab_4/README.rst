=============================================
Лабораторна робота №4
=============================================

Тема
------

**Потоки у ядрі та синхронізація**

Завдання:
-------
Написати та зібрати  власний модуль ядра, який:
* содержит глобальную переменную glob_var и параметры thread_num, thread_inccnt, thread_delay
* запускает thread_num потоков на одновременное выполнение
* каждый поток инкрементирует переменную glob_var thread_inccnt раз с задержкой thread_delay (может быть 0 — в этом случае, без задержки), кладет значение переменной в список и завершается
* при выгрузке модуль выводит значение переменной glob_var и содержимое списка
* для переменной, списка, потоков использовать динамическую аллокацию. Переменную передавать в поток аргументом
* предусматривает возможность досрочной выгрузки и будет нормально отрабатывать в этом случае

А також:
* Защитите увеличение счетчика, а также доступ к списку (и другим шареным элементам) механизмами блокировки и продемонстрируйте, что количество отсчетов правильное
* Сделайте второй вариант кода модуля, который бы использовал собственные реализации lock() и unlock() с использованием атомарных операций ядра (atomic.h, отличается в зависимости от архитектуры). Продемонстрируйте работоспособность. Можно использовать функцию xchg

Теорія
-----

Зв'язаний список - це найпростіша і одна з найчастіше використовуваних структур даних в ядрі Linux.
Вона дозволяє зберігати змінне число елементів, які називаються вузлами (nodes) списку, і маніпулювати ними.
На відміну від елементів статичного масиву, елементи пов'язаного списку можна динамічно створювати і розміщувати їх
в сам список. Це дозволяє на етапі виконання програми обробляти довільну кількість елементів,
які ще не існували під час компіляції програми, і точне їх число було невідомо.
Оскільки елементи створюються в різні ділянки часу виконання програми,
вони необов'язково повинні займати сусідні ділянки пам'яті комп'ютера. З цієї причини елементи потрібно якось пов'язати один з одним,
тобто в кожному елементі списку повинен зберігатися покажчик на наступний елемент.
Під час додавання або видалення елементів списку потрібно просто скорегувати покажчик на наступний вузол.

Також часто потрібно виконати в ядрі деякі операції в фоновому режимі. В ядрі така можливість реалізована у вигляді потоків
ядра (kernel thread) - звичайних процесів, які виконуються виключно в просторі ядра.
Істотною відмінністю між потоками ядра і звичайними процесами є те, що потоки в ядрі не мають свого
адресного простору. Ці потоки працюють тільки в просторі ядра, і їх контекст не переходить в простір
користувача. Проте потоки ядра плануються і витісняються так само, як і звичайні процеси.
Потік ядра може бути створений тільки іншим потоком ядра.
Інтерфейс для породження нового потоку ядра з існуючого описаний в файлі `` <linux / kthread.h> ``

Наступним важливим елементом, який буде розглянуто в рамках даної роботи буде механізми синхронізації в ядрі.
Визначення, необхідні для використання неподільних цілочисельних операцій, знаходяться в файлі `` <asm / atomic.h> ``.
Для деяких апаратних платформ існують додаткові унікальні засоби,
але для всіх апаратних платформ існує мінімальний набір операцій, які використовуються в ядрі всюди.
При написанні коду ядра необхідно переконатися в тому, що відповідні операції доступні і правильно реалізовані для всіх
апаратних платформ. Оголошення змінних типу `` atomic_t`` виконується як звичайно.
У міру необхідності можна встановити початкове значення цієї змінної за допомогою `` ATOMIC_INIT () ``

Однак через складність певних операцій, які повинні виконуватися неподільне, атомарних операцій може бути недостатньо.
Для цього використовують більш складні механізми. В ядрі `` Linux`` використовуються так звані спін-блокування (spin lock).
Це такий тип блокування, яка може бути захоплена не більше ніж в одному потоці команд.
Якщо в якомусь із потоків команд буде зроблена спроба захоплення спін-блокування,
яка утримується іншим потоком, виникає стан конфлікту.
При цьому перший потік входить в цикл і починає в ньому постійно перевіряти, чи не звільнилася чи вже необхідна блокування.
Оскільки код при цьому постійно знаходиться в циклі.
Якщо блокування вільна, потік може відразу ж її захопити і продовжити своє виконання.
Циклічна перевірка запобігає ситуацію, коли в критичній ділянці коду одночасно може перебувати більше
одного потоку команд. Одна і та ж спін-блокування може захоплюватися в різних місцях коду ядра.
В результаті завжди буде гарантований захист і синхронізація при доступі, наприклад, до якої-небудь структурі даних.

У ядрі Linux також можуть бути використані семафори (semaphore). Це блокування, які переводять процеси в стан
очікування. При спробі захоплення семафора, який вже захоплений іншим завданням,
поточна задача поміщається в чергу очікування і заморожується.
Після цього процесор переходить до виконання іншої задачі.
Як тільки необхідний семафор звільняється, одне із завдань, що знаходиться в черзі очікування, активізується,
після чого вона може захопити необхідний семафор.

Є певний перелік особливостей використання семафорів:

- Оскільки завдання, яка хоче захопити блокування, переводиться в стан очікування до моменту звільнення блокування,
  семафори добре підходять для реалізації блокувань, які можуть утримуватися протягом тривалого періоду часу.
- З іншого боку, не рекомендується використовувати семафори для реалізації блокувань, які утримуються
  протягом короткого періоду часу. Справа в тому, що затримки, пов'язані з перекладом процесів в стан очікування,
  обслуговування черги очікування і подальшої активізації процесу, можуть легко перевищити час,
  протягом якого утримується сама блокування.
- Так як в разі виникнення конфлікту при захопленні блокування потік
  буде переведений в стан очікування, семафори можна захоплювати тільки в контексті процесу.
  Справа в тому, що в контексті переривання потоки не обробляються планувальником.
- При утриманні семафора процес може переходити в стан очікування, хоча зазвичай так не роблять.
  Це не призведе до тупикової ситуації, коли інший процес спробує захопити ту ж блокування
  (Просто він переводиться в стан очікування і не заважає виконуватися першому процесу).
- При захопленні семафора не можна утримувати спін-блокування, оскільки процес може переходити в стан очікування
  до звільнення семафора, а при утриманні спін-блокування в стан очікування переходити не можна.

Останнім буде розглянуто механізм під назвою м'ютекс ( `` mutex``). М'ютекс представляється у вигляді структури mutex. Він веде себе так само, як і семафор, лічильник використання якого дорівнює
одиниці, але має більш простий інтерфейс, більш високу ефективність і накладає додаткові обмеження при
використанні.

Особливості м'ютексів наведені нижче:

- В один і той же момент часу м'ютекс може утримувати тільки одне задача.
  Іншими словами, лічильник використання мьютекса завжди дорівнює одиниці.
- Той процес, який захопив м'ютекс, повинен обов'язково його звільнити.
  Іншими словами, не можна захопити м'ютекс в одному контексті, а потім звільнити його в іншому.
  Це означає, що м'ютекс не придатний для вирішення складних завдань синхронізації між ядром і простором користувача.
  Проте в більшості випадків вони акуратно захоплюються і звільняються в одному і тому ж контексті.
- Повторні захоплення і звільнення м'ютексів не дозволяються. Це означає, що не можна повторно захопити
  той же самий м'ютекс і не можна звільнити вже звільнений м'ютекс.
- Процес не може завершити свою роботу до тих пір,
  поки він не звільнить м'ютекс.
- М'ютекс не можна захопити в обробнику переривань або в його нижній половині.

Хід роботи
-------

**Опис виконаної роботи** 

В ході роботи було написано модуль ядра мовою С.

Спочатку створено параметри модуля *thread_num*, *thread_delay* та *thread_inccnt* та додано їхні описи.

Далі було створено вказівник на потоки *thread*, глобальну змінну *glob_var*, та зв'язний список *data*.

Потім було створенно функцію-обробник для потоків *thread_func()*. У якій запускаємо цикл *for*, який *thread_inccnt* разів збільшує змінну *glob_var* на 1 із затримкою *thread_delay* мілісекунд, а також перевіряє, чи не викликав користувач раптом дострокове завершення потоку. Після закінчення циклу записуємо поточне значення змінної *glob_var* до списку, виводимо повідомлення про те, що потік завершився і виходимо з функції.

В даній роботі перевіряються введені параметри на корректність, виділяється пам'ять під масив структур, які описують потоки і безпосереднью створюються та запускаються потоки в *create_list_init *.

В * create_list_exit * функції зупиняємо потоки, звільнюємо пам'ять від масиву структур на потоки. Відображаємо в термінал вміст списку і фінальне значення змінної *glob_var*. І завершаємо роботу модуля.



Тести:

.. code-block:: bash


	/mnt # insmod no_lock.ko thread_num=15 thread_delay=0 thread_inccnt=1000
	/mnt # [   92.591396] thread is finished)
	[   92.598473] thread is finished)
	[   92.600160] thread is finished)
	[   92.600162] thread is finished)
	[   92.600214] thread is finished)
	[   92.600230] thread is finished)
	[   92.600265] thread is finished)
	[   92.600266] thread is finished)
	[   92.600283] thread is finished)
	[   92.600327] thread is finished)
	[   92.600341] thread is finished)
	[   92.600350] thread is finished)
	[   92.600363] thread is finished)
	[   92.600371] thread is finished)
	[   92.600382] thread is finished)
	/mnt # rmmod no_lock
	[   97.807584] glob_var per thread = 14734
	[   97.811375] glob_var per thread = 14736
	[   97.815106] glob_var per thread = 14746
	[   97.818358] glob_var per thread = 14746
	[   97.821618] glob_var per thread = 14746
	[   97.825049] glob_var per thread = 14746
	[   97.828319] glob_var per thread = 14746
	[   97.830785] glob_var per thread = 14746
	[   97.833670] glob_var per thread = 14746
	[   97.836376] glob_var per thread = 14746
	[   97.840640] glob_var per thread = 14746
	[   97.844136] glob_var per thread = 14746
	[   97.846643] glob_var per thread = 14746
	[   97.849226] glob_var per thread = 14746
	[   97.851887] glob_var per thread = 14746
	[   97.854401] Final glob_var is 14746
	[   97.856757] Goodbye:)
	/mnt # insmod kernel_lock.ko thread_num=15 thread_delay=0 thread_inccnt=1000
	/mnt # [ 2734.947281] thread is finished)
	[ 2734.949766] thread is finished)
	[ 2734.950173] thread is finished)
	[ 2734.950198] thread is finished)
	[ 2734.952132] thread is finished)
	[ 2734.952245] thread is finished)
	[ 2734.952444] thread is finished)
	[ 2734.955007] thread is finished)
	[ 2734.957059] thread is finished)
	[ 2734.958010] thread is finished)
	[ 2734.958511] thread is finished)
	[ 2734.959018] thread is finished)
	[ 2734.961075] thread is finished)
	[ 2734.964121] thread is finished)
	[ 2734.966248] thread is finished)
	/mnt # rmmod kernel_lock
	[ 2746.850777] glob_var per thread = 14967
	[ 2746.854511] glob_var per thread = 14967
	[ 2746.858190] glob_var per thread = 14972
	[ 2746.861532] glob_var per thread = 14976
	[ 2746.864793] glob_var per thread = 14978
	[ 2746.868263] glob_var per thread = 14981
	[ 2746.871984] glob_var per thread = 14981
	[ 2746.875440] glob_var per thread = 14985
	[ 2746.878759] glob_var per thread = 14993
	[ 2746.882186] glob_var per thread = 14994
	[ 2746.885642] glob_var per thread = 14994
	[ 2746.890903] glob_var per thread = 14994
	[ 2746.893276] glob_var per thread = 14997
	[ 2746.895625] glob_var per thread = 15000
	[ 2746.897363] glob_var per thread = 15000
	[ 2746.898526] Final glob_var is 15000
	[ 2746.899579] Goodbye:)
	/mnt # insmod my_lock.ko thread_num=15 thread_delay=0 thread_inccnt=1000
	/mnt # [ 2762.700196] thread is finished)
	[ 2762.704156] thread is finished)
	[ 2762.704233] thread is finished)
	[ 2762.704235] thread is finished)
	[ 2762.704301] thread is finished)
	[ 2762.706103] thread is finished)
	[ 2762.706314] thread is finished)
	[ 2762.706364] thread is finished)
	[ 2762.708153] thread is finished)
	[ 2762.708155] thread is finished)
	[ 2762.708212] thread is finished)
	[ 2762.709099] thread is finished)
	[ 2762.710112] thread is finished)
	[ 2762.710259] thread is finished)
	[ 2762.710305] thread is finished)
	/mnt # rmmod my_lock
	[ 2768.943851] glob_var per thread = 14967
	[ 2768.946793] glob_var per thread = 14981
	[ 2768.949695] glob_var per thread = 14988
	[ 2768.952561] glob_var per thread = 14988
	[ 2768.955562] glob_var per thread = 14991
	[ 2768.958716] glob_var per thread = 14991
	[ 2768.961550] glob_var per thread = 14993
	[ 2768.964259] glob_var per thread = 14994
	[ 2768.967089] glob_var per thread = 14998
	[ 2768.969829] glob_var per thread = 14998
	[ 2768.972687] glob_var per thread = 15000
	[ 2768.977328] glob_var per thread = 15000
	[ 2768.980187] glob_var per thread = 15000
	[ 2768.983010] glob_var per thread = 15000
	[ 2768.985872] glob_var per thread = 15000
	[ 2768.989439] Final glob_var is 15000
	[ 2768.992237] Goodbye:)

Висновки
-------	

в ході виконання роботи було створено модуль ядра для демонстрації роботи потоків списків та синхронізації. Загалом, зпочатку було створено модуль без синжронізації як видно з результатів відпрацювання модуля для коректної роботи модуля потрібно додатити синхронізацію до критичних частин коду, пілся додання синхронізації було отримано очікувані результати інкремент змінної відбувався корректно.

