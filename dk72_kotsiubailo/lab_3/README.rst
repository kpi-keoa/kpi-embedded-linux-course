=============================================
Лабораторна робота №3
=============================================

Тема
------

**Засоби відкладеної обробки, аллокація пам'яті**

Завдання:
-------
Переписати код з другої лабораторної роботи так, щоб замість звичайного таймера використовувався *hrtimer*.

Хід роботи
-------

**Опис виконаної роботи** 
В ході роботи в коді з другої лабораторної роботи звичайний таймер було замінено на таймер високої роздільної здатності. 
Таймери з високою роздільною здатністю (або hrtimers) забезпечують високоточну структуру управління таймерами, незалежно від раніше обговореної системи таймерів, через складність об'єднання двох фреймворків. Незважаючи на те, що таймери працюють на деталізованості jiffies, hrtimers працюють на деталізованості наносекунд.

Структура hrtimer реалізована інакше, ніж традиційний API таймера. Замість сегментів та каскаду таймерів, hrtimers підтримують впорядковану за часом структуру даних таймерів (таймери вставляються вчасно, щоб мінімізувати обробку під час активації). Використовувана структура даних - це червоно-чорне дерево, яке ідеально підходить для програм, орієнтованих на продуктивність (і, як правило, доступно загалом як бібліотека в ядрі).

Фреймворк hrtimer доступний як API всередині ядра, а також використовується додатками користувацького простору через nanosleep, itimers та інтерфейс портативних операційних систем (POSIX) -timers. Це було включено в ядро ​​2.6.21.
Було замінено структуру таймеру *timer_list* на *hrtimer* та додано змінну *period* типу *ktime_t*.

Змінено функцію-обробник для таймеру зі звичайної *void* на функцію типу *enum hrtimer_restart*, що є необхідною умовою для *hrtimers* так як ця функція повинна повертати значення, яке каже перезапускати таймер чи ні. Також у функції для таймеру було замінено функцію яка вказує коли потрібно наступного разу викликати функцію-обробник.

Далі параметр *delay* конвертується із секунд у тип *ktime* завдяки функції `ktime_set()`.

Далі ініціюємо *hrtimer*, вказуємо яка функція повинна виконуватись по таймеру і запускаємо його.

В *exit_callback* видаляємо таймер(так як він більше не потрібен).


Тести:

.. code-block:: bash

        / # insmod /mnt/lab3.ko cnt=1000 delay=1
        [  134.526864] 1 msec is 1 jiffies
        [  134.527385] Init jiffies is 4294801840
        [  134.527915] Tasklet jiffies is 4294801840
        / # rmmod lab3
        [  157.265037] Exit jiffies is 4294824577
        [  157.265852] Array isn't full
        [  157.266216] Array[0] = 4294802841
        [  157.266422] Array[1] = 4294803852
        [  157.266749] Array[2] = 4294804843
        [  157.266944] Array[3] = 4294805844
        [  157.267266] Array[4] = 4294806842
        [  157.267512] Array[5] = 4294807847
        [  157.267730] Array[6] = 4294808843
        [  157.267944] Array[7] = 4294809856
        [  157.268594] Array[8] = 4294810842
        [  157.268820] Array[9] = 4294811842
        [  157.269189] Array[10] = 4294812841
        [  157.269415] Array[11] = 4294813853
        [  157.269664] Array[12] = 4294814841
        [  157.269884] Array[13] = 4294815858
        [  157.270219] Array[14] = 4294816841
        [  157.270467] Array[15] = 4294817845
        [  157.270690] Array[16] = 4294818843
        [  157.270994] Array[17] = 4294819847
        [  157.271217] Array[18] = 4294820841
        [  157.271509] Array[19] = 4294821846
        [  157.271743] Array[20] = 4294822840
        [  157.271972] Array[21] = 4294823849
        [  157.272573] Goodbye:)




Висновки
-------
В ході роботи було переписано код з лабораторної роботи №2 так, щоб замість звичайних таймерів використовувався *hrtimer*. Виконану роботу описано вище. В порівнянні з попередньою лабораторною роботою в цій *jiffies* кожного разу відрізняється на *delay*+1(час від часу).
*hrtimer* відрізняється від звичайного тим, що він має більшу роздільну здатність(*hrtimer* -> наносекунди, звичайний -> мілісекунди).



