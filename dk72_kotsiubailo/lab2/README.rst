=================================================
**Лабораторна робота №2 засоби відкладеної роботи: тасклети таймери**
=================================================


Завдання
---------------
* ознайомитись з зазначеною документацією
* на основі отриманих знань створити модуль  ядра що приймати 2 параметри з командної строки cnt та delay. При запуску init молдуль повинен з початку вивести поточне зеначення jiffies потім потрібно запустити тасклет 
що зробить те саме. Далі потрібно запустити таймер що повторно запуститься cnt разів із затримкою delay 


**Теорія**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
У модулях ядра можна використовувати механізми відкладених переривань і тасклетів. Тасклети - це механізм побудови bottom half (нижніх половин) обробників (рус.обрабочиков - не знаю як правильно украънською) переривань на основі механізму відкладених переривань. 
 За своєю природою і принципом роботи вони дуже схожі на відкладені переривання, але мають більш простий інтерфейс і спрощені правила блокувань. 
Тасклети представляються у вигляді структури tasklet_struct. Кожен екземпляр структури являє собою унікальний тасклет. Ця структура визначена у файлі linux / interrupt.h. Задекларувати тасклет можна за допомогою макросу DECLARE_TASKLET або вручну через ініціалізацію примірника структури tasklet_struct.
 Також необхідно описати функцію-обробник тасклета. Запланувати виконання таксклета можна за допомогою tasklet_schedule (& <tasklet_name>). Коли тасклет запланований на виконання, ядро ​​генерує одне з двох відкладених переривань. Відкладені переривання, в свою чергу, обробляються за допомогою спеціальних функцій, в яких запускаються всі заплановані на виконання тасклети.
 У цих функціях вжито заходи, які дозволяють гарантувати, що тільки один тасклет даного типу буде виконуватися в будь-який момент часу . Після планування тасклета на виконання він буде запущений всього один раз в деякий момент часу в найближчому майбутньому. Якщо до запуску тасклет буде запланований на виконання ще раз, то він також запуститься всього один раз.

Для синхронізації процесів в системі і управління системним часом використовується системний таймер, який тактується від кварцового резонатора з постійною і досить точної частотою, забезпечуючи стабільність роботи таймера. По закінченню періоду роботи таймера, процесору передається сигнал і виникає переривання зі своїм обробником (обработчиком). Частота імпульсів системного таймера (tick rate) програмується при завантаженні системи на підставі
 значення статично визначеної директиви препроцесора HZ. Значення параметра HZ залежить від використовуваної апаратної платформи. Є дві думки щодо вибору значення HZ: порядок сотні або порядок тисячі. Велике значення HZ дозволяє запускати переривання по таймеру більш часто і поліпшити точність визначення часу, коректніше витісняти завдання. Але існує проблема підвищення витрат за рахунок більш частого уваги на обробник таймера. Що може привести до 
зменшення часу уваги процесора на інші процеси, а також передчасно очищає кеш. У певних умовах все це зменшує продуктивність.

Хід роботи
---------

Спочатку було створено 2 параметри модуля *cnt* та *delay*. Додано їхні описи. 
Потім створено вказівник на перший елемент головного масиву *array*. Створено структуру для таймеру *my_timer* та 2 тимчасових лічильника *i* та *cnt_t*.
Створено функцію для тасклету `tasklet_funk(unsigned long arg)`, яка виводить значення *jiffies* на момент виклику тасклету. Далі задекларовано тасклет. І створено функцію для таймера, яка *cnt* разів записує до *array* значення *jiffies* на момент виклику цієї функції.
Далі в init_callback в першу чергу перевіряємо корректність введених *cnt* та *delay*. Потім виділяємо пам'ять для *array* за допомогою функції `kzalloc()`(тому що він виділяє пам'ять і відразу заповнює її нулями) і відразу перевіряємо, чи змогла ця функція виділити необхідну пам'ять.
Оскільки *delay* має одиницю вимірювання мілісекунди, то вказуємо яке значення *jiffies* відповідає такому *delay*.
Виводимо поточне значення *jiffies*. Далі запускаємо тасклет і "знищуємо" його, так як він більше не потрібен. 
Ініціюємо таймер та запускаємо його.
Далі в *exit_callback* видаляємо таймер(так як він більше не потрібен). Виводимо поточне значення *jiffies*.  
Якщо на момент завершення роботи модуля, *array* ще не було заповнено, то виводимо відповідне повідомлення і виводимо всі значення *array* які є в наявності.
Звільняємо пам'ять від *array* і прощаємось з користувачем.


Демонстрація роботи
---------
.. code-block:: bash

/ # insmod /mnt/lab2.ko cnt=3425 delay=523
[  291.125175] 523 msec is 523 jiffies
[  291.125597] Init jiffies is 4294958441
[  291.126003] Tasklet jiffies is 4294958441
/ # rmmod lab2
[  310.774988] Exit jiffies is 4294978090
[  310.775252] Array isn't full
[  310.775598] Array[0] = 4294958979
[  310.775923] Array[1] = 4294959555
[  310.776186] Array[2] = 4294960142
[  310.776440] Array[3] = 4294960713
[  310.777073] Array[4] = 4294961291
[  310.777616] Array[5] = 4294961862
[  310.778065] Array[6] = 4294962438
[  310.778408] Array[7] = 4294963020
[  310.778571] Array[8] = 4294963594
[  310.778571] Array[9] = 4294964172
[  310.778571] Array[10] = 4294964747
[  310.778571] Array[11] = 4294965316
[  310.778571] Array[12] = 4294965913
[  310.778571] Array[13] = 4294966470
[  310.778571] Array[14] = 4294967047
[  310.781085] Array[15] = 4294967618
[  310.781380] Array[16] = 4294968197
[  310.781875] Array[17] = 4294968770
[  310.782294] Array[18] = 4294969345
[  310.782552] Array[19] = 4294969923
[  310.782732] Array[20] = 4294970499
[  310.783114] Array[21] = 4294971080
[  310.783475] Array[22] = 4294971654
[  310.783794] Array[23] = 4294972226
[  310.783961] Array[24] = 4294972813
[  310.784123] Array[25] = 4294973379
[  310.784437] Array[26] = 4294974144
[  310.784683] Array[27] = 4294974721
[  310.784762] Array[28] = 4294975298
[  310.784762] Array[29] = 4294975879
[  310.784762] Array[30] = 4294976454
[  310.784762] Array[31] = 4294977032
[  310.784762] Array[32] = 4294977618
[  310.785997] Goodbye:)


Висновки
---------

в результаті роботи було створено свій модуль ядра, роботу та структуру якого описано вище, Jiffies в init та tasklet відрізняються,
тому що від початку ініціалізації і до ``botom half`` де і запускається хендлер тасклету прохходить багато часу,  GFP_KERNEL використовується чререз те 
що ми алокуємо пам'ять в процеісі а не в скедюалері тобто можемо дати можливість процесу поспати чекаючи звільнення простору для алокації пам'яті. використання данного флагу 
при алокації пам'яті в скедюалері може призвести до дедлоку. При delay рівним нулю таймер буде
відпрацьовувати з мінімальною затримкою, зазвичай це 1 такт.
