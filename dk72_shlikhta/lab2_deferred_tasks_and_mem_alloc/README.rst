=============================================
Лабораторна робота №1
=============================================

Тема
------

**Засоби відкладеної обробки, аллокація пам'яті**

Завдання:
-------
Написати модуль ядра, який:
	* Приймає 2 параметри *cnt* і *delay*
		- *cnt* є кількістю циклів, які повинен опрацювати таймер
		- *delay* є затримкою між двома спрацюваннями таймера
		- Модуль повинен відпрацьовувати при *cnt* і *delay* рівних нулю
	* Спочатку *init* друкує поточне значення *jiffies* в лог ядра
	* Потім запускає тасклет, котрий повинен надрукувати своє значення *jiffies* в лог ядра
	* Потім виділяє масив розміру *cnt*, використовуючи динамічну алокацію
	* Потім *init* запускає таймер з затримкою *delay* і функція завершується
		- При спрацюванні таймер кладе поточне значення *jiffies* до масиву і перезапускається з затримкою *delay*
		- Загальна кількість разів, які запускається таймер дорівнює *cnt*
	* В *exit* модуль повинен надрукувати поточне значення *jiffies* і вивести всі значення з масиву

Хід роботи
-------

**Опис виконаної роботи** 
В ході роботи було проглянуто рекомендовану літературу та написано модуль ядра мовою *C*.

Спочатку було створено 2 параметри модуля *cnt* та *delay*. Додано їхні описи. 
Потім створено вказівник на перший елемент головного масиву *array*. Створено структуру для таймеру *my_timer* та 2 тимчасових лічильника *i* та *tmp_cnt*.

Створено функцію для тасклету `tasklet_foo(unsigned long arg)`, яка виводить значення *jiffies* на момент виклику тасклету. Далі задекларовано тасклет. І створено функцію для таймера, яка *cnt* разів записує до *array* значення *jiffies* на момент виклику цієї функції.

Далі в init_callback в першу чергу перевіряємо корректність введених *cnt* та *delay*. Потім виділяємо пам'ять для *array* за допомогою функції `kzalloc()`(тому що він виділяє пам'ять і відразу заповнює її нулями) і відразу перевіряємо, чи змогла ця функція виділити необхідну пам'ять.

Оскільки *delay* має одиницю вимірювання мілісекунди, то вказуємо яке значення *jiffies* відповідає такому *delay*.

Виводимо поточне значення *jiffies*. Далі запускаємо тасклет і "знищуємо" його, так як він більше не потрібен. 

Ініціюємо таймер та запускаємо його.

Далі в *exit_callback* видаляємо таймер(так як він більше не потрібен). Виводимо поточне значення *jiffies*.  

Якщо на момент завершення роботи модуля, *array* ще не було заповнено, то виводимо відповідне повідомлення і виводимо всі значення *array* які є в наявності.

Звільняємо пам'ять від *array* і прощаємось з користувачем.


Тести:

.. code-block:: bash

	/mnt # insmod lab_2.ko cnt=1234 delay=-1234
	[  222.563378] Invalid <delay> < 0 :(
	insmod: can't insert 'lab_2.ko': invalid parameter
	/mnt # insmod lab_2.ko delay=-1234
	[  258.064908] Invalid <cnt> <= 0 :(
	insmod: can't insert 'lab_2.ko': invalid parameter
	/mnt # insmod lab_2.ko cnt=1234 delay=1234
	[  164.697127] 1234 msec is 1234 jiffies
	[  164.701081] Init jiffies is 4294831881
	[  164.704006] Tasklet jiffies is 4294831884
	/mnt # rmmod lab_2
	[  174.224972] Exit jiffies is 4294841405
	[  174.228195] Array isn't full
	[  174.230113] Array[0] = 4294831888
	[  174.232279] Array[1] = 4294833152
	[  174.234738] Array[2] = 4294834432
	[  174.236989] Array[3] = 4294835712
	[  174.239143] Array[4] = 4294836992
	[  174.241491] Array[5] = 4294838272
	[  174.245003] Array[6] = 4294839552
	[  174.246972] Array[7] = 4294840832
	[  174.248902] Goodbye:)
	/mnt # insmod lab_2.ko cnt=10 delay=100
	[   88.161392] 100 msec is 100 jiffies
	[   88.165361] Init jiffies is 4294755346
	[   88.168277] Tasklet jiffies is 4294755349
	/mnt # rmmod lab_2
	[   99.440835] Exit jiffies is 4294766621
	[   99.443983] Array[0] = 4294755353
	[   99.447281] Array[1] = 4294755456
	[   99.449929] Array[2] = 4294755560
	[   99.452348] Array[3] = 4294755664
	[   99.454750] Array[4] = 4294755768
	[   99.457846] Array[5] = 4294755872
	[   99.460518] Array[6] = 4294755976
	[   99.462824] Array[7] = 4294756080
	[   99.465989] Array[8] = 4294756184
	[   99.469127] Array[9] = 4294756288
	[   99.471660] Goodbye:)
	/mnt # insmod lab_2.ko cnt=1234 delay=10000
	[ 3645.424303] 10000 msec is 10000 jiffies
	[ 3645.427190] Init jiffies is 4298312607
	[ 3645.427994] Tasklet jiffies is 4298312608
	/mnt # rmmod lab_2
	[ 3723.185795] Exit jiffies is 4298390366
	[ 3723.189025] Array isn't full
	[ 3723.190403] Array[0] = 4298312610
	[ 3723.191117] Array[1] = 4298322944
	[ 3723.191825] Array[2] = 4298333184
	[ 3723.192535] Array[3] = 4298343424
	[ 3723.193236] Array[4] = 4298353664
	[ 3723.193928] Array[5] = 4298363904
	[ 3723.194594] Array[6] = 4298374144
	[ 3723.195216] Array[7] = 4298384384
	[ 3723.195836] Goodbye:)

Висновки
-------
В ході роботи було написано, зібрано та протестовано власний модуль ядра. Він відповідає завданню.

	1. *jiffies*, яке друкується в *init* і яке виводиться тасклетом відрізняється тому що між цими двома подіями проходить деякий час, а також потік модуля міг перериватись
	2. При виділенні пам'яті використовувався флаг `GFP_KERNEL` тому що(на скільки я зрозумів) `GFP_KERNEL` "заганяє" процес, який викликав функцію виділення пам'яті, в "сон" і при відсутності вільної необхідної кількості пам'яті намагається виконати певні дії для того, щоб ця пам'ять "з'явилась". На це все потрібен час. І оскільки процес, який викликав функцію виділення пам'яті не критичний до часу, то було використано саме цей флаг.
	3. *jiffies* між двома запусками таймера дорівнює `msecs_to_jiffies(delay)` + деяке невелике число. Так відбувається(на скільки я зрозумів) тому, що ми зчитуємо значення *jiffies* не в момент, коли воно змінюється і ми перейшли у обробник таймеру. І при великих *delay* ця різниця також стає більшою
	4. Таймер буде викликатися максимально часто, як тільки зможе(1 jiffies) 


