=============================================
Лабораторна робота №0
=============================================

Тема
------

**Робота з потоками**

Завдання:
-------
Написати код в якому:
* Завести глобальну змінну з нульовим початковим значенням
* Створити функцію потоку, яка N разів додає до цієї глобальної змінної К
* Запустити 2 потоки з цією функцією
* Дочекатися завершення потоків, використовуючи `pthread_join()`
* Вивести у *stdout* очікуване і фактичне значення глобальної змінної

Хід роботи
-------

**Опис виконаної роботи** 
	В ході роботи було написано програмний код мовою *С* та Makefie 
для прискорення та спрощення процесу збирання проекту(для розробника). Також код було скомпільовано у трьох варіантах:
1. З оптимізацією -О0
2. З оптимізацією -О2
3. З оптимізацією -О2 і модифікатором змінної `volatile`

У випадках №1 і №3 очікуване та фактичне значення відрізняються. Мною було помічено, що фактичне значення може змінюватися при нових запусках програми з незмінними вхідними значеннями. Також у випадках №1 та №3 час виконання програми прямо залежить від кількості ітерацій додавання.
При малих значеннях доданку(K) та кількості ітерацій додавання(N) такого "ефекту" не спостерігалось.

Що стосовно випадку №2, то тут при будь яких значеннях N і K очікуване та фактичне значення глобальної змінної завжди однакове. Також виконання коду виконується дуже швидко в порівнянні з випадками №1 та №3 при одних і тих же(великих) вхідних значеннях.

Аналізуючи асемблерні лістинги для всіх трьох випадків можка отримати наступне:
* У випадках №1 та №3 для глобальної змінної відсутня оптимізація, тобто додавання до глобальної змінної відбувається у 3 етапи:
    - Зчитали значення змінної до регістру
    - Додали потрібне число
    - Записали нове значення у змінну
І між зчитуванням і записом одного потоку може "вклинитись" інший поток спочатку один запише своє значення змінної до пам'яті, а потім інший. В результаті ми отримуємо неправильне значення глобальної змінної
* У випадку ж №2 включено другий рівень оптимізації. Тут компілятор "зарання" прораховує резулютуюче значення змінної і за 1 раз записує його до пам'яті. Саме тому код з оптимізацією -O2 завжди видавав корректне значення і "обраховував" його дуже швидко.



Висновки
-------
З вище сказаного слідує наступне: щоб код виконувався швидше і видавав правильний результат(у проектах накшталт нашого) слід використовувати оптимізацію, але при цьому слід враховувати, що часом компілятор може аж "занадто" оптимізовувати код і від цього він навпаки буде працювати гірше. Саме тому слід використовувати модифікатор *volatile*, що вкаже компілятору не проводити ніяких оптимізацій в роботі зі зміною. Але при цьому код буде працювати повільніше, а також можливі ситуації накшталт нашої, коли 2 потоки "конкурують" і можуть записати дані до пам'яті коли інший поток ще не завершив роботу з даною коміркою і як результат ми отримуємо невалідні дані.


